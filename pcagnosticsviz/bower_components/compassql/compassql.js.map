{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/browser-resolve/empty.js",
    "node_modules/datalib/node_modules/d3-time/build/d3-time.js",
    "node_modules/datalib/src/bins/bins.js",
    "node_modules/datalib/src/generate.js",
    "node_modules/datalib/src/import/type.js",
    "node_modules/datalib/src/stats.js",
    "node_modules/datalib/src/time.js",
    "node_modules/datalib/src/util.js",
    "node_modules/json-stable-stringify/index.js",
    "node_modules/jsonify/index.js",
    "node_modules/jsonify/lib/parse.js",
    "node_modules/jsonify/lib/stringify.js",
    "node_modules/vega-lite/src/aggregate.js",
    "node_modules/vega-lite/src/axis.js",
    "node_modules/vega-lite/src/bin.js",
    "node_modules/vega-lite/src/channel.js",
    "node_modules/vega-lite/src/datetime.js",
    "node_modules/vega-lite/src/encoding.js",
    "node_modules/vega-lite/src/mark.js",
    "node_modules/vega-lite/src/scale.js",
    "node_modules/vega-lite/src/sort.js",
    "node_modules/vega-lite/src/stack.js",
    "node_modules/vega-lite/src/timeunit.js",
    "node_modules/vega-lite/src/type.js",
    "node_modules/vega-lite/src/util.js",
    "src/config.js",
    "src/constraint/base.js",
    "src/constraint/constraint.js",
    "src/constraint/encoding.js",
    "src/constraint/spec.js",
    "src/cql.js",
    "src/enumerator.js",
    "src/enumspec.js",
    "src/enumspecindex.js",
    "src/generate.js",
    "src/model.js",
    "src/nest.js",
    "src/property.js",
    "src/query/encoding.js",
    "src/query/groupby.js",
    "src/query/query.js",
    "src/query/shorthand.js",
    "src/query/spec.js",
    "src/query/transform.js",
    "src/ranking/aggregation.js",
    "src/ranking/effectiveness/channel.js",
    "src/ranking/effectiveness/effectiveness.js",
    "src/ranking/effectiveness/mark.js",
    "src/ranking/effectiveness/type.js",
    "src/ranking/fieldorder.js",
    "src/ranking/ranking.js",
    "src/schema.js",
    "src/stylize.js",
    "src/util.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACz1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.1\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));",
    "var util = require('../util'),\r\n    time = require('../time'),\r\n    EPSILON = 1e-15;\r\n\r\nfunction bins(opt) {\r\n  if (!opt) { throw Error(\"Missing binning options.\"); }\r\n\r\n  // determine range\r\n  var maxb = opt.maxbins || 15,\r\n      base = opt.base || 10,\r\n      logb = Math.log(base),\r\n      div = opt.div || [5, 2],\r\n      min = opt.min,\r\n      max = opt.max,\r\n      span = max - min,\r\n      step, level, minstep, precision, v, i, eps;\r\n\r\n  if (opt.step) {\r\n    // if step size is explicitly given, use that\r\n    step = opt.step;\r\n  } else if (opt.steps) {\r\n    // if provided, limit choice to acceptable step sizes\r\n    step = opt.steps[Math.min(\r\n      opt.steps.length - 1,\r\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\r\n    )];\r\n  } else {\r\n    // else use span to determine step size\r\n    level = Math.ceil(Math.log(maxb) / logb);\r\n    minstep = opt.minstep || 0;\r\n    step = Math.max(\r\n      minstep,\r\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\r\n    );\r\n\r\n    // increase step size if too many bins\r\n    while (Math.ceil(span/step) > maxb) { step *= base; }\r\n\r\n    // decrease step size if allowed\r\n    for (i=0; i<div.length; ++i) {\r\n      v = step / div[i];\r\n      if (v >= minstep && span / v <= maxb) step = v;\r\n    }\r\n  }\r\n\r\n  // update precision, min and max\r\n  v = Math.log(step);\r\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\r\n  eps = Math.pow(base, -precision - 1);\r\n  min = Math.min(min, Math.floor(min / step + eps) * step);\r\n  max = Math.ceil(max / step) * step;\r\n\r\n  return {\r\n    start: min,\r\n    stop:  max,\r\n    step:  step,\r\n    unit:  {precision: precision},\r\n    value: value,\r\n    index: index\r\n  };\r\n}\r\n\r\nfunction bisect(a, x, lo, hi) {\r\n  while (lo < hi) {\r\n    var mid = lo + hi >>> 1;\r\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\r\n    else { hi = mid; }\r\n  }\r\n  return lo;\r\n}\r\n\r\nfunction value(v) {\r\n  return this.step * Math.floor(v / this.step + EPSILON);\r\n}\r\n\r\nfunction index(v) {\r\n  return Math.floor((v - this.start) / this.step + EPSILON);\r\n}\r\n\r\nfunction date_value(v) {\r\n  return this.unit.date(value.call(this, v));\r\n}\r\n\r\nfunction date_index(v) {\r\n  return index.call(this, this.unit.unit(v));\r\n}\r\n\r\nbins.date = function(opt) {\r\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\r\n\r\n  // find time step, then bin\r\n  var units = opt.utc ? time.utc : time,\r\n      dmin = opt.min,\r\n      dmax = opt.max,\r\n      maxb = opt.maxbins || 20,\r\n      minb = opt.minbins || 4,\r\n      span = (+dmax) - (+dmin),\r\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\r\n      spec = bins({\r\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\r\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\r\n        maxbins: maxb,\r\n        minstep: unit.minstep,\r\n        steps:   unit.step\r\n      });\r\n\r\n  spec.unit = unit;\r\n  spec.index = date_index;\r\n  if (!opt.raw) spec.value = date_value;\r\n  return spec;\r\n};\r\n\r\nmodule.exports = bins;\r\n",
    "var util = require('./util'),\r\n    gen = module.exports;\r\n\r\ngen.repeat = function(val, n) {\r\n  var a = Array(n), i;\r\n  for (i=0; i<n; ++i) a[i] = val;\r\n  return a;\r\n};\r\n\r\ngen.zeros = function(n) {\r\n  return gen.repeat(0, n);\r\n};\r\n\r\ngen.range = function(start, stop, step) {\r\n  if (arguments.length < 3) {\r\n    step = 1;\r\n    if (arguments.length < 2) {\r\n      stop = start;\r\n      start = 0;\r\n    }\r\n  }\r\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\r\n  var range = [], i = -1, j;\r\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\r\n  else while ((j = start + step * ++i) < stop) range.push(j);\r\n  return range;\r\n};\r\n\r\ngen.random = {};\r\n\r\ngen.random.uniform = function(min, max) {\r\n  if (max === undefined) {\r\n    max = min === undefined ? 1 : min;\r\n    min = 0;\r\n  }\r\n  var d = max - min;\r\n  var f = function() {\r\n    return min + d * Math.random();\r\n  };\r\n  f.samples = function(n) {\r\n    return gen.zeros(n).map(f);\r\n  };\r\n  f.pdf = function(x) {\r\n    return (x >= min && x <= max) ? 1/d : 0;\r\n  };\r\n  f.cdf = function(x) {\r\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\r\n  };\r\n  f.icdf = function(p) {\r\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\r\n  };\r\n  return f;\r\n};\r\n\r\ngen.random.integer = function(a, b) {\r\n  if (b === undefined) {\r\n    b = a;\r\n    a = 0;\r\n  }\r\n  var d = b - a;\r\n  var f = function() {\r\n    return a + Math.floor(d * Math.random());\r\n  };\r\n  f.samples = function(n) {\r\n    return gen.zeros(n).map(f);\r\n  };\r\n  f.pdf = function(x) {\r\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\r\n  };\r\n  f.cdf = function(x) {\r\n    var v = Math.floor(x);\r\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\r\n  };\r\n  f.icdf = function(p) {\r\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\r\n  };\r\n  return f;\r\n};\r\n\r\ngen.random.normal = function(mean, stdev) {\r\n  mean = mean || 0;\r\n  stdev = stdev || 1;\r\n  var next;\r\n  var f = function() {\r\n    var x = 0, y = 0, rds, c;\r\n    if (next !== undefined) {\r\n      x = next;\r\n      next = undefined;\r\n      return x;\r\n    }\r\n    do {\r\n      x = Math.random()*2-1;\r\n      y = Math.random()*2-1;\r\n      rds = x*x + y*y;\r\n    } while (rds === 0 || rds > 1);\r\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\r\n    next = mean + y*c*stdev;\r\n    return mean + x*c*stdev;\r\n  };\r\n  f.samples = function(n) {\r\n    return gen.zeros(n).map(f);\r\n  };\r\n  f.pdf = function(x) {\r\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\r\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\r\n  };\r\n  f.cdf = function(x) {\r\n    // Approximation from West (2009)\r\n    // Better Approximations to Cumulative Normal Functions\r\n    var cd,\r\n        z = (x - mean) / stdev,\r\n        Z = Math.abs(z);\r\n    if (Z > 37) {\r\n      cd = 0;\r\n    } else {\r\n      var sum, exp = Math.exp(-Z*Z/2);\r\n      if (Z < 7.07106781186547) {\r\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\r\n        sum = sum * Z + 6.37396220353165;\r\n        sum = sum * Z + 33.912866078383;\r\n        sum = sum * Z + 112.079291497871;\r\n        sum = sum * Z + 221.213596169931;\r\n        sum = sum * Z + 220.206867912376;\r\n        cd = exp * sum;\r\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\r\n        sum = sum * Z + 16.064177579207;\r\n        sum = sum * Z + 86.7807322029461;\r\n        sum = sum * Z + 296.564248779674;\r\n        sum = sum * Z + 637.333633378831;\r\n        sum = sum * Z + 793.826512519948;\r\n        sum = sum * Z + 440.413735824752;\r\n        cd = cd / sum;\r\n      } else {\r\n        sum = Z + 0.65;\r\n        sum = Z + 4 / sum;\r\n        sum = Z + 3 / sum;\r\n        sum = Z + 2 / sum;\r\n        sum = Z + 1 / sum;\r\n        cd = exp / sum / 2.506628274631;\r\n      }\r\n    }\r\n    return z > 0 ? 1 - cd : cd;\r\n  };\r\n  f.icdf = function(p) {\r\n    // Approximation of Probit function using inverse error function.\r\n    if (p <= 0 || p >= 1) return NaN;\r\n    var x = 2*p - 1,\r\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\r\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\r\n        b = Math.log(1 - (x*x)) / v,\r\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\r\n    return mean + stdev * Math.SQRT2 * s;\r\n  };\r\n  return f;\r\n};\r\n\r\ngen.random.bootstrap = function(domain, smooth) {\r\n  // Generates a bootstrap sample from a set of observations.\r\n  // Smooth bootstrapping adds random zero-centered noise to the samples.\r\n  var val = domain.filter(util.isValid),\r\n      len = val.length,\r\n      err = smooth ? gen.random.normal(0, smooth) : null;\r\n  var f = function() {\r\n    return val[~~(Math.random()*len)] + (err ? err() : 0);\r\n  };\r\n  f.samples = function(n) {\r\n    return gen.zeros(n).map(f);\r\n  };\r\n  return f;\r\n};",
    "var util = require('../util');\r\n\r\nvar TYPES = '__types__';\r\n\r\nvar PARSERS = {\r\n  boolean: util.boolean,\r\n  integer: util.number,\r\n  number:  util.number,\r\n  date:    util.date,\r\n  string:  function(x) { return x == null || x === '' ? null : x + ''; }\r\n};\r\n\r\nvar TESTS = {\r\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\r\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\r\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\r\n  date: function(x) { return !isNaN(Date.parse(x)); }\r\n};\r\n\r\nfunction annotation(data, types) {\r\n  if (!types) return data && data[TYPES] || null;\r\n  data[TYPES] = types;\r\n}\r\n\r\nfunction fieldNames(datum) {\r\n  return util.keys(datum);\r\n}\r\n\r\nfunction bracket(fieldName) {\r\n  return '[' + fieldName + ']';\r\n}\r\n\r\nfunction type(values, f) {\r\n  values = util.array(values);\r\n  f = util.$(f);\r\n  var v, i, n;\r\n\r\n  // if data array has type annotations, use them\r\n  if (values[TYPES]) {\r\n    v = f(values[TYPES]);\r\n    if (util.isString(v)) return v;\r\n  }\r\n\r\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n  }\r\n\r\n  return util.isDate(v) ? 'date' :\r\n    util.isNumber(v)    ? 'number' :\r\n    util.isBoolean(v)   ? 'boolean' :\r\n    util.isString(v)    ? 'string' : null;\r\n}\r\n\r\nfunction typeAll(data, fields) {\r\n  if (!data.length) return;\r\n  var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);\r\n  return fields.reduce(function(types, f) {\r\n    return (types[f] = type(data, get(f)), types);\r\n  }, {});\r\n}\r\n\r\nfunction infer(values, f, ignore) {\r\n  values = util.array(values);\r\n  f = util.$(f);\r\n  var i, j, v;\r\n\r\n  // types to test for, in precedence order\r\n  var types = ['boolean', 'integer', 'number', 'date'];\r\n\r\n  for (i=0; i<values.length; ++i) {\r\n    // get next value to test\r\n    v = f ? f(values[i]) : values[i];\r\n    // test value against remaining types\r\n    for (j=0; j<types.length; ++j) {\r\n      if ((!ignore || !ignore.test(v)) && util.isValid(v) && !TESTS[types[j]](v)) {\r\n        types.splice(j, 1);\r\n        j -= 1;\r\n      }\r\n    }\r\n    // if no types left, return 'string'\r\n    if (types.length === 0) return 'string';\r\n  }\r\n\r\n  return types[0];\r\n}\r\n\r\nfunction inferAll(data, fields, ignore) {\r\n  var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);\r\n  return fields.reduce(function(types, f) {\r\n    types[f] = infer(data, get(f), ignore);\r\n    return types;\r\n  }, {});\r\n}\r\n\r\ntype.annotation = annotation;\r\ntype.all = typeAll;\r\ntype.infer = infer;\r\ntype.inferAll = inferAll;\r\ntype.parsers = PARSERS;\r\nmodule.exports = type;\r\n",
    "var util = require('./util');\r\nvar type = require('./import/type');\r\nvar gen = require('./generate');\r\n\r\nvar stats = module.exports;\r\n\r\n// Collect unique values.\r\n// Output: an array of unique values, in first-observed order\r\nstats.unique = function(values, f, results) {\r\n  f = util.$(f);\r\n  results = results || [];\r\n  var u = {}, v, i, n;\r\n  for (i=0, n=values.length; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (v in u) continue;\r\n    u[v] = 1;\r\n    results.push(v);\r\n  }\r\n  return results;\r\n};\r\n\r\n// Return the length of the input array.\r\nstats.count = function(values) {\r\n  return values && values.length || 0;\r\n};\r\n\r\n// Count the number of non-null, non-undefined, non-NaN values.\r\nstats.count.valid = function(values, f) {\r\n  f = util.$(f);\r\n  var v, i, n, valid = 0;\r\n  for (i=0, n=values.length; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) valid += 1;\r\n  }\r\n  return valid;\r\n};\r\n\r\n// Count the number of null or undefined values.\r\nstats.count.missing = function(values, f) {\r\n  f = util.$(f);\r\n  var v, i, n, count = 0;\r\n  for (i=0, n=values.length; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (v == null) count += 1;\r\n  }\r\n  return count;\r\n};\r\n\r\n// Count the number of distinct values.\r\n// Null, undefined and NaN are each considered distinct values.\r\nstats.count.distinct = function(values, f) {\r\n  f = util.$(f);\r\n  var u = {}, v, i, n, count = 0;\r\n  for (i=0, n=values.length; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (v in u) continue;\r\n    u[v] = 1;\r\n    count += 1;\r\n  }\r\n  return count;\r\n};\r\n\r\n// Construct a map from distinct values to occurrence counts.\r\nstats.count.map = function(values, f) {\r\n  f = util.$(f);\r\n  var map = {}, v, i, n;\r\n  for (i=0, n=values.length; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    map[v] = (v in map) ? map[v] + 1 : 1;\r\n  }\r\n  return map;\r\n};\r\n\r\n// Compute the median of an array of numbers.\r\nstats.median = function(values, f) {\r\n  if (f) values = values.map(util.$(f));\r\n  values = values.filter(util.isValid).sort(util.cmp);\r\n  return stats.quantile(values, 0.5);\r\n};\r\n\r\n// Computes the quartile boundaries of an array of numbers.\r\nstats.quartile = function(values, f) {\r\n  if (f) values = values.map(util.$(f));\r\n  values = values.filter(util.isValid).sort(util.cmp);\r\n  var q = stats.quantile;\r\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\r\n};\r\n\r\n// Compute the quantile of a sorted array of numbers.\r\n// Adapted from the D3.js implementation.\r\nstats.quantile = function(values, f, p) {\r\n  if (p === undefined) { p = f; f = util.identity; }\r\n  f = util.$(f);\r\n  var H = (values.length - 1) * p + 1,\r\n      h = Math.floor(H),\r\n      v = +f(values[h - 1]),\r\n      e = H - h;\r\n  return e ? v + e * (f(values[h]) - v) : v;\r\n};\r\n\r\n// Compute the sum of an array of numbers.\r\nstats.sum = function(values, f) {\r\n  f = util.$(f);\r\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) sum += v;\r\n  }\r\n  return sum;\r\n};\r\n\r\n// Compute the mean (average) of an array of numbers.\r\nstats.mean = function(values, f) {\r\n  f = util.$(f);\r\n  var mean = 0, delta, i, n, c, v;\r\n  for (i=0, c=0, n=values.length; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) {\r\n      delta = v - mean;\r\n      mean = mean + delta / (++c);\r\n    }\r\n  }\r\n  return mean;\r\n};\r\n\r\n// Compute the geometric mean of an array of numbers.\r\nstats.mean.geometric = function(values, f) {\r\n  f = util.$(f);\r\n  var mean = 1, c, n, v, i;\r\n  for (i=0, c=0, n=values.length; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) {\r\n      if (v <= 0) {\r\n        throw Error(\"Geometric mean only defined for positive values.\");\r\n      }\r\n      mean *= v;\r\n      ++c;\r\n    }\r\n  }\r\n  mean = c > 0 ? Math.pow(mean, 1/c) : 0;\r\n  return mean;\r\n};\r\n\r\n// Compute the harmonic mean of an array of numbers.\r\nstats.mean.harmonic = function(values, f) {\r\n  f = util.$(f);\r\n  var mean = 0, c, n, v, i;\r\n  for (i=0, c=0, n=values.length; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) {\r\n      mean += 1/v;\r\n      ++c;\r\n    }\r\n  }\r\n  return c / mean;\r\n};\r\n\r\n// Compute the sample variance of an array of numbers.\r\nstats.variance = function(values, f) {\r\n  f = util.$(f);\r\n  if (!util.isArray(values) || values.length < 2) return 0;\r\n  var mean = 0, M2 = 0, delta, i, c, v;\r\n  for (i=0, c=0; i<values.length; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) {\r\n      delta = v - mean;\r\n      mean = mean + delta / (++c);\r\n      M2 = M2 + delta * (v - mean);\r\n    }\r\n  }\r\n  M2 = M2 / (c - 1);\r\n  return M2;\r\n};\r\n\r\n// Compute the sample standard deviation of an array of numbers.\r\nstats.stdev = function(values, f) {\r\n  return Math.sqrt(stats.variance(values, f));\r\n};\r\n\r\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\r\nstats.modeskew = function(values, f) {\r\n  var avg = stats.mean(values, f),\r\n      med = stats.median(values, f),\r\n      std = stats.stdev(values, f);\r\n  return std === 0 ? 0 : (avg - med) / std;\r\n};\r\n\r\n// Find the minimum value in an array.\r\nstats.min = function(values, f) {\r\n  return stats.extent(values, f)[0];\r\n};\r\n\r\n// Find the maximum value in an array.\r\nstats.max = function(values, f) {\r\n  return stats.extent(values, f)[1];\r\n};\r\n\r\n// Find the minimum and maximum of an array of values.\r\nstats.extent = function(values, f) {\r\n  f = util.$(f);\r\n  var a, b, v, i, n = values.length;\r\n  for (i=0; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) { a = b = v; break; }\r\n  }\r\n  for (; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) {\r\n      if (v < a) a = v;\r\n      if (v > b) b = v;\r\n    }\r\n  }\r\n  return [a, b];\r\n};\r\n\r\n// Find the integer indices of the minimum and maximum values.\r\nstats.extent.index = function(values, f) {\r\n  f = util.$(f);\r\n  var x = -1, y = -1, a, b, v, i, n = values.length;\r\n  for (i=0; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\r\n  }\r\n  for (; i<n; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n    if (util.isValid(v)) {\r\n      if (v < a) { a = v; x = i; }\r\n      if (v > b) { b = v; y = i; }\r\n    }\r\n  }\r\n  return [x, y];\r\n};\r\n\r\n// Compute the dot product of two arrays of numbers.\r\nstats.dot = function(values, a, b) {\r\n  var sum = 0, i, v;\r\n  if (!b) {\r\n    if (values.length !== a.length) {\r\n      throw Error('Array lengths must match.');\r\n    }\r\n    for (i=0; i<values.length; ++i) {\r\n      v = values[i] * a[i];\r\n      if (v === v) sum += v;\r\n    }\r\n  } else {\r\n    a = util.$(a);\r\n    b = util.$(b);\r\n    for (i=0; i<values.length; ++i) {\r\n      v = a(values[i]) * b(values[i]);\r\n      if (v === v) sum += v;\r\n    }\r\n  }\r\n  return sum;\r\n};\r\n\r\n// Compute the vector distance between two arrays of numbers.\r\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\r\nstats.dist = function(values, a, b, exp) {\r\n  var f = util.isFunction(b) || util.isString(b),\r\n      X = values,\r\n      Y = f ? values : a,\r\n      e = f ? exp : b,\r\n      L2 = e === 2 || e == null,\r\n      n = values.length, s = 0, d, i;\r\n  if (f) {\r\n    a = util.$(a);\r\n    b = util.$(b);\r\n  }\r\n  for (i=0; i<n; ++i) {\r\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\r\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\r\n  }\r\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\r\n};\r\n\r\n// Compute the Cohen's d effect size between two arrays of numbers.\r\nstats.cohensd = function(values, a, b) {\r\n  var X = b ? values.map(util.$(a)) : values,\r\n      Y = b ? values.map(util.$(b)) : a,\r\n      x1 = stats.mean(X),\r\n      x2 = stats.mean(Y),\r\n      n1 = stats.count.valid(X),\r\n      n2 = stats.count.valid(Y);\r\n\r\n  if ((n1+n2-2) <= 0) {\r\n    // if both arrays are size 1, or one is empty, there's no effect size\r\n    return 0;\r\n  }\r\n  // pool standard deviation\r\n  var s1 = stats.variance(X),\r\n      s2 = stats.variance(Y),\r\n      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));\r\n  // if there is no variance, there's no effect size\r\n  return s===0 ? 0 : (x1 - x2) / s;\r\n};\r\n\r\n// Computes the covariance between two arrays of numbers\r\nstats.covariance = function(values, a, b) {\r\n  var X = b ? values.map(util.$(a)) : values,\r\n      Y = b ? values.map(util.$(b)) : a,\r\n      n = X.length,\r\n      xm = stats.mean(X),\r\n      ym = stats.mean(Y),\r\n      sum = 0, c = 0, i, x, y, vx, vy;\r\n\r\n  if (n !== Y.length) {\r\n    throw Error('Input lengths must match.');\r\n  }\r\n\r\n  for (i=0; i<n; ++i) {\r\n    x = X[i]; vx = util.isValid(x);\r\n    y = Y[i]; vy = util.isValid(y);\r\n    if (vx && vy) {\r\n      sum += (x-xm) * (y-ym);\r\n      ++c;\r\n    } else if (vx || vy) {\r\n      throw Error('Valid values must align.');\r\n    }\r\n  }\r\n  return sum / (c-1);\r\n};\r\n\r\n// Compute ascending rank scores for an array of values.\r\n// Ties are assigned their collective mean rank.\r\nstats.rank = function(values, f) {\r\n  f = util.$(f) || util.identity;\r\n  var a = values.map(function(v, i) {\r\n      return {idx: i, val: f(v)};\r\n    })\r\n    .sort(util.comparator('val'));\r\n\r\n  var n = values.length,\r\n      r = Array(n),\r\n      tie = -1, p = {}, i, v, mu;\r\n\r\n  for (i=0; i<n; ++i) {\r\n    v = a[i].val;\r\n    if (tie < 0 && p === v) {\r\n      tie = i - 1;\r\n    } else if (tie > -1 && p !== v) {\r\n      mu = 1 + (i-1 + tie) / 2;\r\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\r\n      tie = -1;\r\n    }\r\n    r[a[i].idx] = i + 1;\r\n    p = v;\r\n  }\r\n\r\n  if (tie > -1) {\r\n    mu = 1 + (n-1 + tie) / 2;\r\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\r\n  }\r\n\r\n  return r;\r\n};\r\n\r\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\r\nstats.cor = function(values, a, b) {\r\n  var fn = b;\r\n  b = fn ? values.map(util.$(b)) : a;\r\n  a = fn ? values.map(util.$(a)) : values;\r\n\r\n  var dot = stats.dot(a, b),\r\n      mua = stats.mean(a),\r\n      mub = stats.mean(b),\r\n      sda = stats.stdev(a),\r\n      sdb = stats.stdev(b),\r\n      n = values.length;\r\n\r\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\r\n};\r\n\r\n// Compute the Spearman rank correlation of two arrays of values.\r\nstats.cor.rank = function(values, a, b) {\r\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\r\n      rb = b ? stats.rank(values, b) : stats.rank(a),\r\n      n = values.length, i, s, d;\r\n\r\n  for (i=0, s=0; i<n; ++i) {\r\n    d = ra[i] - rb[i];\r\n    s += d * d;\r\n  }\r\n\r\n  return 1 - 6*s / (n * (n*n-1));\r\n};\r\n\r\n// Compute the distance correlation of two arrays of numbers.\r\n// http://en.wikipedia.org/wiki/Distance_correlation\r\nstats.cor.dist = function(values, a, b) {\r\n  var X = b ? values.map(util.$(a)) : values,\r\n      Y = b ? values.map(util.$(b)) : a;\r\n\r\n  var A = stats.dist.mat(X),\r\n      B = stats.dist.mat(Y),\r\n      n = A.length,\r\n      i, aa, bb, ab;\r\n\r\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\r\n    aa += A[i]*A[i];\r\n    bb += B[i]*B[i];\r\n    ab += A[i]*B[i];\r\n  }\r\n\r\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\r\n};\r\n\r\n// Simple linear regression.\r\n// Returns a \"fit\" object with slope (m), intercept (b),\r\n// r value (R), and sum-squared residual error (rss).\r\nstats.linearRegression = function(values, a, b) {\r\n  var X = b ? values.map(util.$(a)) : values,\r\n      Y = b ? values.map(util.$(b)) : a,\r\n      n = X.length,\r\n      xy = stats.covariance(X, Y), // will throw err if valid vals don't align\r\n      sx = stats.stdev(X),\r\n      sy = stats.stdev(Y),\r\n      slope = xy / (sx*sx),\r\n      icept = stats.mean(Y) - slope * stats.mean(X),\r\n      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},\r\n      res, i;\r\n\r\n  for (i=0; i<n; ++i) {\r\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\r\n      res = (slope*X[i] + icept) - Y[i];\r\n      fit.rss += res * res;\r\n    }\r\n  }\r\n\r\n  return fit;\r\n};\r\n\r\n// Namespace for bootstrap\r\nstats.bootstrap = {};\r\n\r\n// Construct a bootstrapped confidence interval at a given percentile level\r\n// Arguments are an array, an optional n (defaults to 1000),\r\n//  an optional alpha (defaults to 0.05), and an optional smoothing parameter\r\nstats.bootstrap.ci = function(values, a, b, c, d) {\r\n  var X, N, alpha, smooth, bs, means, i;\r\n  if (util.isFunction(a) || util.isString(a)) {\r\n    X = values.map(util.$(a));\r\n    N = b;\r\n    alpha = c;\r\n    smooth = d;\r\n  } else {\r\n    X = values;\r\n    N = a;\r\n    alpha = b;\r\n    smooth = c;\r\n  }\r\n  N = N ? +N : 1000;\r\n  alpha = alpha || 0.05;\r\n\r\n  bs = gen.random.bootstrap(X, smooth);\r\n  for (i=0, means = Array(N); i<N; ++i) {\r\n    means[i] = stats.mean(bs.samples(X.length));\r\n  }\r\n  means.sort(util.numcmp);\r\n  return [\r\n    stats.quantile(means, alpha/2),\r\n    stats.quantile(means, 1-(alpha/2))\r\n  ];\r\n};\r\n\r\n// Namespace for z-tests\r\nstats.z = {};\r\n\r\n// Construct a z-confidence interval at a given significance level\r\n// Arguments are an array and an optional alpha (defaults to 0.05).\r\nstats.z.ci = function(values, a, b) {\r\n  var X = values, alpha = a;\r\n  if (util.isFunction(a) || util.isString(a)) {\r\n    X = values.map(util.$(a));\r\n    alpha = b;\r\n  }\r\n  alpha = alpha || 0.05;\r\n\r\n  var z = alpha===0.05 ? 1.96 : gen.random.normal(0, 1).icdf(1-(alpha/2)),\r\n      mu = stats.mean(X),\r\n      SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));\r\n  return [mu - (z*SE), mu + (z*SE)];\r\n};\r\n\r\n// Perform a z-test of means. Returns the p-value.\r\n// If a single array is provided, performs a one-sample location test.\r\n// If two arrays or a table and two accessors are provided, performs\r\n// a two-sample location test. A paired test is performed if specified\r\n// by the options hash.\r\n// The options hash format is: {paired: boolean, nullh: number}.\r\n// http://en.wikipedia.org/wiki/Z-test\r\n// http://en.wikipedia.org/wiki/Paired_difference_test\r\nstats.z.test = function(values, a, b, opt) {\r\n  if (util.isFunction(b) || util.isString(b)) { // table and accessors\r\n    return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);\r\n  } else if (util.isArray(a)) { // two arrays\r\n    return (b && b.paired ? ztestP : ztest2)(b, values, a);\r\n  } else if (util.isFunction(a) || util.isString(a)) {\r\n    return ztest1(b, values, a); // table and accessor\r\n  } else {\r\n    return ztest1(a, values); // one array\r\n  }\r\n};\r\n\r\n// Perform a z-test of means. Returns the p-value.\r\n// Assuming we have a list of values, and a null hypothesis. If no null\r\n// hypothesis, assume our null hypothesis is mu=0.\r\nfunction ztest1(opt, X, f) {\r\n  var nullH = opt && opt.nullh || 0,\r\n      gaussian = gen.random.normal(0, 1),\r\n      mu = stats.mean(X,f),\r\n      SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));\r\n\r\n  if (SE===0) {\r\n    // Test not well defined when standard error is 0.\r\n    return (mu - nullH) === 0 ? 1 : 0;\r\n  }\r\n  // Two-sided, so twice the one-sided cdf.\r\n  var z = (mu - nullH) / SE;\r\n  return 2 * gaussian.cdf(-Math.abs(z));\r\n}\r\n\r\n// Perform a two sample paired z-test of means. Returns the p-value.\r\nfunction ztestP(opt, values, a, b) {\r\n  var X = b ? values.map(util.$(a)) : values,\r\n      Y = b ? values.map(util.$(b)) : a,\r\n      n1 = stats.count(X),\r\n      n2 = stats.count(Y),\r\n      diffs = Array(), i;\r\n\r\n  if (n1 !== n2) {\r\n    throw Error('Array lengths must match.');\r\n  }\r\n  for (i=0; i<n1; ++i) {\r\n    // Only valid differences should contribute to the test statistic\r\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\r\n      diffs.push(X[i] - Y[i]);\r\n    }\r\n  }\r\n  return stats.z.test(diffs, opt && opt.nullh || 0);\r\n}\r\n\r\n// Perform a two sample z-test of means. Returns the p-value.\r\nfunction ztest2(opt, values, a, b) {\r\n  var X = b ? values.map(util.$(a)) : values,\r\n      Y = b ? values.map(util.$(b)) : a,\r\n      n1 = stats.count.valid(X),\r\n      n2 = stats.count.valid(Y),\r\n      gaussian = gen.random.normal(0, 1),\r\n      meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),\r\n      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);\r\n\r\n  if (SE===0) {\r\n    // Not well defined when pooled standard error is 0.\r\n    return meanDiff===0 ? 1 : 0;\r\n  }\r\n  // Two-tailed, so twice the one-sided cdf.\r\n  var z = meanDiff / SE;\r\n  return 2 * gaussian.cdf(-Math.abs(z));\r\n}\r\n\r\n// Construct a mean-centered distance matrix for an array of numbers.\r\nstats.dist.mat = function(X) {\r\n  var n = X.length,\r\n      m = n*n,\r\n      A = Array(m),\r\n      R = gen.zeros(n),\r\n      M = 0, v, i, j;\r\n\r\n  for (i=0; i<n; ++i) {\r\n    A[i*n+i] = 0;\r\n    for (j=i+1; j<n; ++j) {\r\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\r\n      A[j*n+i] = v;\r\n      R[i] += v;\r\n      R[j] += v;\r\n    }\r\n  }\r\n\r\n  for (i=0; i<n; ++i) {\r\n    M += R[i];\r\n    R[i] /= n;\r\n  }\r\n  M /= m;\r\n\r\n  for (i=0; i<n; ++i) {\r\n    for (j=i; j<n; ++j) {\r\n      A[i*n+j] += M - R[i] - R[j];\r\n      A[j*n+i] = A[i*n+j];\r\n    }\r\n  }\r\n\r\n  return A;\r\n};\r\n\r\n// Compute the Shannon entropy (log base 2) of an array of counts.\r\nstats.entropy = function(counts, f) {\r\n  f = util.$(f);\r\n  var i, p, s = 0, H = 0, n = counts.length;\r\n  for (i=0; i<n; ++i) {\r\n    s += (f ? f(counts[i]) : counts[i]);\r\n  }\r\n  if (s === 0) return 0;\r\n  for (i=0; i<n; ++i) {\r\n    p = (f ? f(counts[i]) : counts[i]) / s;\r\n    if (p) H += p * Math.log(p);\r\n  }\r\n  return -H / Math.LN2;\r\n};\r\n\r\n// Compute the mutual information between two discrete variables.\r\n// Returns an array of the form [MI, MI_distance]\r\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\r\n// http://en.wikipedia.org/wiki/Mutual_information\r\nstats.mutual = function(values, a, b, counts) {\r\n  var x = counts ? values.map(util.$(a)) : values,\r\n      y = counts ? values.map(util.$(b)) : a,\r\n      z = counts ? values.map(util.$(counts)) : b;\r\n\r\n  var px = {},\r\n      py = {},\r\n      n = z.length,\r\n      s = 0, I = 0, H = 0, p, t, i;\r\n\r\n  for (i=0; i<n; ++i) {\r\n    px[x[i]] = 0;\r\n    py[y[i]] = 0;\r\n  }\r\n\r\n  for (i=0; i<n; ++i) {\r\n    px[x[i]] += z[i];\r\n    py[y[i]] += z[i];\r\n    s += z[i];\r\n  }\r\n\r\n  t = 1 / (s * Math.LN2);\r\n  for (i=0; i<n; ++i) {\r\n    if (z[i] === 0) continue;\r\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\r\n    I += z[i] * t * Math.log(p);\r\n    H += z[i] * t * Math.log(z[i]/s);\r\n  }\r\n\r\n  return [I, 1 + I/H];\r\n};\r\n\r\n// Compute the mutual information between two discrete variables.\r\nstats.mutual.info = function(values, a, b, counts) {\r\n  return stats.mutual(values, a, b, counts)[0];\r\n};\r\n\r\n// Compute the mutual information distance between two discrete variables.\r\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\r\nstats.mutual.dist = function(values, a, b, counts) {\r\n  return stats.mutual(values, a, b, counts)[1];\r\n};\r\n\r\n// Compute a profile of summary statistics for a variable.\r\nstats.profile = function(values, f) {\r\n  var mean = 0,\r\n      valid = 0,\r\n      missing = 0,\r\n      distinct = 0,\r\n      min = null,\r\n      max = null,\r\n      M2 = 0,\r\n      M2s = 0,\r\n      multimodality = 0,\r\n      outlier = 0,\r\n      q1,q3,iqr,\r\n      vals = [],\r\n      u = {}, delta, sd, i, v, x;\r\n\r\n  // compute summary stats\r\n  for (i=0; i<values.length; ++i) {\r\n    v = f ? f(values[i]) : values[i];\r\n\r\n    // update unique values\r\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\r\n\r\n    if (v == null) {\r\n      ++missing;\r\n    } else if (util.isValid(v)) {\r\n      // update stats\r\n      x = (typeof v === 'string') ? v.length : v;\r\n      if (min===null || x < min) min = x;\r\n      if (max===null || x > max) max = x;\r\n      delta = x - mean;\r\n      mean = mean + delta / (++valid);\r\n      M2 = M2 + delta * (x - mean);\r\n      vals.push(x);\r\n    }\r\n  }\r\n  M2 = M2 / (valid - 1);\r\n  sd = Math.sqrt(M2);\r\n\r\n  // sort values for median and iqr\r\n  vals.sort(util.cmp);\r\n    q1 = stats.quantile(vals, 0.25);\r\n    q3 = stats.quantile(vals, 0.75);\r\n    iqr = (q3 - q1);\r\n    if (max !==min) {\r\n        var means = (stats.mean(vals) - min) / (max - min);\r\n        var standardizedData = []\r\n        for (i = 0; i < vals.length; ++i) {\r\n            x = (vals[i] - min) / (max - min);\r\n            standardizedData.push(x);\r\n            delta = x - means;\r\n            M2s = M2s + delta * delta;\r\n            // outlier\r\n            if ((vals[i] < q1 - 1.5 * iqr) || (vals[i] > q3 + 1.5 * iqr))\r\n                outlier += 1;\r\n        }\r\n        M2s = M2s / (valid*0.25);\r\n\r\n        // Apply K-means\r\n        var k_mean = stats.k_means1(standardizedData, 2);\r\n        var count_loop = 0;\r\n        var deltaerror = 2;\r\n        while (count_loop<100 && deltaerror > 0.0001){\r\n            var k_mean_new = stats.k_means1(standardizedData, 2,k_mean);\r\n            deltaerror =  Math.abs(k_mean_new[0].val-k_mean[0].val)+Math.abs(k_mean_new[1].val-k_mean[1].val);\r\n            k_mean = k_mean_new;\r\n            count_loop++\r\n        }\r\n        // Compute multimodality feature\r\n        multimodality = Math.sqrt(Math.abs(k_mean[0].val-k_mean[1].val))\r\n    }\r\n\r\n\r\n\r\n  return {\r\n    type:     type(values, f),\r\n    unique:   u,\r\n    count:    values.length,\r\n    valid:    valid,\r\n    missing:  missing,\r\n    distinct: distinct,\r\n    min:      min,\r\n    max:      max,\r\n    mean:     mean,\r\n    stdev:    sd,\r\n    median:   (v = stats.quantile(vals, 0.5)),\r\n    q1:       q1,\r\n    q3:       q3,\r\n    iqr:      iqr,\r\n    q1iqr:    Math.max(q1 - iqr, min),\r\n    q3iqr:    Math.min(q3 + iqr, max),\r\n    outlier: outlier,\r\n    modeskew: sd === 0 ? 0 : (mean - v) / sd,\r\n    variance: M2s,\r\n    multimodality: multimodality\r\n  };\r\n};\r\nstats.k_means1 = function(x, n, means) {\r\n    // A simple average function, just because\r\n    // JavaScript doesn't provide one by default.\r\n    function avg(x) {\r\n        var s = 0;\r\n        for (var i = 0; i < x.length; i++) {\r\n            s += x[i];\r\n        }\r\n        return (x.length > 0) ? (s / x.length) : 0;\r\n    }\r\n\r\n    // n is the number of means to choose.\r\n    if (n === 0) {\r\n        throw new Error('The number of means must be non-zero');\r\n    } else if (n > x.length) {\r\n        throw new Error('The number of means must be fewer than the length of the dataset');\r\n    }\r\n\r\n    var seen = {};\r\n    if (!means) {\r\n        means = [];\r\n        // Randomly choose k means from the data and make sure that no point\r\n        // is chosen twice. This bit inspired by polymaps\r\n        while (means.length < n) {\r\n            var idx = Math.floor(Math.random() * (x.length - 1));\r\n            if (!seen[idx]) {\r\n                means.push({ val: x[idx], vals: [] });\r\n                seen[idx] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    var i;\r\n    // For every value, find the closest mean and add that value to the\r\n    // mean's `vals` array.\r\n    for (i = 0; i < x.length; i++) {\r\n        var dists = [];\r\n        for (var j = 0; j < means.length; j++) {\r\n            dists.push(Math.abs(x[i] - means[j].val));\r\n        }\r\n        var closest_index = dists.indexOf(Math.min.apply(null, dists));\r\n        means[closest_index].vals.push(x[i]);\r\n    }\r\n\r\n    // Create new centers from the centroids of the values in each\r\n    // group.\r\n    //\r\n    // > In the case of one-dimensional data, such as the test scores,\r\n    // the centroid is the arithmetic average of the values\r\n    // of the points in a cluster.\r\n    //\r\n    // [Vance Faber](http://bit.ly/LHCh2y)\r\n    var newvals = [];\r\n    for (i = 0; i < means.length; i++) {\r\n        var centroid = avg(means[i].vals);\r\n        newvals.push({\r\n            val: centroid,\r\n            vals: []\r\n        });\r\n    }\r\n    return newvals;\r\n}\r\n// Compute profiles for all variables in a data set.\r\nstats.summary = function(data, fields) {\r\n  fields = fields || util.keys(data[0]);\r\n  var s = fields.map(function(f) {\r\n    var p = stats.profile(data, util.$(f));\r\n    return (p.field = f, p);\r\n  });\r\n  return (s.__summary__ = true, s);\r\n};\r\n",
    "var d3_time = require('d3-time');\r\n\r\nvar tempDate = new Date(),\r\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\r\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\r\n\r\nfunction date(d) {\r\n  return (tempDate.setTime(+d), tempDate);\r\n}\r\n\r\n// create a time unit entry\r\nfunction entry(type, date, unit, step, min, max) {\r\n  var e = {\r\n    type: type,\r\n    date: date,\r\n    unit: unit\r\n  };\r\n  if (step) {\r\n    e.step = step;\r\n  } else {\r\n    e.minstep = 1;\r\n  }\r\n  if (min != null) e.min = min;\r\n  if (max != null) e.max = max;\r\n  return e;\r\n}\r\n\r\nfunction create(type, unit, base, step, min, max) {\r\n  return entry(type,\r\n    function(d) { return unit.offset(base, d); },\r\n    function(d) { return unit.count(base, d); },\r\n    step, min, max);\r\n}\r\n\r\nvar locale = [\r\n  create('second', d3_time.second, baseDate),\r\n  create('minute', d3_time.minute, baseDate),\r\n  create('hour',   d3_time.hour,   baseDate),\r\n  create('day',    d3_time.day,    baseDate, [1, 7]),\r\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\r\n  create('year',   d3_time.year,   baseDate),\r\n\r\n  // periodic units\r\n  entry('seconds',\r\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\r\n    function(d) { return date(d).getSeconds(); },\r\n    null, 0, 59\r\n  ),\r\n  entry('minutes',\r\n    function(d) { return new Date(1970, 0, 1, 0, d); },\r\n    function(d) { return date(d).getMinutes(); },\r\n    null, 0, 59\r\n  ),\r\n  entry('hours',\r\n    function(d) { return new Date(1970, 0, 1, d); },\r\n    function(d) { return date(d).getHours(); },\r\n    null, 0, 23\r\n  ),\r\n  entry('weekdays',\r\n    function(d) { return new Date(1970, 0, 4+d); },\r\n    function(d) { return date(d).getDay(); },\r\n    [1], 0, 6\r\n  ),\r\n  entry('dates',\r\n    function(d) { return new Date(1970, 0, d); },\r\n    function(d) { return date(d).getDate(); },\r\n    [1], 1, 31\r\n  ),\r\n  entry('months',\r\n    function(d) { return new Date(1970, d % 12, 1); },\r\n    function(d) { return date(d).getMonth(); },\r\n    [1], 0, 11\r\n  )\r\n];\r\n\r\nvar utc = [\r\n  create('second', d3_time.utcSecond, utcBaseDate),\r\n  create('minute', d3_time.utcMinute, utcBaseDate),\r\n  create('hour',   d3_time.utcHour,   utcBaseDate),\r\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\r\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\r\n  create('year',   d3_time.utcYear,   utcBaseDate),\r\n\r\n  // periodic units\r\n  entry('seconds',\r\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\r\n    function(d) { return date(d).getUTCSeconds(); },\r\n    null, 0, 59\r\n  ),\r\n  entry('minutes',\r\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\r\n    function(d) { return date(d).getUTCMinutes(); },\r\n    null, 0, 59\r\n  ),\r\n  entry('hours',\r\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\r\n    function(d) { return date(d).getUTCHours(); },\r\n    null, 0, 23\r\n  ),\r\n  entry('weekdays',\r\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\r\n    function(d) { return date(d).getUTCDay(); },\r\n    [1], 0, 6\r\n  ),\r\n  entry('dates',\r\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\r\n    function(d) { return date(d).getUTCDate(); },\r\n    [1], 1, 31\r\n  ),\r\n  entry('months',\r\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\r\n    function(d) { return date(d).getUTCMonth(); },\r\n    [1], 0, 11\r\n  )\r\n];\r\n\r\nvar STEPS = [\r\n  [31536e6, 5],  // 1-year\r\n  [7776e6, 4],   // 3-month\r\n  [2592e6, 4],   // 1-month\r\n  [12096e5, 3],  // 2-week\r\n  [6048e5, 3],   // 1-week\r\n  [1728e5, 3],   // 2-day\r\n  [864e5, 3],    // 1-day\r\n  [432e5, 2],    // 12-hour\r\n  [216e5, 2],    // 6-hour\r\n  [108e5, 2],    // 3-hour\r\n  [36e5, 2],     // 1-hour\r\n  [18e5, 1],     // 30-minute\r\n  [9e5, 1],      // 15-minute\r\n  [3e5, 1],      // 5-minute\r\n  [6e4, 1],      // 1-minute\r\n  [3e4, 0],      // 30-second\r\n  [15e3, 0],     // 15-second\r\n  [5e3, 0],      // 5-second\r\n  [1e3, 0]       // 1-second\r\n];\r\n\r\nfunction find(units, span, minb, maxb) {\r\n  var step = STEPS[0], i, n, bins;\r\n\r\n  for (i=1, n=STEPS.length; i<n; ++i) {\r\n    step = STEPS[i];\r\n    if (span > step[0]) {\r\n      bins = span / step[0];\r\n      if (bins > maxb) {\r\n        return units[STEPS[i-1][1]];\r\n      }\r\n      if (bins >= minb) {\r\n        return units[step[1]];\r\n      }\r\n    }\r\n  }\r\n  return units[STEPS[n-1][1]];\r\n}\r\n\r\nfunction toUnitMap(units) {\r\n  var map = {}, i, n;\r\n  for (i=0, n=units.length; i<n; ++i) {\r\n    map[units[i].type] = units[i];\r\n  }\r\n  map.find = function(span, minb, maxb) {\r\n    return find(units, span, minb, maxb);\r\n  };\r\n  return map;\r\n}\r\n\r\nmodule.exports = toUnitMap(locale);\r\nmodule.exports.utc = toUnitMap(utc);",
    "var u = module.exports;\r\n\r\n// utility functions\r\n\r\nvar FNAME = '__name__';\r\n\r\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\r\n\r\nu.name = function(f) { return f==null ? null : f[FNAME]; };\r\n\r\nu.identity = function(x) { return x; };\r\n\r\nu.true = u.namedfunc('true', function() { return true; });\r\n\r\nu.false = u.namedfunc('false', function() { return false; });\r\n\r\nu.duplicate = function(obj) {\r\n  return JSON.parse(JSON.stringify(obj));\r\n};\r\n\r\nu.equal = function(a, b) {\r\n  return JSON.stringify(a) === JSON.stringify(b);\r\n};\r\n\r\nu.extend = function(obj) {\r\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\r\n    x = arguments[i];\r\n    for (name in x) { obj[name] = x[name]; }\r\n  }\r\n  return obj;\r\n};\r\n\r\nu.length = function(x) {\r\n  return x != null && x.length != null ? x.length : null;\r\n};\r\n\r\nu.keys = function(x) {\r\n  var keys = [], k;\r\n  for (k in x) keys.push(k);\r\n  return keys;\r\n};\r\n\r\nu.vals = function(x) {\r\n  var vals = [], k;\r\n  for (k in x) vals.push(x[k]);\r\n  return vals;\r\n};\r\n\r\nu.toMap = function(list, f) {\r\n  return (f = u.$(f)) ?\r\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\r\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\r\n};\r\n\r\nu.keystr = function(values) {\r\n  // use to ensure consistent key generation across modules\r\n  var n = values.length;\r\n  if (!n) return '';\r\n  for (var s=String(values[0]), i=1; i<n; ++i) {\r\n    s += '|' + String(values[i]);\r\n  }\r\n  return s;\r\n};\r\n\r\n// type checking functions\r\n\r\nvar toString = Object.prototype.toString;\r\n\r\nu.isObject = function(obj) {\r\n  return obj === Object(obj);\r\n};\r\n\r\nu.isFunction = function(obj) {\r\n  return toString.call(obj) === '[object Function]';\r\n};\r\n\r\nu.isString = function(obj) {\r\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\r\n};\r\n\r\nu.isArray = Array.isArray || function(obj) {\r\n  return toString.call(obj) === '[object Array]';\r\n};\r\n\r\nu.isNumber = function(obj) {\r\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\r\n};\r\n\r\nu.isBoolean = function(obj) {\r\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\r\n};\r\n\r\nu.isDate = function(obj) {\r\n  return toString.call(obj) === '[object Date]';\r\n};\r\n\r\nu.isValid = function(obj) {\r\n  return obj != null && obj === obj;\r\n};\r\n\r\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\r\n\r\n// type coercion functions\r\n\r\nu.number = function(s) {\r\n  return s == null || s === '' ? null : +s;\r\n};\r\n\r\nu.boolean = function(s) {\r\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\r\n};\r\n\r\n// parse a date with optional d3.time-format format\r\nu.date = function(s, format) {\r\n  var d = format ? format : Date;\r\n  return s == null || s === '' ? null : d.parse(s);\r\n};\r\n\r\nu.array = function(x) {\r\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\r\n};\r\n\r\nu.str = function(x) {\r\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\r\n    : u.isObject(x) || u.isString(x) ?\r\n      // Output valid JSON and JS source strings.\r\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\r\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\r\n    : x;\r\n};\r\n\r\n// data access functions\r\n\r\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\r\n\r\nu.field = function(f) {\r\n  return String(f).match(field_re).map(function(d) {\r\n    return d[0] !== '[' ? d :\r\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\r\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\r\n  });\r\n};\r\n\r\nu.accessor = function(f) {\r\n  /* jshint evil: true */\r\n  return f==null || u.isFunction(f) ? f :\r\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\r\n};\r\n\r\n// short-cut for accessor\r\nu.$ = u.accessor;\r\n\r\nu.mutator = function(f) {\r\n  var s;\r\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\r\n    function(x, v) {\r\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\r\n      x[s[i]] = v;\r\n    } :\r\n    function(x, v) { x[f] = v; };\r\n};\r\n\r\n\r\nu.$func = function(name, op) {\r\n  return function(f) {\r\n    f = u.$(f) || u.identity;\r\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\r\n    return u.namedfunc(n, function(d) { return op(f(d)); });\r\n  };\r\n};\r\n\r\nu.$valid  = u.$func('valid', u.isValid);\r\nu.$length = u.$func('length', u.length);\r\n\r\nu.$in = function(f, values) {\r\n  f = u.$(f);\r\n  var map = u.isArray(values) ? u.toMap(values) : values;\r\n  return function(d) { return !!map[f(d)]; };\r\n};\r\n\r\n// comparison / sorting functions\r\n\r\nu.comparator = function(sort) {\r\n  var sign = [];\r\n  if (sort === undefined) sort = [];\r\n  sort = u.array(sort).map(function(f) {\r\n    var s = 1;\r\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\r\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\r\n    sign.push(s);\r\n    return u.accessor(f);\r\n  });\r\n  return function(a, b) {\r\n    var i, n, f, c;\r\n    for (i=0, n=sort.length; i<n; ++i) {\r\n      f = sort[i];\r\n      c = u.cmp(f(a), f(b));\r\n      if (c) return c * sign[i];\r\n    }\r\n    return 0;\r\n  };\r\n};\r\n\r\nu.cmp = function(a, b) {\r\n  return (a < b || a == null) && b != null ? -1 :\r\n    (a > b || b == null) && a != null ? 1 :\r\n    ((b = b instanceof Date ? +b : b),\r\n     (a = a instanceof Date ? +a : a)) !== a && b === b ? -1 :\r\n    b !== b && a === a ? 1 : 0;\r\n};\r\n\r\nu.numcmp = function(a, b) { return a - b; };\r\n\r\nu.stablesort = function(array, sortBy, keyFn) {\r\n  var indices = array.reduce(function(idx, v, i) {\r\n    return (idx[keyFn(v)] = i, idx);\r\n  }, {});\r\n\r\n  array.sort(function(a, b) {\r\n    var sa = sortBy(a),\r\n        sb = sortBy(b);\r\n    return sa < sb ? -1 : sa > sb ? 1\r\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\r\n  });\r\n\r\n  return array;\r\n};\r\n\r\n// permutes an array using a Knuth shuffle\r\nu.permute = function(a) {\r\n  var m = a.length,\r\n      swap,\r\n      i;\r\n\r\n  while (m) {\r\n    i = Math.floor(Math.random() * m--);\r\n    swap = a[m];\r\n    a[m] = a[i];\r\n    a[i] = swap;\r\n  }\r\n};\r\n\r\n// string functions\r\n\r\nu.pad = function(s, length, pos, padchar) {\r\n  padchar = padchar || \" \";\r\n  var d = length - s.length;\r\n  if (d <= 0) return s;\r\n  switch (pos) {\r\n    case 'left':\r\n      return strrep(d, padchar) + s;\r\n    case 'middle':\r\n    case 'center':\r\n      return strrep(Math.floor(d/2), padchar) +\r\n         s + strrep(Math.ceil(d/2), padchar);\r\n    default:\r\n      return s + strrep(d, padchar);\r\n  }\r\n};\r\n\r\nfunction strrep(n, str) {\r\n  var s = \"\", i;\r\n  for (i=0; i<n; ++i) s += str;\r\n  return s;\r\n}\r\n\r\nu.truncate = function(s, length, pos, word, ellipsis) {\r\n  var len = s.length;\r\n  if (len <= length) return s;\r\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\r\n  var l = Math.max(0, length - ellipsis.length);\r\n\r\n  switch (pos) {\r\n    case 'left':\r\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\r\n    case 'middle':\r\n    case 'center':\r\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\r\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\r\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\r\n    default:\r\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\r\n  }\r\n};\r\n\r\nfunction truncateOnWord(s, len, rev) {\r\n  var cnt = 0, tok = s.split(truncate_word_re);\r\n  if (rev) {\r\n    s = (tok = tok.reverse())\r\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\r\n      .reverse();\r\n  } else {\r\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\r\n  }\r\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\r\n}\r\n\r\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\r\n",
    "var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n",
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n",
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n",
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n",
    "\"use strict\";\r\n(function (AggregateOp) {\r\n    AggregateOp[AggregateOp[\"VALUES\"] = 'values'] = \"VALUES\";\r\n    AggregateOp[AggregateOp[\"COUNT\"] = 'count'] = \"COUNT\";\r\n    AggregateOp[AggregateOp[\"VALID\"] = 'valid'] = \"VALID\";\r\n    AggregateOp[AggregateOp[\"MISSING\"] = 'missing'] = \"MISSING\";\r\n    AggregateOp[AggregateOp[\"DISTINCT\"] = 'distinct'] = \"DISTINCT\";\r\n    AggregateOp[AggregateOp[\"SUM\"] = 'sum'] = \"SUM\";\r\n    AggregateOp[AggregateOp[\"MEAN\"] = 'mean'] = \"MEAN\";\r\n    AggregateOp[AggregateOp[\"AVERAGE\"] = 'average'] = \"AVERAGE\";\r\n    AggregateOp[AggregateOp[\"VARIANCE\"] = 'variance'] = \"VARIANCE\";\r\n    AggregateOp[AggregateOp[\"VARIANCEP\"] = 'variancep'] = \"VARIANCEP\";\r\n    AggregateOp[AggregateOp[\"STDEV\"] = 'stdev'] = \"STDEV\";\r\n    AggregateOp[AggregateOp[\"STDEVP\"] = 'stdevp'] = \"STDEVP\";\r\n    AggregateOp[AggregateOp[\"MEDIAN\"] = 'median'] = \"MEDIAN\";\r\n    AggregateOp[AggregateOp[\"Q1\"] = 'q1'] = \"Q1\";\r\n    AggregateOp[AggregateOp[\"Q3\"] = 'q3'] = \"Q3\";\r\n    AggregateOp[AggregateOp[\"MODESKEW\"] = 'modeskew'] = \"MODESKEW\";\r\n    AggregateOp[AggregateOp[\"MIN\"] = 'min'] = \"MIN\";\r\n    AggregateOp[AggregateOp[\"MAX\"] = 'max'] = \"MAX\";\r\n    AggregateOp[AggregateOp[\"ARGMIN\"] = 'argmin'] = \"ARGMIN\";\r\n    AggregateOp[AggregateOp[\"ARGMAX\"] = 'argmax'] = \"ARGMAX\";\r\n})(exports.AggregateOp || (exports.AggregateOp = {}));\r\nvar AggregateOp = exports.AggregateOp;\r\nexports.AGGREGATE_OPS = [\r\n    AggregateOp.VALUES,\r\n    AggregateOp.COUNT,\r\n    AggregateOp.VALID,\r\n    AggregateOp.MISSING,\r\n    AggregateOp.DISTINCT,\r\n    AggregateOp.SUM,\r\n    AggregateOp.MEAN,\r\n    AggregateOp.AVERAGE,\r\n    AggregateOp.VARIANCE,\r\n    AggregateOp.VARIANCEP,\r\n    AggregateOp.STDEV,\r\n    AggregateOp.STDEVP,\r\n    AggregateOp.MEDIAN,\r\n    AggregateOp.Q1,\r\n    AggregateOp.Q3,\r\n    AggregateOp.MODESKEW,\r\n    AggregateOp.MIN,\r\n    AggregateOp.MAX,\r\n    AggregateOp.ARGMIN,\r\n    AggregateOp.ARGMAX,\r\n];\r\n/** Additive-based aggregation operations.  These can be applied to stack. */\r\nexports.SUM_OPS = [\r\n    AggregateOp.COUNT,\r\n    AggregateOp.SUM,\r\n    AggregateOp.DISTINCT,\r\n    AggregateOp.VALID,\r\n    AggregateOp.MISSING\r\n];\r\nexports.SHARED_DOMAIN_OPS = [\r\n    AggregateOp.MEAN,\r\n    AggregateOp.AVERAGE,\r\n    AggregateOp.STDEV,\r\n    AggregateOp.STDEVP,\r\n    AggregateOp.MEDIAN,\r\n    AggregateOp.Q1,\r\n    AggregateOp.Q3,\r\n    AggregateOp.MIN,\r\n    AggregateOp.MAX,\r\n];\r\n//# sourceMappingURL=aggregate.js.map",
    "\"use strict\";\r\n(function (AxisOrient) {\r\n    AxisOrient[AxisOrient[\"TOP\"] = 'top'] = \"TOP\";\r\n    AxisOrient[AxisOrient[\"RIGHT\"] = 'right'] = \"RIGHT\";\r\n    AxisOrient[AxisOrient[\"LEFT\"] = 'left'] = \"LEFT\";\r\n    AxisOrient[AxisOrient[\"BOTTOM\"] = 'bottom'] = \"BOTTOM\";\r\n})(exports.AxisOrient || (exports.AxisOrient = {}));\r\nvar AxisOrient = exports.AxisOrient;\r\n// TODO: add comment for properties that we rely on Vega's default to produce\r\n// more concise Vega output.\r\nexports.defaultAxisConfig = {\r\n    offset: undefined,\r\n    grid: undefined,\r\n    labels: true,\r\n    labelMaxLength: 25,\r\n    tickSize: undefined,\r\n    characterWidth: 6\r\n};\r\nexports.defaultFacetAxisConfig = {\r\n    axisWidth: 0,\r\n    labels: true,\r\n    grid: false,\r\n    tickSize: 0\r\n};\r\n//# sourceMappingURL=axis.js.map",
    "\"use strict\";\r\nvar channel_1 = require('./channel');\r\nfunction autoMaxBins(channel) {\r\n    switch (channel) {\r\n        case channel_1.ROW:\r\n        case channel_1.COLUMN:\r\n        case channel_1.SIZE:\r\n        // Facets and Size shouldn't have too many bins\r\n        // We choose 6 like shape to simplify the rule\r\n        case channel_1.SHAPE:\r\n            return 6; // Vega's \"shape\" has 6 distinct values\r\n        default:\r\n            return 10;\r\n    }\r\n}\r\nexports.autoMaxBins = autoMaxBins;\r\n//# sourceMappingURL=bin.js.map",
    "/*\r\n * Constants and utilities for encoding channels (Visual variables)\r\n * such as 'x', 'y', 'color'.\r\n */\r\n\"use strict\";\r\nvar util_1 = require('./util');\r\n(function (Channel) {\r\n    Channel[Channel[\"X\"] = 'x'] = \"X\";\r\n    Channel[Channel[\"Y\"] = 'y'] = \"Y\";\r\n    Channel[Channel[\"X2\"] = 'x2'] = \"X2\";\r\n    Channel[Channel[\"Y2\"] = 'y2'] = \"Y2\";\r\n    Channel[Channel[\"ROW\"] = 'row'] = \"ROW\";\r\n    Channel[Channel[\"COLUMN\"] = 'column'] = \"COLUMN\";\r\n    Channel[Channel[\"SHAPE\"] = 'shape'] = \"SHAPE\";\r\n    Channel[Channel[\"SIZE\"] = 'size'] = \"SIZE\";\r\n    Channel[Channel[\"COLOR\"] = 'color'] = \"COLOR\";\r\n    Channel[Channel[\"TEXT\"] = 'text'] = \"TEXT\";\r\n    Channel[Channel[\"DETAIL\"] = 'detail'] = \"DETAIL\";\r\n    Channel[Channel[\"LABEL\"] = 'label'] = \"LABEL\";\r\n    Channel[Channel[\"PATH\"] = 'path'] = \"PATH\";\r\n    Channel[Channel[\"ORDER\"] = 'order'] = \"ORDER\";\r\n    Channel[Channel[\"OPACITY\"] = 'opacity'] = \"OPACITY\";\r\n})(exports.Channel || (exports.Channel = {}));\r\nvar Channel = exports.Channel;\r\nexports.X = Channel.X;\r\nexports.Y = Channel.Y;\r\nexports.X2 = Channel.X2;\r\nexports.Y2 = Channel.Y2;\r\nexports.ROW = Channel.ROW;\r\nexports.COLUMN = Channel.COLUMN;\r\nexports.SHAPE = Channel.SHAPE;\r\nexports.SIZE = Channel.SIZE;\r\nexports.COLOR = Channel.COLOR;\r\nexports.TEXT = Channel.TEXT;\r\nexports.DETAIL = Channel.DETAIL;\r\nexports.LABEL = Channel.LABEL;\r\nexports.PATH = Channel.PATH;\r\nexports.ORDER = Channel.ORDER;\r\nexports.OPACITY = Channel.OPACITY;\r\nexports.CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.PATH, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL, exports.LABEL];\r\nexports.UNIT_CHANNELS = util_1.without(exports.CHANNELS, [exports.ROW, exports.COLUMN]);\r\nexports.UNIT_SCALE_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.PATH, exports.ORDER, exports.DETAIL, exports.TEXT, exports.LABEL, exports.X2, exports.Y2]);\r\nexports.NONSPATIAL_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);\r\nexports.NONSPATIAL_SCALE_CHANNELS = util_1.without(exports.UNIT_SCALE_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);\r\n/** Channels that can serve as groupings for stacked charts. */\r\nexports.STACK_GROUP_CHANNELS = [exports.COLOR, exports.DETAIL, exports.ORDER, exports.OPACITY, exports.SIZE];\r\n;\r\n/**\r\n * Return whether a channel supports a particular mark type.\r\n * @param channel  channel name\r\n * @param mark the mark type\r\n * @return whether the mark supports the channel\r\n */\r\nfunction supportMark(channel, mark) {\r\n    return !!getSupportedMark(channel)[mark];\r\n}\r\nexports.supportMark = supportMark;\r\n/**\r\n * Return a dictionary showing whether a channel supports mark type.\r\n * @param channel\r\n * @return A dictionary mapping mark types to boolean values.\r\n */\r\nfunction getSupportedMark(channel) {\r\n    switch (channel) {\r\n        case exports.X:\r\n        case exports.Y:\r\n        case exports.COLOR:\r\n        case exports.DETAIL:\r\n        case exports.ORDER:\r\n        case exports.OPACITY:\r\n        case exports.ROW:\r\n        case exports.COLUMN:\r\n            return {\r\n                point: true, tick: true, rule: true, circle: true, square: true,\r\n                bar: true, line: true, area: true, text: true\r\n            };\r\n        case exports.X2:\r\n        case exports.Y2:\r\n            return {\r\n                rule: true, bar: true, area: true\r\n            };\r\n        case exports.SIZE:\r\n            return {\r\n                point: true, tick: true, rule: true, circle: true, square: true,\r\n                bar: true, text: true\r\n            };\r\n        case exports.SHAPE:\r\n            return { point: true };\r\n        case exports.TEXT:\r\n            return { text: true };\r\n        case exports.PATH:\r\n            return { line: true };\r\n    }\r\n    return {};\r\n}\r\nexports.getSupportedMark = getSupportedMark;\r\n;\r\n/**\r\n * Return whether a channel supports dimension / measure role\r\n * @param  channel\r\n * @return A dictionary mapping role to boolean values.\r\n */\r\nfunction getSupportedRole(channel) {\r\n    switch (channel) {\r\n        case exports.X:\r\n        case exports.Y:\r\n        case exports.COLOR:\r\n        case exports.OPACITY:\r\n        case exports.LABEL:\r\n        case exports.DETAIL:\r\n            return {\r\n                measure: true,\r\n                dimension: true\r\n            };\r\n        case exports.ROW:\r\n        case exports.COLUMN:\r\n        case exports.SHAPE:\r\n            return {\r\n                measure: false,\r\n                dimension: true\r\n            };\r\n        case exports.X2:\r\n        case exports.Y2:\r\n        case exports.SIZE:\r\n        case exports.TEXT:\r\n            return {\r\n                measure: true,\r\n                dimension: false\r\n            };\r\n        case exports.PATH:\r\n            return {\r\n                measure: false,\r\n                dimension: true\r\n            };\r\n    }\r\n    throw new Error('Invalid encoding channel' + channel);\r\n}\r\nexports.getSupportedRole = getSupportedRole;\r\nfunction hasScale(channel) {\r\n    return !util_1.contains([exports.DETAIL, exports.PATH, exports.TEXT, exports.LABEL, exports.ORDER], channel);\r\n}\r\nexports.hasScale = hasScale;\r\n//# sourceMappingURL=channel.js.map",
    "// DateTime definition object\r\n\"use strict\";\r\nvar util_1 = require('./util');\r\n/*\r\n * A designated year that starts on Sunday.\r\n */\r\nvar SUNDAY_YEAR = 2006;\r\nfunction isDateTime(o) {\r\n    return !!o && (!!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||\r\n        !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds);\r\n}\r\nexports.isDateTime = isDateTime;\r\nexports.MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\r\nexports.SHORT_MONTHS = exports.MONTHS.map(function (m) { return m.substr(0, 3); });\r\nexports.DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\r\nexports.SHORT_DAYS = exports.DAYS.map(function (d) { return d.substr(0, 3); });\r\nfunction normalizeQuarter(q) {\r\n    if (util_1.isNumber(q)) {\r\n        // We accept 1-based quarter, so need to readjust to 0-based quarter\r\n        return (q - 1) + '';\r\n    }\r\n    else {\r\n        // Simply an expression string, but normalize should not be called in this case.\r\n        console.warn('Potentially invalid quarter', q);\r\n        return q;\r\n    }\r\n}\r\nfunction normalizeMonth(m) {\r\n    if (util_1.isNumber(m)) {\r\n        // We accept 1-based month, so need to readjust to 0-based month\r\n        return (m - 1) + '';\r\n    }\r\n    else {\r\n        var lowerM = m.toLowerCase();\r\n        var monthIndex = exports.MONTHS.indexOf(lowerM);\r\n        if (monthIndex !== -1) {\r\n            return monthIndex + ''; // 0 for january, ...\r\n        }\r\n        var shortM = lowerM.substr(0, 3);\r\n        var shortMonthIndex = exports.SHORT_MONTHS.indexOf(shortM);\r\n        if (shortMonthIndex !== -1) {\r\n            return shortMonthIndex + '';\r\n        }\r\n        // Simply an expression string, but normalize should not be called in this case.\r\n        console.warn('Potentially invalid month', m);\r\n        return m;\r\n    }\r\n}\r\nfunction normalizeDay(d) {\r\n    if (util_1.isNumber(d)) {\r\n        // mod so that this can be both 0-based where 0 = sunday\r\n        // and 1-based where 7=sunday\r\n        return (d % 7) + '';\r\n    }\r\n    else {\r\n        var lowerD = d.toLowerCase();\r\n        var dayIndex = exports.DAYS.indexOf(lowerD);\r\n        if (dayIndex !== -1) {\r\n            return dayIndex + ''; // 0 for january, ...\r\n        }\r\n        var shortD = lowerD.substr(0, 3);\r\n        var shortDayIndex = exports.SHORT_DAYS.indexOf(shortD);\r\n        if (shortDayIndex !== -1) {\r\n            return shortDayIndex + '';\r\n        }\r\n        // Simply an expression string, but normalize should not be called in this case.\r\n        console.warn('Potentially invalid day', d);\r\n        return d;\r\n    }\r\n}\r\nfunction timestamp(d, normalize) {\r\n    var date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\r\n    // FIXME support UTC\r\n    if (d.day !== undefined) {\r\n        if (util_1.keys(d).length > 1) {\r\n            console.warn('Dropping day from datetime', JSON.stringify(d), 'as day cannot be combined with other units.');\r\n            d = util_1.duplicate(d);\r\n            delete d.day;\r\n        }\r\n        else {\r\n            // Use a year that has 1/1 as Sunday so we can setDate below\r\n            date.setFullYear(SUNDAY_YEAR);\r\n            var day = normalize ? normalizeDay(d.day) : d.day;\r\n            date.setDate(+day + 1); // +1 since date start at 1 in JS\r\n        }\r\n    }\r\n    if (d.year !== undefined) {\r\n        date.setFullYear(d.year);\r\n    }\r\n    if (d.quarter !== undefined) {\r\n        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\r\n        date.setMonth(+quarter * 3);\r\n    }\r\n    if (d.month !== undefined) {\r\n        var month = normalize ? normalizeMonth(d.month) : d.month;\r\n        date.setMonth(+month);\r\n    }\r\n    if (d.date !== undefined) {\r\n        date.setDate(d.date);\r\n    }\r\n    if (d.hours !== undefined) {\r\n        date.setHours(d.hours);\r\n    }\r\n    if (d.minutes !== undefined) {\r\n        date.setMinutes(d.minutes);\r\n    }\r\n    if (d.seconds !== undefined) {\r\n        date.setSeconds(d.seconds);\r\n    }\r\n    if (d.milliseconds !== undefined) {\r\n        date.setMilliseconds(d.milliseconds);\r\n    }\r\n    return date.getTime();\r\n}\r\nexports.timestamp = timestamp;\r\n/**\r\n * Return Vega Expression for a particular date time.\r\n * @param d\r\n * @param normalize whether to normalize quarter, month, day.\r\n */\r\nfunction dateTimeExpr(d, normalize) {\r\n    if (normalize === void 0) { normalize = false; }\r\n    var units = [];\r\n    if (normalize && d.day !== undefined) {\r\n        if (util_1.keys(d).length > 1) {\r\n            console.warn('Dropping day from datetime', JSON.stringify(d), 'as day cannot be combined with other units.');\r\n            d = util_1.duplicate(d);\r\n            delete d.day;\r\n        }\r\n    }\r\n    if (d.year !== undefined) {\r\n        units.push(d.year);\r\n    }\r\n    else if (d.day !== undefined) {\r\n        // Set year to 2006 for working with day since January 1 2006 is a Sunday\r\n        units.push(SUNDAY_YEAR);\r\n    }\r\n    else {\r\n        units.push(0);\r\n    }\r\n    if (d.month !== undefined) {\r\n        var month = normalize ? normalizeMonth(d.month) : d.month;\r\n        units.push(month);\r\n    }\r\n    else if (d.quarter !== undefined) {\r\n        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\r\n        units.push(quarter + '*3');\r\n    }\r\n    else {\r\n        units.push(0); // months start at zero in JS\r\n    }\r\n    if (d.date !== undefined) {\r\n        units.push(d.date);\r\n    }\r\n    else if (d.day !== undefined) {\r\n        // HACK: Day only works as a standalone unit\r\n        // This is only correct because we always set year to 2006 for day\r\n        var day = normalize ? normalizeDay(d.day) : d.day;\r\n        units.push(day + '+1');\r\n    }\r\n    else {\r\n        units.push(1); // Date starts at 1 in JS\r\n    }\r\n    // Note: can't use TimeUnit enum here as importing it will create\r\n    // circular dependency problem!\r\n    for (var _i = 0, _a = ['hours', 'minutes', 'seconds', 'milliseconds']; _i < _a.length; _i++) {\r\n        var timeUnit = _a[_i];\r\n        if (d[timeUnit] !== undefined) {\r\n            units.push(d[timeUnit]);\r\n        }\r\n        else {\r\n            units.push(0);\r\n        }\r\n    }\r\n    return 'datetime(' + units.join(', ') + ')';\r\n}\r\nexports.dateTimeExpr = dateTimeExpr;\r\n//# sourceMappingURL=datetime.js.map",
    "\"use strict\";\r\nvar channel_1 = require('./channel');\r\nvar util_1 = require('./util');\r\nfunction countRetinal(encoding) {\r\n    var count = 0;\r\n    if (encoding.color) {\r\n        count++;\r\n    }\r\n    if (encoding.opacity) {\r\n        count++;\r\n    }\r\n    if (encoding.size) {\r\n        count++;\r\n    }\r\n    if (encoding.shape) {\r\n        count++;\r\n    }\r\n    return count;\r\n}\r\nexports.countRetinal = countRetinal;\r\nfunction channels(encoding) {\r\n    return channel_1.CHANNELS.filter(function (channel) {\r\n        return has(encoding, channel);\r\n    });\r\n}\r\nexports.channels = channels;\r\n// TOD: rename this to hasChannelField and only use we really want it.\r\nfunction has(encoding, channel) {\r\n    var channelEncoding = encoding && encoding[channel];\r\n    return channelEncoding && (channelEncoding.field !== undefined ||\r\n        // TODO: check that we have field in the array\r\n        (util_1.isArray(channelEncoding) && channelEncoding.length > 0));\r\n}\r\nexports.has = has;\r\nfunction isAggregate(encoding) {\r\n    return util_1.some(channel_1.CHANNELS, function (channel) {\r\n        if (has(encoding, channel) && encoding[channel].aggregate) {\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n}\r\nexports.isAggregate = isAggregate;\r\nfunction isRanged(encoding) {\r\n    return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\r\n}\r\nexports.isRanged = isRanged;\r\nfunction fieldDefs(encoding) {\r\n    var arr = [];\r\n    channel_1.CHANNELS.forEach(function (channel) {\r\n        if (has(encoding, channel)) {\r\n            if (util_1.isArray(encoding[channel])) {\r\n                encoding[channel].forEach(function (fieldDef) {\r\n                    arr.push(fieldDef);\r\n                });\r\n            }\r\n            else {\r\n                arr.push(encoding[channel]);\r\n            }\r\n        }\r\n    });\r\n    return arr;\r\n}\r\nexports.fieldDefs = fieldDefs;\r\n;\r\nfunction forEach(encoding, f, thisArg) {\r\n    channelMappingForEach(channel_1.CHANNELS, encoding, f, thisArg);\r\n}\r\nexports.forEach = forEach;\r\nfunction channelMappingForEach(channels, mapping, f, thisArg) {\r\n    var i = 0;\r\n    channels.forEach(function (channel) {\r\n        if (has(mapping, channel)) {\r\n            if (util_1.isArray(mapping[channel])) {\r\n                mapping[channel].forEach(function (fieldDef) {\r\n                    f.call(thisArg, fieldDef, channel, i++);\r\n                });\r\n            }\r\n            else {\r\n                f.call(thisArg, mapping[channel], channel, i++);\r\n            }\r\n        }\r\n    });\r\n}\r\nexports.channelMappingForEach = channelMappingForEach;\r\nfunction map(encoding, f, thisArg) {\r\n    return channelMappingMap(channel_1.CHANNELS, encoding, f, thisArg);\r\n}\r\nexports.map = map;\r\nfunction channelMappingMap(channels, mapping, f, thisArg) {\r\n    var arr = [];\r\n    channels.forEach(function (channel) {\r\n        if (has(mapping, channel)) {\r\n            if (util_1.isArray(mapping[channel])) {\r\n                mapping[channel].forEach(function (fieldDef) {\r\n                    arr.push(f.call(thisArg, fieldDef, channel));\r\n                });\r\n            }\r\n            else {\r\n                arr.push(f.call(thisArg, mapping[channel], channel));\r\n            }\r\n        }\r\n    });\r\n    return arr;\r\n}\r\nexports.channelMappingMap = channelMappingMap;\r\nfunction reduce(encoding, f, init, thisArg) {\r\n    return channelMappingReduce(channel_1.CHANNELS, encoding, f, init, thisArg);\r\n}\r\nexports.reduce = reduce;\r\nfunction channelMappingReduce(channels, mapping, f, init, thisArg) {\r\n    var r = init;\r\n    channel_1.CHANNELS.forEach(function (channel) {\r\n        if (has(mapping, channel)) {\r\n            if (util_1.isArray(mapping[channel])) {\r\n                mapping[channel].forEach(function (fieldDef) {\r\n                    r = f.call(thisArg, r, fieldDef, channel);\r\n                });\r\n            }\r\n            else {\r\n                r = f.call(thisArg, r, mapping[channel], channel);\r\n            }\r\n        }\r\n    });\r\n    return r;\r\n}\r\nexports.channelMappingReduce = channelMappingReduce;\r\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\r\n(function (Mark) {\r\n    Mark[Mark[\"AREA\"] = 'area'] = \"AREA\";\r\n    Mark[Mark[\"BAR\"] = 'bar'] = \"BAR\";\r\n    Mark[Mark[\"LINE\"] = 'line'] = \"LINE\";\r\n    Mark[Mark[\"POINT\"] = 'point'] = \"POINT\";\r\n    Mark[Mark[\"TEXT\"] = 'text'] = \"TEXT\";\r\n    Mark[Mark[\"TICK\"] = 'tick'] = \"TICK\";\r\n    Mark[Mark[\"RULE\"] = 'rule'] = \"RULE\";\r\n    Mark[Mark[\"CIRCLE\"] = 'circle'] = \"CIRCLE\";\r\n    Mark[Mark[\"SQUARE\"] = 'square'] = \"SQUARE\";\r\n    Mark[Mark[\"ERRORBAR\"] = 'errorBar'] = \"ERRORBAR\";\r\n})(exports.Mark || (exports.Mark = {}));\r\nvar Mark = exports.Mark;\r\nexports.AREA = Mark.AREA;\r\nexports.BAR = Mark.BAR;\r\nexports.LINE = Mark.LINE;\r\nexports.POINT = Mark.POINT;\r\nexports.TEXT = Mark.TEXT;\r\nexports.TICK = Mark.TICK;\r\nexports.RULE = Mark.RULE;\r\nexports.CIRCLE = Mark.CIRCLE;\r\nexports.SQUARE = Mark.SQUARE;\r\nexports.ERRORBAR = Mark.ERRORBAR;\r\nexports.PRIMITIVE_MARKS = [exports.AREA, exports.BAR, exports.LINE, exports.POINT, exports.TEXT, exports.TICK, exports.RULE, exports.CIRCLE, exports.SQUARE];\r\n//# sourceMappingURL=mark.js.map",
    "\"use strict\";\r\n(function (ScaleType) {\r\n    ScaleType[ScaleType[\"LINEAR\"] = 'linear'] = \"LINEAR\";\r\n    ScaleType[ScaleType[\"LOG\"] = 'log'] = \"LOG\";\r\n    ScaleType[ScaleType[\"POW\"] = 'pow'] = \"POW\";\r\n    ScaleType[ScaleType[\"SQRT\"] = 'sqrt'] = \"SQRT\";\r\n    ScaleType[ScaleType[\"QUANTILE\"] = 'quantile'] = \"QUANTILE\";\r\n    ScaleType[ScaleType[\"QUANTIZE\"] = 'quantize'] = \"QUANTIZE\";\r\n    ScaleType[ScaleType[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\r\n    ScaleType[ScaleType[\"TIME\"] = 'time'] = \"TIME\";\r\n    ScaleType[ScaleType[\"UTC\"] = 'utc'] = \"UTC\";\r\n})(exports.ScaleType || (exports.ScaleType = {}));\r\nvar ScaleType = exports.ScaleType;\r\n(function (NiceTime) {\r\n    NiceTime[NiceTime[\"SECOND\"] = 'second'] = \"SECOND\";\r\n    NiceTime[NiceTime[\"MINUTE\"] = 'minute'] = \"MINUTE\";\r\n    NiceTime[NiceTime[\"HOUR\"] = 'hour'] = \"HOUR\";\r\n    NiceTime[NiceTime[\"DAY\"] = 'day'] = \"DAY\";\r\n    NiceTime[NiceTime[\"WEEK\"] = 'week'] = \"WEEK\";\r\n    NiceTime[NiceTime[\"MONTH\"] = 'month'] = \"MONTH\";\r\n    NiceTime[NiceTime[\"YEAR\"] = 'year'] = \"YEAR\";\r\n})(exports.NiceTime || (exports.NiceTime = {}));\r\nvar NiceTime = exports.NiceTime;\r\n(function (BandSize) {\r\n    BandSize[BandSize[\"FIT\"] = 'fit'] = \"FIT\";\r\n})(exports.BandSize || (exports.BandSize = {}));\r\nvar BandSize = exports.BandSize;\r\nexports.BANDSIZE_FIT = BandSize.FIT;\r\nexports.defaultScaleConfig = {\r\n    round: true,\r\n    textBandWidth: 90,\r\n    bandSize: 21,\r\n    padding: 0.1,\r\n    useRawDomain: false,\r\n    opacity: [0.3, 0.8],\r\n    nominalColorRange: 'category10',\r\n    sequentialColorRange: ['#AFC6A3', '#09622A'],\r\n    shapeRange: 'shapes',\r\n    fontSizeRange: [8, 40],\r\n    ruleSizeRange: [1, 5],\r\n    tickSizeRange: [1, 20]\r\n};\r\nexports.defaultFacetScaleConfig = {\r\n    round: true,\r\n    padding: 16\r\n};\r\n//# sourceMappingURL=scale.js.map",
    "\"use strict\";\r\n(function (SortOrder) {\r\n    SortOrder[SortOrder[\"ASCENDING\"] = 'ascending'] = \"ASCENDING\";\r\n    SortOrder[SortOrder[\"DESCENDING\"] = 'descending'] = \"DESCENDING\";\r\n    SortOrder[SortOrder[\"NONE\"] = 'none'] = \"NONE\";\r\n})(exports.SortOrder || (exports.SortOrder = {}));\r\nvar SortOrder = exports.SortOrder;\r\nfunction isSortField(sort) {\r\n    return !!sort && !!sort['field'] && !!sort['op'];\r\n}\r\nexports.isSortField = isSortField;\r\n//# sourceMappingURL=sort.js.map",
    "\"use strict\";\r\nvar aggregate_1 = require('./aggregate');\r\nvar channel_1 = require('./channel');\r\nvar encoding_1 = require('./encoding');\r\nvar mark_1 = require('./mark');\r\nvar scale_1 = require('./scale');\r\nvar util_1 = require('./util');\r\n(function (StackOffset) {\r\n    StackOffset[StackOffset[\"ZERO\"] = 'zero'] = \"ZERO\";\r\n    StackOffset[StackOffset[\"CENTER\"] = 'center'] = \"CENTER\";\r\n    StackOffset[StackOffset[\"NORMALIZE\"] = 'normalize'] = \"NORMALIZE\";\r\n    StackOffset[StackOffset[\"NONE\"] = 'none'] = \"NONE\";\r\n})(exports.StackOffset || (exports.StackOffset = {}));\r\nvar StackOffset = exports.StackOffset;\r\nfunction stack(mark, encoding, stacked) {\r\n    // Should not have stack explicitly disabled\r\n    if (util_1.contains([StackOffset.NONE, null, false], stacked)) {\r\n        return null;\r\n    }\r\n    // Should have stackable mark\r\n    if (!util_1.contains([mark_1.BAR, mark_1.AREA, mark_1.POINT, mark_1.CIRCLE, mark_1.SQUARE, mark_1.LINE, mark_1.TEXT, mark_1.TICK], mark)) {\r\n        return null;\r\n    }\r\n    // Should be aggregate plot\r\n    if (!encoding_1.isAggregate(encoding)) {\r\n        return null;\r\n    }\r\n    // Should have grouping level of detail\r\n    var stackByChannels = channel_1.STACK_GROUP_CHANNELS.reduce(function (sc, channel) {\r\n        if (encoding_1.has(encoding, channel) && !encoding[channel].aggregate) {\r\n            sc.push(channel);\r\n        }\r\n        return sc;\r\n    }, []);\r\n    if (stackByChannels.length === 0) {\r\n        return null;\r\n    }\r\n    // Has only one aggregate axis\r\n    var hasXField = encoding_1.has(encoding, channel_1.X);\r\n    var hasYField = encoding_1.has(encoding, channel_1.Y);\r\n    var xIsAggregate = hasXField && !!encoding.x.aggregate;\r\n    var yIsAggregate = hasYField && !!encoding.y.aggregate;\r\n    if (xIsAggregate !== yIsAggregate) {\r\n        var fieldChannel = xIsAggregate ? channel_1.X : channel_1.Y;\r\n        var fieldChannelAggregate = encoding[fieldChannel].aggregate;\r\n        var fieldChannelScale = encoding[fieldChannel].scale;\r\n        if (fieldChannelScale && fieldChannelScale.type && fieldChannelScale.type !== scale_1.ScaleType.LINEAR) {\r\n            console.warn('Cannot stack non-linear (' + fieldChannelScale.type + ') scale');\r\n            return null;\r\n        }\r\n        if (util_1.contains(aggregate_1.SUM_OPS, fieldChannelAggregate)) {\r\n            if (util_1.contains([mark_1.BAR, mark_1.AREA], mark)) {\r\n                // Bar and Area with sum ops are automatically stacked by default\r\n                stacked = stacked === undefined ? StackOffset.ZERO : stacked;\r\n            }\r\n        }\r\n        else {\r\n            console.warn('Cannot stack when the aggregate function is ' + fieldChannelAggregate + '(non-summative).');\r\n            return null;\r\n        }\r\n        if (!stacked) {\r\n            return null;\r\n        }\r\n        return {\r\n            groupbyChannel: xIsAggregate ? (hasYField ? channel_1.Y : null) : (hasXField ? channel_1.X : null),\r\n            fieldChannel: fieldChannel,\r\n            stackByChannels: stackByChannels,\r\n            offset: stacked\r\n        };\r\n    }\r\n    return null;\r\n}\r\nexports.stack = stack;\r\n//# sourceMappingURL=stack.js.map",
    "\"use strict\";\r\nvar channel_1 = require('./channel');\r\nvar datetime_1 = require('./datetime');\r\nvar scale_1 = require('./scale');\r\nvar util_1 = require('./util');\r\n(function (TimeUnit) {\r\n    TimeUnit[TimeUnit[\"YEAR\"] = 'year'] = \"YEAR\";\r\n    TimeUnit[TimeUnit[\"MONTH\"] = 'month'] = \"MONTH\";\r\n    TimeUnit[TimeUnit[\"DAY\"] = 'day'] = \"DAY\";\r\n    TimeUnit[TimeUnit[\"DATE\"] = 'date'] = \"DATE\";\r\n    TimeUnit[TimeUnit[\"HOURS\"] = 'hours'] = \"HOURS\";\r\n    TimeUnit[TimeUnit[\"MINUTES\"] = 'minutes'] = \"MINUTES\";\r\n    TimeUnit[TimeUnit[\"SECONDS\"] = 'seconds'] = \"SECONDS\";\r\n    TimeUnit[TimeUnit[\"MILLISECONDS\"] = 'milliseconds'] = \"MILLISECONDS\";\r\n    TimeUnit[TimeUnit[\"YEARMONTH\"] = 'yearmonth'] = \"YEARMONTH\";\r\n    TimeUnit[TimeUnit[\"YEARMONTHDATE\"] = 'yearmonthdate'] = \"YEARMONTHDATE\";\r\n    TimeUnit[TimeUnit[\"YEARMONTHDATEHOURS\"] = 'yearmonthdatehours'] = \"YEARMONTHDATEHOURS\";\r\n    TimeUnit[TimeUnit[\"YEARMONTHDATEHOURSMINUTES\"] = 'yearmonthdatehoursminutes'] = \"YEARMONTHDATEHOURSMINUTES\";\r\n    TimeUnit[TimeUnit[\"YEARMONTHDATEHOURSMINUTESSECONDS\"] = 'yearmonthdatehoursminutesseconds'] = \"YEARMONTHDATEHOURSMINUTESSECONDS\";\r\n    // MONTHDATE always include 29 February since we use year 0th (which is a leap year)\r\n    TimeUnit[TimeUnit[\"MONTHDATE\"] = 'monthdate'] = \"MONTHDATE\";\r\n    TimeUnit[TimeUnit[\"HOURSMINUTES\"] = 'hoursminutes'] = \"HOURSMINUTES\";\r\n    TimeUnit[TimeUnit[\"HOURSMINUTESSECONDS\"] = 'hoursminutesseconds'] = \"HOURSMINUTESSECONDS\";\r\n    TimeUnit[TimeUnit[\"MINUTESSECONDS\"] = 'minutesseconds'] = \"MINUTESSECONDS\";\r\n    TimeUnit[TimeUnit[\"SECONDSMILLISECONDS\"] = 'secondsmilliseconds'] = \"SECONDSMILLISECONDS\";\r\n    TimeUnit[TimeUnit[\"QUARTER\"] = 'quarter'] = \"QUARTER\";\r\n    TimeUnit[TimeUnit[\"YEARQUARTER\"] = 'yearquarter'] = \"YEARQUARTER\";\r\n    TimeUnit[TimeUnit[\"QUARTERMONTH\"] = 'quartermonth'] = \"QUARTERMONTH\";\r\n    TimeUnit[TimeUnit[\"YEARQUARTERMONTH\"] = 'yearquartermonth'] = \"YEARQUARTERMONTH\";\r\n})(exports.TimeUnit || (exports.TimeUnit = {}));\r\nvar TimeUnit = exports.TimeUnit;\r\n/** Time Unit that only corresponds to only one part of Date objects. */\r\nexports.SINGLE_TIMEUNITS = [\r\n    TimeUnit.YEAR,\r\n    TimeUnit.QUARTER,\r\n    TimeUnit.MONTH,\r\n    TimeUnit.DAY,\r\n    TimeUnit.DATE,\r\n    TimeUnit.HOURS,\r\n    TimeUnit.MINUTES,\r\n    TimeUnit.SECONDS,\r\n    TimeUnit.MILLISECONDS,\r\n];\r\nvar SINGLE_TIMEUNIT_INDEX = exports.SINGLE_TIMEUNITS.reduce(function (d, timeUnit) {\r\n    d[timeUnit] = true;\r\n    return d;\r\n}, {});\r\nfunction isSingleTimeUnit(timeUnit) {\r\n    return !!SINGLE_TIMEUNIT_INDEX[timeUnit];\r\n}\r\nexports.isSingleTimeUnit = isSingleTimeUnit;\r\n/**\r\n * Converts a date to only have the measurements relevant to the specified unit\r\n * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'\r\n * Note: the base date is Jan 01 1900 00:00:00\r\n */\r\nfunction convert(unit, date) {\r\n    var result = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\r\n    exports.SINGLE_TIMEUNITS.forEach(function (singleUnit) {\r\n        if (containsTimeUnit(unit, singleUnit)) {\r\n            switch (singleUnit) {\r\n                case TimeUnit.DAY:\r\n                    throw new Error('Cannot convert to TimeUnits containing \\'day\\'');\r\n                case TimeUnit.YEAR:\r\n                    result.setFullYear(date.getFullYear());\r\n                    break;\r\n                case TimeUnit.QUARTER:\r\n                    // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)\r\n                    result.setMonth((Math.floor(date.getMonth() / 3)) * 3);\r\n                    break;\r\n                case TimeUnit.MONTH:\r\n                    result.setMonth(date.getMonth());\r\n                    break;\r\n                case TimeUnit.DATE:\r\n                    result.setDate(date.getDate());\r\n                    break;\r\n                case TimeUnit.HOURS:\r\n                    result.setHours(date.getHours());\r\n                    break;\r\n                case TimeUnit.MINUTES:\r\n                    result.setMinutes(date.getMinutes());\r\n                    break;\r\n                case TimeUnit.SECONDS:\r\n                    result.setSeconds(date.getSeconds());\r\n                    break;\r\n                case TimeUnit.MILLISECONDS:\r\n                    result.setMilliseconds(date.getMilliseconds());\r\n                    break;\r\n            }\r\n        }\r\n    });\r\n    return result;\r\n}\r\nexports.convert = convert;\r\nexports.MULTI_TIMEUNITS = [\r\n    TimeUnit.YEARQUARTER,\r\n    TimeUnit.YEARQUARTERMONTH,\r\n    TimeUnit.YEARMONTH,\r\n    TimeUnit.YEARMONTHDATE,\r\n    TimeUnit.YEARMONTHDATEHOURS,\r\n    TimeUnit.YEARMONTHDATEHOURSMINUTES,\r\n    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\r\n    TimeUnit.QUARTERMONTH,\r\n    TimeUnit.HOURSMINUTES,\r\n    TimeUnit.HOURSMINUTESSECONDS,\r\n    TimeUnit.MINUTESSECONDS,\r\n    TimeUnit.SECONDSMILLISECONDS,\r\n];\r\nvar MULTI_TIMEUNIT_INDEX = exports.MULTI_TIMEUNITS.reduce(function (d, timeUnit) {\r\n    d[timeUnit] = true;\r\n    return d;\r\n}, {});\r\nfunction isMultiTimeUnit(timeUnit) {\r\n    return !!MULTI_TIMEUNIT_INDEX[timeUnit];\r\n}\r\nexports.isMultiTimeUnit = isMultiTimeUnit;\r\nexports.TIMEUNITS = exports.SINGLE_TIMEUNITS.concat(exports.MULTI_TIMEUNITS);\r\n/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */\r\nfunction containsTimeUnit(fullTimeUnit, timeUnit) {\r\n    var fullTimeUnitStr = fullTimeUnit.toString();\r\n    var timeUnitStr = timeUnit.toString();\r\n    var index = fullTimeUnitStr.indexOf(timeUnitStr);\r\n    return index > -1 &&\r\n        (timeUnit !== TimeUnit.SECONDS ||\r\n            index === 0 ||\r\n            fullTimeUnitStr.charAt(index - 1) !== 'i' // exclude milliseconds\r\n        );\r\n}\r\nexports.containsTimeUnit = containsTimeUnit;\r\nfunction defaultScaleType(timeUnit) {\r\n    switch (timeUnit) {\r\n        case TimeUnit.HOURS:\r\n        case TimeUnit.DAY:\r\n        case TimeUnit.MONTH:\r\n        case TimeUnit.QUARTER:\r\n            return scale_1.ScaleType.ORDINAL;\r\n    }\r\n    // date, year, minute, second, yearmonth, monthday, ...\r\n    return scale_1.ScaleType.TIME;\r\n}\r\nexports.defaultScaleType = defaultScaleType;\r\n/**\r\n * Returns Vega expresssion for a given timeUnit and fieldRef\r\n */\r\nfunction fieldExpr(fullTimeUnit, field) {\r\n    var fieldRef = 'datum[\"' + field + '\"]';\r\n    function func(timeUnit) {\r\n        if (timeUnit === TimeUnit.QUARTER) {\r\n            // Divide by 3 to get the corresponding quarter number, multiply by 3\r\n            // to scale to the first month of the corresponding quarter(0,3,6,9).\r\n            return 'floor(month(' + fieldRef + ')' + '/3)';\r\n        }\r\n        else {\r\n            return timeUnit + '(' + fieldRef + ')';\r\n        }\r\n    }\r\n    var d = exports.SINGLE_TIMEUNITS.reduce(function (_d, tu) {\r\n        if (containsTimeUnit(fullTimeUnit, tu)) {\r\n            _d[tu] = func(tu);\r\n        }\r\n        return _d;\r\n    }, {});\r\n    if (d.day && util_1.keys(d).length > 1) {\r\n        console.warn('Time unit \"' + fullTimeUnit + '\" is not supported. We are replacing it with ', (fullTimeUnit + '').replace('day', 'date') + '.');\r\n        delete d.day;\r\n        d.date = func(TimeUnit.DATE);\r\n    }\r\n    return datetime_1.dateTimeExpr(d);\r\n}\r\nexports.fieldExpr = fieldExpr;\r\n/** Generate the complete domain. */\r\nfunction imputedDomain(timeUnit, channel) {\r\n    if (util_1.contains([channel_1.ROW, channel_1.COLUMN, channel_1.SHAPE, channel_1.COLOR], channel)) {\r\n        return null;\r\n    }\r\n    switch (timeUnit) {\r\n        case TimeUnit.SECONDS:\r\n            return util_1.range(0, 60);\r\n        case TimeUnit.MINUTES:\r\n            return util_1.range(0, 60);\r\n        case TimeUnit.HOURS:\r\n            return util_1.range(0, 24);\r\n        case TimeUnit.DAY:\r\n            return util_1.range(0, 7);\r\n        case TimeUnit.DATE:\r\n            return util_1.range(1, 32);\r\n        case TimeUnit.MONTH:\r\n            return util_1.range(0, 12);\r\n        case TimeUnit.QUARTER:\r\n            return [0, 1, 2, 3]; // Q1-Q4 (0th-index)\r\n    }\r\n    return null;\r\n}\r\nexports.imputedDomain = imputedDomain;\r\n/** returns the smallest nice unit for scale.nice */\r\nfunction smallestUnit(timeUnit) {\r\n    if (!timeUnit) {\r\n        return undefined;\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\r\n        return 'second';\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\r\n        return 'minute';\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\r\n        return 'hour';\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||\r\n        containsTimeUnit(timeUnit, TimeUnit.DATE)) {\r\n        return 'day';\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\r\n        return 'month';\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\r\n        return 'year';\r\n    }\r\n    return undefined;\r\n}\r\nexports.smallestUnit = smallestUnit;\r\n/** returns the template name used for axis labels for a time unit */\r\nfunction template(timeUnit, field, shortTimeLabels) {\r\n    if (!timeUnit) {\r\n        return undefined;\r\n    }\r\n    var dateComponents = [];\r\n    var template = '';\r\n    var hasYear = containsTimeUnit(timeUnit, TimeUnit.YEAR);\r\n    if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\r\n        // special template for quarter as prefix\r\n        template = 'Q{{' + field + ' | quarter}}';\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\r\n        // By default use short month name\r\n        dateComponents.push(shortTimeLabels !== false ? '%b' : '%B');\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\r\n        dateComponents.push(shortTimeLabels ? '%a' : '%A');\r\n    }\r\n    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\r\n        dateComponents.push('%d' + (hasYear ? ',' : '')); // add comma if there is year\r\n    }\r\n    if (hasYear) {\r\n        dateComponents.push(shortTimeLabels ? '%y' : '%Y');\r\n    }\r\n    var timeComponents = [];\r\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\r\n        timeComponents.push('%H');\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\r\n        timeComponents.push('%M');\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\r\n        timeComponents.push('%S');\r\n    }\r\n    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\r\n        timeComponents.push('%L');\r\n    }\r\n    var dateTimeComponents = [];\r\n    if (dateComponents.length > 0) {\r\n        dateTimeComponents.push(dateComponents.join(' '));\r\n    }\r\n    if (timeComponents.length > 0) {\r\n        dateTimeComponents.push(timeComponents.join(':'));\r\n    }\r\n    if (dateTimeComponents.length > 0) {\r\n        if (template) {\r\n            // Add space between quarter and main time format\r\n            template += ' ';\r\n        }\r\n        template += '{{' + field + ' | time:\\'' + dateTimeComponents.join(' ') + '\\'}}';\r\n    }\r\n    // If template is still an empty string, return undefined instead.\r\n    return template || undefined;\r\n}\r\nexports.template = template;\r\n//# sourceMappingURL=timeunit.js.map",
    "/** Constants and utilities for data type */\r\n\"use strict\";\r\n(function (Type) {\r\n    Type[Type[\"QUANTITATIVE\"] = 'quantitative'] = \"QUANTITATIVE\";\r\n    Type[Type[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\r\n    Type[Type[\"TEMPORAL\"] = 'temporal'] = \"TEMPORAL\";\r\n    Type[Type[\"NOMINAL\"] = 'nominal'] = \"NOMINAL\";\r\n})(exports.Type || (exports.Type = {}));\r\nvar Type = exports.Type;\r\nexports.QUANTITATIVE = Type.QUANTITATIVE;\r\nexports.ORDINAL = Type.ORDINAL;\r\nexports.TEMPORAL = Type.TEMPORAL;\r\nexports.NOMINAL = Type.NOMINAL;\r\n/**\r\n * Mapping from full type names to short type names.\r\n * @type {Object}\r\n */\r\nexports.SHORT_TYPE = {\r\n    quantitative: 'Q',\r\n    temporal: 'T',\r\n    nominal: 'N',\r\n    ordinal: 'O'\r\n};\r\n/**\r\n * Mapping from short type names to full type names.\r\n * @type {Object}\r\n */\r\nexports.TYPE_FROM_SHORT_TYPE = {\r\n    Q: exports.QUANTITATIVE,\r\n    T: exports.TEMPORAL,\r\n    O: exports.ORDINAL,\r\n    N: exports.NOMINAL\r\n};\r\n/**\r\n * Get full, lowercase type name for a given type.\r\n * @param  type\r\n * @return Full type name.\r\n */\r\nfunction getFullName(type) {\r\n    var typeString = type; // force type as string so we can translate short types\r\n    return exports.TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] ||\r\n        typeString.toLowerCase();\r\n}\r\nexports.getFullName = getFullName;\r\n//# sourceMappingURL=type.js.map",
    "/// <reference path=\"../typings/datalib.d.ts\"/>\r\n/// <reference path=\"../typings/json-stable-stringify.d.ts\"/>\r\n\"use strict\";\r\nvar stringify = require('json-stable-stringify');\r\nvar util_1 = require('datalib/src/util');\r\nexports.keys = util_1.keys;\r\nexports.extend = util_1.extend;\r\nexports.duplicate = util_1.duplicate;\r\nexports.isArray = util_1.isArray;\r\nexports.vals = util_1.vals;\r\nexports.truncate = util_1.truncate;\r\nexports.toMap = util_1.toMap;\r\nexports.isObject = util_1.isObject;\r\nexports.isString = util_1.isString;\r\nexports.isNumber = util_1.isNumber;\r\nexports.isBoolean = util_1.isBoolean;\r\nvar util_2 = require('datalib/src/util');\r\nvar util_3 = require('datalib/src/util');\r\n/**\r\n * Creates an object composed of the picked object properties.\r\n *\r\n * Example:  (from lodash)\r\n *\r\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\r\n * pick(object, ['a', 'c']);\r\n * //  { 'a': 1, 'c': 3 }\r\n *\r\n */\r\nfunction pick(obj, props) {\r\n    var copy = {};\r\n    props.forEach(function (prop) {\r\n        if (obj.hasOwnProperty(prop)) {\r\n            copy[prop] = obj[prop];\r\n        }\r\n    });\r\n    return copy;\r\n}\r\nexports.pick = pick;\r\n// Copied from datalib\r\nfunction range(start, stop, step) {\r\n    if (arguments.length < 3) {\r\n        step = 1;\r\n        if (arguments.length < 2) {\r\n            stop = start;\r\n            start = 0;\r\n        }\r\n    }\r\n    if ((stop - start) / step === Infinity) {\r\n        throw new Error('Infinite range');\r\n    }\r\n    var range = [], i = -1, j;\r\n    if (step < 0) {\r\n        /* tslint:disable */\r\n        while ((j = start + step * ++i) > stop) {\r\n            range.push(j);\r\n        }\r\n    }\r\n    else {\r\n        while ((j = start + step * ++i) < stop) {\r\n            range.push(j);\r\n        }\r\n    }\r\n    return range;\r\n}\r\nexports.range = range;\r\n;\r\n/**\r\n * The opposite of _.pick; this method creates an object composed of the own\r\n * and inherited enumerable string keyed properties of object that are not omitted.\r\n */\r\nfunction omit(obj, props) {\r\n    var copy = util_2.duplicate(obj);\r\n    props.forEach(function (prop) {\r\n        delete copy[prop];\r\n    });\r\n    return copy;\r\n}\r\nexports.omit = omit;\r\nfunction hash(a) {\r\n    if (util_3.isString(a) || util_3.isNumber(a) || util_3.isBoolean(a)) {\r\n        return String(a);\r\n    }\r\n    return stringify(a);\r\n}\r\nexports.hash = hash;\r\nfunction contains(array, item) {\r\n    return array.indexOf(item) > -1;\r\n}\r\nexports.contains = contains;\r\n/** Returns the array without the elements in item */\r\nfunction without(array, excludedItems) {\r\n    return array.filter(function (item) {\r\n        return !contains(excludedItems, item);\r\n    });\r\n}\r\nexports.without = without;\r\nfunction union(array, other) {\r\n    return array.concat(without(other, array));\r\n}\r\nexports.union = union;\r\nfunction forEach(obj, f, thisArg) {\r\n    if (obj.forEach) {\r\n        obj.forEach.call(thisArg, f);\r\n    }\r\n    else {\r\n        for (var k in obj) {\r\n            if (obj.hasOwnProperty(k)) {\r\n                f.call(thisArg, obj[k], k, obj);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.forEach = forEach;\r\nfunction reduce(obj, f, init, thisArg) {\r\n    if (obj.reduce) {\r\n        return obj.reduce.call(thisArg, f, init);\r\n    }\r\n    else {\r\n        for (var k in obj) {\r\n            if (obj.hasOwnProperty(k)) {\r\n                init = f.call(thisArg, init, obj[k], k, obj);\r\n            }\r\n        }\r\n        return init;\r\n    }\r\n}\r\nexports.reduce = reduce;\r\nfunction map(obj, f, thisArg) {\r\n    if (obj.map) {\r\n        return obj.map.call(thisArg, f);\r\n    }\r\n    else {\r\n        var output = [];\r\n        for (var k in obj) {\r\n            if (obj.hasOwnProperty(k)) {\r\n                output.push(f.call(thisArg, obj[k], k, obj));\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n}\r\nexports.map = map;\r\nfunction some(arr, f) {\r\n    var i = 0;\r\n    for (var k = 0; k < arr.length; k++) {\r\n        if (f(arr[k], k, i++)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.some = some;\r\nfunction every(arr, f) {\r\n    var i = 0;\r\n    for (var k = 0; k < arr.length; k++) {\r\n        if (!f(arr[k], k, i++)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.every = every;\r\nfunction flatten(arrays) {\r\n    return [].concat.apply([], arrays);\r\n}\r\nexports.flatten = flatten;\r\nfunction mergeDeep(dest) {\r\n    var src = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        src[_i - 1] = arguments[_i];\r\n    }\r\n    for (var i = 0; i < src.length; i++) {\r\n        dest = deepMerge_(dest, src[i]);\r\n    }\r\n    return dest;\r\n}\r\nexports.mergeDeep = mergeDeep;\r\n;\r\n// recursively merges src into dest\r\nfunction deepMerge_(dest, src) {\r\n    if (typeof src !== 'object' || src === null) {\r\n        return dest;\r\n    }\r\n    for (var p in src) {\r\n        if (!src.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        if (src[p] === undefined) {\r\n            continue;\r\n        }\r\n        if (typeof src[p] !== 'object' || src[p] === null) {\r\n            dest[p] = src[p];\r\n        }\r\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\r\n            dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\r\n        }\r\n        else {\r\n            mergeDeep(dest[p], src[p]);\r\n        }\r\n    }\r\n    return dest;\r\n}\r\nfunction unique(values, f) {\r\n    var results = [];\r\n    var u = {}, v, i, n;\r\n    for (i = 0, n = values.length; i < n; ++i) {\r\n        v = f ? f(values[i]) : values[i];\r\n        if (v in u) {\r\n            continue;\r\n        }\r\n        u[v] = 1;\r\n        results.push(values[i]);\r\n    }\r\n    return results;\r\n}\r\nexports.unique = unique;\r\n;\r\nfunction warning(message) {\r\n    console.warn('[VL Warning]', message);\r\n}\r\nexports.warning = warning;\r\nfunction error(message) {\r\n    console.error('[VL Error]', message);\r\n}\r\nexports.error = error;\r\n/**\r\n * Returns true if the two dictionaries disagree. Applies only to defined values.\r\n */\r\nfunction differ(dict, other) {\r\n    for (var key in dict) {\r\n        if (dict.hasOwnProperty(key)) {\r\n            if (other[key] && dict[key] && other[key] !== dict[key]) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.differ = differ;\r\n//# sourceMappingURL=util.js.map",
    "\"use strict\";\r\nvar channel_1 = require('vega-lite/src/channel');\r\nvar aggregate_1 = require('vega-lite/src/aggregate');\r\nvar mark_1 = require('vega-lite/src/mark');\r\nvar scale_1 = require('vega-lite/src/scale');\r\nvar sort_1 = require('vega-lite/src/sort');\r\nvar timeunit_1 = require('vega-lite/src/timeunit');\r\nvar type_1 = require('vega-lite/src/type');\r\nvar property_1 = require('./property');\r\nexports.DEFAULT_QUERY_CONFIG = {\r\n    verbose: false,\r\n    defaultSpecConfig: {\r\n        overlay: { line: true },\r\n        scale: { useRawDomain: true }\r\n    },\r\n    propertyPrecedence: property_1.DEFAULT_PROPERTY_PRECEDENCE,\r\n    marks: [mark_1.Mark.POINT, mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA, mark_1.Mark.TICK],\r\n    channels: [channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN, channel_1.SIZE, channel_1.COLOR],\r\n    aggregates: [undefined, aggregate_1.AggregateOp.MEAN],\r\n    timeUnits: [undefined, timeunit_1.TimeUnit.YEAR, timeunit_1.TimeUnit.MONTH, timeunit_1.TimeUnit.DATE, timeunit_1.TimeUnit.MINUTES, timeunit_1.TimeUnit.SECONDS],\r\n    types: [type_1.Type.NOMINAL, type_1.Type.ORDINAL, type_1.Type.QUANTITATIVE, type_1.Type.TEMPORAL],\r\n    maxBinsList: [5, 10, 20],\r\n    axisAxisColors: [undefined],\r\n    axisAxisWidths: [undefined],\r\n    axisLayers: ['front', 'back'],\r\n    axisOffsets: [undefined],\r\n    axisOrients: [undefined],\r\n    axisGridColors: [undefined],\r\n    axisGridDashes: [undefined],\r\n    axisGridOpacities: [undefined],\r\n    axisGridWidths: [undefined],\r\n    axisFormats: [undefined],\r\n    axisLabelAngles: [undefined],\r\n    axisLabelMaxLengths: [undefined],\r\n    axisSubDivides: [undefined],\r\n    axisTicks: [undefined],\r\n    axisTickColors: [undefined],\r\n    axisTickLabelColors: [undefined],\r\n    axisTickLabelFonts: [undefined],\r\n    axisTickLabelFontSizes: [undefined],\r\n    axisTickPaddings: [undefined],\r\n    axisTickSizes: [undefined],\r\n    axisTickSizeMajors: [undefined],\r\n    axisTickSizeMinors: [undefined],\r\n    axisTickSizeEnds: [undefined],\r\n    axisTickWidths: [undefined],\r\n    axisValuesList: [undefined],\r\n    axisTitles: [undefined],\r\n    axisTitleColors: [undefined],\r\n    axisTitleFonts: [undefined],\r\n    axisTitleFontWeights: [undefined],\r\n    axisTitleFontSizes: [undefined],\r\n    axisTitleOffsets: [undefined],\r\n    axisTitleMaxLengths: [undefined],\r\n    axisCharacterWidths: [undefined],\r\n    legendOrients: ['left', 'right'],\r\n    legendOffsets: [undefined],\r\n    legendValuesList: [undefined],\r\n    legendFormats: [undefined],\r\n    legendLabelAligns: [undefined],\r\n    legendLabelBaselines: [undefined],\r\n    legendLabelColors: [undefined],\r\n    legendLabelFonts: [undefined],\r\n    legendLabelFontSizes: [undefined],\r\n    legendSymbolColors: [undefined],\r\n    legendSymbolShapes: [undefined],\r\n    legendSymbolSizes: [undefined],\r\n    legendSymbolStrokeWidths: [undefined],\r\n    legendTitles: [undefined],\r\n    legendTitleColors: [undefined],\r\n    legendTitleFonts: [undefined],\r\n    legendTitleFontSizes: [undefined],\r\n    legendTitleFontWeights: [undefined],\r\n    // TODO: Come back and implement correctly when designing sort enumeration.\r\n    sorts: [sort_1.SortOrder.ASCENDING, sort_1.SortOrder.DESCENDING],\r\n    sortOps: [aggregate_1.AggregateOp.MIN, aggregate_1.AggregateOp.MEAN],\r\n    sortOrders: [sort_1.SortOrder.ASCENDING, sort_1.SortOrder.DESCENDING],\r\n    scaleBandSizes: [17, 21],\r\n    scaleDomains: [undefined],\r\n    scaleExponents: [1],\r\n    scaleRanges: [undefined],\r\n    scaleTypes: [undefined, scale_1.ScaleType.LOG],\r\n    numberNominalProportion: 0.05,\r\n    numberNominalLimit: 40,\r\n    // CONSTRAINTS\r\n    constraintManuallySpecifiedValue: false,\r\n    // Spec Constraints -- See description inside src/constraints/spec.ts\r\n    autoAddCount: false,\r\n    hasAppropriateGraphicTypeForMark: true,\r\n    omitAggregate: false,\r\n    omitAggregatePlotWithDimensionOnlyOnFacet: true,\r\n    omitAggregatePlotWithoutDimension: false,\r\n    omitBarLineAreaWithOcclusion: true,\r\n    omitBarTickWithSize: true,\r\n    omitMultipleNonPositionalChannels: true,\r\n    omitNonSumStack: true,\r\n    omitRaw: false,\r\n    omitRawContinuousFieldForAggregatePlot: true,\r\n    omitRepeatedField: true,\r\n    omitNonPositionalOrFacetOverPositionalChannels: true,\r\n    omitTableWithOcclusionIfAutoAddCount: true,\r\n    omitVerticalDotPlot: false,\r\n    preferredBinAxis: channel_1.Channel.X,\r\n    preferredTemporalAxis: channel_1.Channel.X,\r\n    preferredOrdinalAxis: channel_1.Channel.Y,\r\n    preferredNominalAxis: channel_1.Channel.Y,\r\n    preferredFacet: channel_1.Channel.ROW,\r\n    // Encoding Constraints -- See description inside src/constraints/encoding.ts\r\n    maxCardinalityForCategoricalColor: 20,\r\n    maxCardinalityForFacet: 20,\r\n    maxCardinalityForShape: 6,\r\n    timeUnitShouldHaveVariation: true,\r\n    typeMatchesSchemaType: true,\r\n    // STYLIZE\r\n    stylize: true,\r\n    smallBandSizeForHighCardinalityOrFacet: { maxCardinality: 10, bandSize: 12 },\r\n    nominalColorScaleForHighCardinality: { maxCardinality: 10, palette: 'category20' },\r\n    xAxisOnTopForHighYCardinalityWithoutColumn: { maxCardinality: 30 },\r\n    // RANKING PREFERENCE\r\n    maxGoodCardinalityForFacet: 5,\r\n    maxGoodCardinalityForColor: 7,\r\n};\r\n//# sourceMappingURL=config.js.map",
    "\"use strict\";\r\n/**\r\n * Abstract model for a constraint.\r\n */\r\nvar AbstractConstraintModel = (function () {\r\n    function AbstractConstraintModel(constraint) {\r\n        this.constraint = constraint;\r\n    }\r\n    AbstractConstraintModel.prototype.name = function () {\r\n        return this.constraint.name;\r\n    };\r\n    AbstractConstraintModel.prototype.description = function () {\r\n        return this.constraint.description;\r\n    };\r\n    AbstractConstraintModel.prototype.properties = function () {\r\n        return this.constraint.properties;\r\n    };\r\n    AbstractConstraintModel.prototype.strict = function () {\r\n        return this.constraint.strict;\r\n    };\r\n    return AbstractConstraintModel;\r\n}());\r\nexports.AbstractConstraintModel = AbstractConstraintModel;\r\n//# sourceMappingURL=base.js.map",
    "\"use strict\";\r\nvar _encoding = require('./encoding');\r\nvar _spec = require('./spec');\r\nexports.encoding = _encoding;\r\nexports.spec = _spec;\r\n//# sourceMappingURL=constraint.js.map",
    "\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar aggregate_1 = require('vega-lite/src/aggregate');\r\nvar channel_1 = require('vega-lite/src/channel');\r\nvar scale_1 = require('vega-lite/src/scale');\r\nvar type_1 = require('vega-lite/src/type');\r\nvar base_1 = require('./base');\r\nvar property_1 = require('../property');\r\nvar enumspec_1 = require('../enumspec');\r\nvar schema_1 = require('../schema');\r\nvar util_1 = require('../util');\r\nvar encoding_1 = require('../query/encoding');\r\nvar EncodingConstraintModel = (function (_super) {\r\n    __extends(EncodingConstraintModel, _super);\r\n    function EncodingConstraintModel(constraint) {\r\n        _super.call(this, constraint);\r\n    }\r\n    EncodingConstraintModel.prototype.hasAllRequiredPropertiesSpecific = function (encQ) {\r\n        return util_1.every(this.constraint.properties, function (prop) {\r\n            var nestedEncProp = property_1.getNestedEncodingProperty(prop);\r\n            if (nestedEncProp) {\r\n                var parent_1 = nestedEncProp.parent;\r\n                var child = nestedEncProp.child;\r\n                if (!encQ[parent_1]) {\r\n                    return true;\r\n                }\r\n                return !enumspec_1.isEnumSpec(encQ[parent_1][child]);\r\n            }\r\n            if (!encQ[prop]) {\r\n                return true;\r\n            }\r\n            return !enumspec_1.isEnumSpec(encQ[prop]);\r\n        });\r\n    };\r\n    EncodingConstraintModel.prototype.satisfy = function (encQ, schema, encEnumSpecIndex, opt) {\r\n        // TODO: Re-order logic to optimize the \"allowEnumSpecForProperties\" check\r\n        if (!this.constraint.allowEnumSpecForProperties) {\r\n            // TODO: extract as a method and do unit test\r\n            if (!this.hasAllRequiredPropertiesSpecific(encQ)) {\r\n                return true;\r\n            }\r\n        }\r\n        return this.constraint.satisfy(encQ, schema, encEnumSpecIndex, opt);\r\n    };\r\n    return EncodingConstraintModel;\r\n}(base_1.AbstractConstraintModel));\r\nexports.EncodingConstraintModel = EncodingConstraintModel;\r\nexports.ENCODING_CONSTRAINTS = [\r\n    {\r\n        name: 'aggregateOpSupportedByType',\r\n        description: 'Aggregate function should be supported by data type.',\r\n        properties: [property_1.Property.TYPE, property_1.Property.AGGREGATE],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.aggregate) {\r\n                return encQ.type !== type_1.Type.ORDINAL && encQ.type !== type_1.Type.NOMINAL;\r\n            }\r\n            // TODO: some aggregate function are actually supported by ordinal\r\n            return true; // no aggregate is okay with any type.\r\n        }\r\n    }, {\r\n        name: 'asteriskFieldWithCountOnly',\r\n        description: 'Field=\"*\" should be disallowed except aggregate=\"count\"',\r\n        properties: [property_1.Property.FIELD, property_1.Property.AGGREGATE],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            return (encQ.field === '*') === (encQ.aggregate === aggregate_1.AggregateOp.COUNT);\r\n        }\r\n    }, {\r\n        name: 'binAppliedForQuantitative',\r\n        description: 'bin should be applied to quantitative field only.',\r\n        properties: [property_1.Property.TYPE, property_1.Property.BIN],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.bin) {\r\n                // If binned, the type must be quantitative\r\n                return encQ.type === type_1.Type.QUANTITATIVE;\r\n            }\r\n            return true;\r\n        }\r\n    }, {\r\n        name: 'channelSupportsRole',\r\n        description: 'encoding channel should support the role of the field',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.BIN, property_1.Property.TIMEUNIT],\r\n        allowEnumSpecForProperties: true,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (enumspec_1.isEnumSpec(encQ.channel))\r\n                return true; // not ready for checking yet!\r\n            if (!encEnumSpecIndex.channel && !opt.constraintManuallySpecifiedValue) {\r\n                // Do not have to check this as this is manually specified by users.\r\n                return true;\r\n            }\r\n            var supportedRole = channel_1.getSupportedRole(encQ.channel);\r\n            if (encoding_1.isDimension(encQ)) {\r\n                return supportedRole.dimension;\r\n            }\r\n            else if (encoding_1.isMeasure(encQ)) {\r\n                return supportedRole.measure;\r\n            }\r\n            return true;\r\n        }\r\n    }, {\r\n        name: 'hasFn',\r\n        description: 'A field with as hasFn flag should have one of aggregate, timeUnit, or bin.',\r\n        properties: [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT],\r\n        allowEnumSpecForProperties: true,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.hasFn) {\r\n                return !!encQ.aggregate || !!encQ.bin || !!encQ.timeUnit;\r\n            }\r\n            return true;\r\n        }\r\n    }, {\r\n        name: 'omitScaleZeroWithBinnedField',\r\n        description: 'Do not use scale zero with binned field',\r\n        properties: [property_1.Property.SCALE, property_1.Property.SCALE_ZERO, property_1.Property.BIN],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.bin && encQ.scale) {\r\n                if (encQ.scale.zero === true) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }, {\r\n        name: 'onlyOneTypeOfFunction',\r\n        description: 'Only of of aggregate, autoCount, timeUnit, or bin should be applied at the same time.',\r\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN],\r\n        allowEnumSpecForProperties: true,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            var numFn = (!enumspec_1.isEnumSpec(encQ.aggregate) && !!encQ.aggregate ? 1 : 0) +\r\n                (!enumspec_1.isEnumSpec(encQ.autoCount) && !!encQ.autoCount ? 1 : 0) +\r\n                (!enumspec_1.isEnumSpec(encQ.bin) && !!encQ.bin ? 1 : 0) +\r\n                (!enumspec_1.isEnumSpec(encQ.timeUnit) && !!encQ.timeUnit ? 1 : 0);\r\n            return numFn <= 1;\r\n        }\r\n    }, {\r\n        name: 'timeUnitAppliedForTemporal',\r\n        description: 'Time unit should be applied to temporal field only.',\r\n        properties: [property_1.Property.TYPE, property_1.Property.TIMEUNIT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.timeUnit && encQ.type !== type_1.Type.TEMPORAL) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n    }, {\r\n        name: 'timeUnitShouldHaveVariation',\r\n        description: 'A particular time unit should be applied only if they produce unique values.',\r\n        properties: [property_1.Property.TIMEUNIT, property_1.Property.TYPE],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.timeUnit && encQ.type === type_1.Type.TEMPORAL) {\r\n                if (!encEnumSpecIndex.timeUnit && !opt.constraintManuallySpecifiedValue) {\r\n                    // Do not have to check this as this is manually specified by users.\r\n                    return true;\r\n                }\r\n                return schema.timeUnitHasVariation(encQ);\r\n            }\r\n            return true;\r\n        }\r\n    }, {\r\n        name: 'scalePropertiesSupportedByScaleType',\r\n        description: 'Scale properties must be supported by correct scale type',\r\n        properties: property_1.SCALE_PROPERTIES.concat([property_1.Property.SCALE, property_1.Property.TYPE]),\r\n        allowEnumSpecForProperties: true,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.scale) {\r\n                var scale = encQ.scale;\r\n                //  If encQ.type is an EnumSpec and scale.type is undefined, it is equivalent\r\n                //  to scale type is EnumSpec. If scale type is an EnumSpec, we do not yet know\r\n                //  what the scale type is, and thus can ignore the constraint.\r\n                var sType = encoding_1.scaleType(encQ);\r\n                if (sType === undefined) {\r\n                    // If still ambiguous, doesn't check the constraint\r\n                    return true;\r\n                }\r\n                for (var scaleProp in scale) {\r\n                    if (property_1.SUPPORTED_SCALE_PROPERTY_INDEX[scaleProp]) {\r\n                        if (!util_1.contains(property_1.SUPPORTED_SCALE_PROPERTY_INDEX[scaleProp], sType)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }, {\r\n        name: 'typeMatchesPrimitiveType',\r\n        description: 'Data type should be supported by field\\'s primitive type.',\r\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.field === '*') {\r\n                return true;\r\n            }\r\n            var primitiveType = schema.primitiveType(encQ.field);\r\n            var type = encQ.type;\r\n            if (!encEnumSpecIndex.field && !encEnumSpecIndex.type && !opt.constraintManuallySpecifiedValue) {\r\n                // Do not have to check this as this is manually specified by users.\r\n                return true;\r\n            }\r\n            switch (primitiveType) {\r\n                case schema_1.PrimitiveType.BOOLEAN:\r\n                case schema_1.PrimitiveType.STRING:\r\n                    return type !== type_1.Type.QUANTITATIVE && type !== type_1.Type.TEMPORAL;\r\n                case schema_1.PrimitiveType.NUMBER:\r\n                case schema_1.PrimitiveType.INTEGER:\r\n                    return type !== type_1.Type.TEMPORAL;\r\n                case schema_1.PrimitiveType.DATE:\r\n                    // TODO: add NOMINAL, ORDINAL support after we support this in Vega-Lite\r\n                    return type === type_1.Type.TEMPORAL;\r\n                case null:\r\n                    // field does not exist in the schema\r\n                    return false;\r\n            }\r\n            throw new Error('Not implemented');\r\n        }\r\n    },\r\n    {\r\n        name: 'typeMatchesSchemaType',\r\n        description: 'Enumerated data type of a field should match the field\\'s type in the schema.',\r\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (!encEnumSpecIndex.field && !encEnumSpecIndex.type && !opt.constraintManuallySpecifiedValue) {\r\n                // Do not have to check this as this is manually specified by users.\r\n                return true;\r\n            }\r\n            if (encQ.field === '*') {\r\n                return encQ.type === type_1.Type.QUANTITATIVE;\r\n            }\r\n            return schema.type(encQ.field) === encQ.type;\r\n        }\r\n    }, {\r\n        name: 'maxCardinalityForCategoricalColor',\r\n        description: 'Categorical channel should not have too high cardinality',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            // TODO: missing case where ordinal / temporal use categorical color\r\n            // (once we do so, need to add Property.BIN, Property.TIMEUNIT)\r\n            if (encQ.channel === channel_1.Channel.COLOR && encQ.type === type_1.Type.NOMINAL) {\r\n                return schema.cardinality(encQ) <= opt.maxCardinalityForCategoricalColor;\r\n            }\r\n            return true; // other channel is irrelevant to this constraint\r\n        }\r\n    }, {\r\n        name: 'maxCardinalityForFacet',\r\n        description: 'Row/column channel should not have too high cardinality',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.channel === channel_1.Channel.ROW || encQ.channel === channel_1.Channel.COLUMN) {\r\n                return schema.cardinality(encQ) <= opt.maxCardinalityForFacet;\r\n            }\r\n            return true; // other channel is irrelevant to this constraint\r\n        }\r\n    }, {\r\n        name: 'maxCardinalityForShape',\r\n        description: 'Shape channel should not have too high cardinality',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.channel === channel_1.Channel.SHAPE) {\r\n                return schema.cardinality(encQ) <= opt.maxCardinalityForShape;\r\n            }\r\n            return true; // other channel is irrelevant to this constraint\r\n        }\r\n    }, {\r\n        name: 'dataTypeAndFunctionMatchScaleType',\r\n        description: 'Scale type must match data type',\r\n        properties: [property_1.Property.TYPE, property_1.Property.SCALE, property_1.Property.SCALE_TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\r\n            if (encQ.scale) {\r\n                var type = encQ.type;\r\n                var sType = encoding_1.scaleType(encQ);\r\n                if (util_1.contains([type_1.Type.ORDINAL, type_1.Type.NOMINAL], type)) {\r\n                    return util_1.contains([scale_1.ScaleType.ORDINAL, undefined], sType);\r\n                }\r\n                else if (type === type_1.Type.TEMPORAL) {\r\n                    if (!encQ.timeUnit) {\r\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], sType);\r\n                    }\r\n                    else {\r\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, scale_1.ScaleType.ORDINAL, undefined], sType);\r\n                    }\r\n                }\r\n                else if (type === type_1.Type.QUANTITATIVE) {\r\n                    if (encQ.bin) {\r\n                        return util_1.contains([scale_1.ScaleType.LINEAR, undefined], sType);\r\n                    }\r\n                    else {\r\n                        return util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.QUANTILE, scale_1.ScaleType.QUANTIZE, scale_1.ScaleType.LINEAR, undefined], sType);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n].map(function (ec) { return new EncodingConstraintModel(ec); });\r\nexports.ENCODING_CONSTRAINT_INDEX = exports.ENCODING_CONSTRAINTS.reduce(function (m, ec) {\r\n    m[ec.name()] = ec;\r\n    return m;\r\n}, {});\r\nexports.ENCODING_CONSTRAINTS_BY_PROPERTY = exports.ENCODING_CONSTRAINTS.reduce(function (m, c) {\r\n    c.properties().forEach(function (prop) {\r\n        m[prop] = m[prop] || [];\r\n        m[prop].push(c);\r\n    });\r\n    return m;\r\n}, {});\r\n/**\r\n * Check all encoding constraints for a particular property and index tuple\r\n */\r\nfunction checkEncoding(prop, enumSpec, index, specM, schema, opt) {\r\n    // Check encoding constraint\r\n    var encodingConstraints = exports.ENCODING_CONSTRAINTS_BY_PROPERTY[prop] || [];\r\n    var encQ = specM.getEncodingQueryByIndex(index);\r\n    for (var i = 0; i < encodingConstraints.length; i++) {\r\n        var c = encodingConstraints[i];\r\n        // Check if the constraint is enabled\r\n        if (c.strict() || !!opt[c.name()]) {\r\n            // For strict constraint, or enabled non-strict, check the constraints\r\n            var satisfy = c.satisfy(encQ, schema, specM.enumSpecIndex.encodings[index], opt);\r\n            if (!satisfy) {\r\n                var violatedConstraint = '(enc) ' + c.name();\r\n                /* istanbul ignore if */\r\n                if (opt.verbose) {\r\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + enumSpec.name);\r\n                }\r\n                return violatedConstraint;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.checkEncoding = checkEncoding;\r\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar aggregate_1 = require('vega-lite/src/aggregate');\r\nvar channel_1 = require('vega-lite/src/channel');\r\nvar mark_1 = require('vega-lite/src/mark');\r\nvar scale_1 = require('vega-lite/src/scale');\r\nvar type_1 = require('vega-lite/src/type');\r\nvar base_1 = require('./base');\r\nvar enumspec_1 = require('../enumspec');\r\nvar property_1 = require('../property');\r\nvar encoding_1 = require('../query/encoding');\r\nvar util_1 = require('../util');\r\nvar encoding_2 = require('../query/encoding');\r\nvar NONSPATIAL_CHANNELS_INDEX = channel_1.NONSPATIAL_CHANNELS.reduce(function (m, channel) {\r\n    m[channel] = true;\r\n    return m;\r\n}, {});\r\nvar SpecConstraintModel = (function (_super) {\r\n    __extends(SpecConstraintModel, _super);\r\n    function SpecConstraintModel(specConstraint) {\r\n        _super.call(this, specConstraint);\r\n    }\r\n    SpecConstraintModel.prototype.hasAllRequiredPropertiesSpecific = function (specM) {\r\n        return util_1.every(this.constraint.properties, function (prop) {\r\n            if (prop === property_1.Property.MARK) {\r\n                return !enumspec_1.isEnumSpec(specM.getMark());\r\n            }\r\n            // TODO: transform\r\n            var nestedEncProp = property_1.getNestedEncodingProperty(prop);\r\n            if (nestedEncProp) {\r\n                var parent_1 = nestedEncProp.parent;\r\n                var child_1 = nestedEncProp.child;\r\n                return util_1.every(specM.getEncodings(), function (encQ) {\r\n                    if (!encQ[parent_1]) {\r\n                        return true;\r\n                    }\r\n                    return !enumspec_1.isEnumSpec(encQ[parent_1][child_1]);\r\n                });\r\n            }\r\n            if (!property_1.isEncodingProperty(prop)) {\r\n                throw new Error('UNIMPLEMENTED');\r\n            }\r\n            return util_1.every(specM.getEncodings(), function (encQ) {\r\n                if (!encQ[prop]) {\r\n                    return true;\r\n                }\r\n                return !enumspec_1.isEnumSpec(encQ[prop]);\r\n            });\r\n        });\r\n    };\r\n    SpecConstraintModel.prototype.satisfy = function (specM, schema, opt) {\r\n        // TODO: Re-order logic to optimize the \"allowEnumSpecForProperties\" check\r\n        if (!this.constraint.allowEnumSpecForProperties) {\r\n            if (!this.hasAllRequiredPropertiesSpecific(specM)) {\r\n                return true;\r\n            }\r\n        }\r\n        return this.constraint.satisfy(specM, schema, opt);\r\n    };\r\n    return SpecConstraintModel;\r\n}(base_1.AbstractConstraintModel));\r\nexports.SpecConstraintModel = SpecConstraintModel;\r\nexports.SPEC_CONSTRAINTS = [\r\n    {\r\n        name: 'noRepeatedChannel',\r\n        description: 'Each encoding channel should only be used once.',\r\n        properties: [property_1.Property.CHANNEL],\r\n        allowEnumSpecForProperties: true,\r\n        strict: true,\r\n        satisfy: function (specM, schema, opt) {\r\n            var usedChannel = {};\r\n            // channel for all encodings should be valid\r\n            return util_1.every(specM.getEncodings(), function (encQ) {\r\n                if (!enumspec_1.isEnumSpec(encQ.channel)) {\r\n                    // If channel is specified, it should no be used already\r\n                    if (usedChannel[encQ.channel]) {\r\n                        return false;\r\n                    }\r\n                    usedChannel[encQ.channel] = true;\r\n                    return true;\r\n                }\r\n                return true; // unspecified channel is valid\r\n            });\r\n        }\r\n    },\r\n    {\r\n        name: 'alwaysIncludeZeroInScaleWithBarMark',\r\n        description: 'Do not recommend bar mark if scale does not start at zero',\r\n        properties: [property_1.Property.MARK, property_1.Property.SCALE, property_1.Property.SCALE_ZERO, property_1.Property.CHANNEL, property_1.Property.TYPE],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (specM, schema, opt) {\r\n            var mark = specM.getMark();\r\n            var encodings = specM.getEncodings();\r\n            if (mark === mark_1.Mark.BAR) {\r\n                for (var _i = 0, encodings_1 = encodings; _i < encodings_1.length; _i++) {\r\n                    var encQ = encodings_1[_i];\r\n                    if ((encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) &&\r\n                        (encQ.type === type_1.Type.QUANTITATIVE) &&\r\n                        (encQ.scale && encQ.scale.zero === false)) {\r\n                        // TODO: zero shouldn't be manually specified\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'autoAddCount',\r\n        description: 'Automatically adding count only for plots with only ordinal, binned quantitative, or temporal with timeunit fields.',\r\n        properties: [property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.TYPE, property_1.Property.AUTOCOUNT],\r\n        allowEnumSpecForProperties: true,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            var hasAutoCount = util_1.some(specM.getEncodings(), function (encQ) { return encQ.autoCount === true; });\r\n            if (hasAutoCount) {\r\n                // Auto count should only be applied if all fields are nominal, ordinal, temporal with timeUnit, binned quantitative, or autoCount\r\n                return util_1.every(specM.getEncodings(), function (encQ) {\r\n                    if (encQ.autoCount !== undefined) {\r\n                        return true;\r\n                    }\r\n                    switch (encQ.type) {\r\n                        case type_1.Type.QUANTITATIVE:\r\n                            return !!encQ.bin;\r\n                        case type_1.Type.TEMPORAL:\r\n                            return !!encQ.timeUnit;\r\n                        case type_1.Type.ORDINAL:\r\n                        case type_1.Type.NOMINAL:\r\n                            return true;\r\n                    }\r\n                    /* istanbul ignore next */\r\n                    throw new Error('Unsupported Type');\r\n                });\r\n            }\r\n            else {\r\n                var neverHaveAutoCount = util_1.every(specM.enumSpecIndex.encodingIndicesByProperty['autoCount'], function (index) {\r\n                    return !enumspec_1.isEnumSpec(specM.getEncodingQueryByIndex(index).autoCount);\r\n                });\r\n                if (neverHaveAutoCount) {\r\n                    // If the query surely does not have autoCount\r\n                    // then one of the field should be\r\n                    // (1) unbinned quantitative\r\n                    // (2) temporal without time unit\r\n                    // (3) nominal or ordinal field\r\n                    // or at least have potential to be (still ambiguous).\r\n                    return util_1.some(specM.getEncodings(), function (encQ) {\r\n                        if (encQ.type === type_1.Type.QUANTITATIVE) {\r\n                            if (encQ.autoCount === false) {\r\n                                return false;\r\n                            }\r\n                            else {\r\n                                return !encQ.bin || enumspec_1.isEnumSpec(encQ.bin);\r\n                            }\r\n                        }\r\n                        else if (encQ.type === type_1.Type.TEMPORAL) {\r\n                            return !encQ.timeUnit || enumspec_1.isEnumSpec(encQ.timeUnit);\r\n                        }\r\n                        return false; // nominal or ordinal\r\n                    });\r\n                }\r\n            }\r\n            return true; // no auto count, no constraint\r\n        }\r\n    },\r\n    {\r\n        name: 'channelPermittedByMarkType',\r\n        description: 'Each encoding channel should be supported by the mark type',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\r\n        allowEnumSpecForProperties: true,\r\n        strict: true,\r\n        satisfy: function (specM, schema, opt) {\r\n            var mark = specM.getMark();\r\n            // if mark is unspecified, no need to check\r\n            if (enumspec_1.isEnumSpec(mark))\r\n                return true;\r\n            // TODO: can optimize this to detect only what's the changed property if needed.\r\n            return util_1.every(specM.getEncodings(), function (encQ) {\r\n                // channel unspecified, no need to check\r\n                if (enumspec_1.isEnumSpec(encQ.channel))\r\n                    return true;\r\n                return channel_1.supportMark(encQ.channel, mark);\r\n            });\r\n        }\r\n    },\r\n    {\r\n        name: 'hasAllRequiredChannelsForMark',\r\n        description: 'All required channels for the specified mark should be specified',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (specM, schema, opt) {\r\n            var mark = specM.getMark();\r\n            switch (mark) {\r\n                case mark_1.Mark.AREA:\r\n                case mark_1.Mark.LINE:\r\n                    return specM.channelUsed(channel_1.Channel.X) && specM.channelUsed(channel_1.Channel.Y);\r\n                case mark_1.Mark.TEXT:\r\n                    return specM.channelUsed(channel_1.Channel.TEXT);\r\n                case mark_1.Mark.BAR:\r\n                case mark_1.Mark.CIRCLE:\r\n                case mark_1.Mark.SQUARE:\r\n                case mark_1.Mark.TICK:\r\n                case mark_1.Mark.RULE:\r\n                    return specM.channelUsed(channel_1.Channel.X) || specM.channelUsed(channel_1.Channel.Y);\r\n                case mark_1.Mark.POINT:\r\n                    // This allows generating a point plot if channel was not an enum spec.\r\n                    return !specM.enumSpecIndex.hasProperty(property_1.Property.CHANNEL) ||\r\n                        specM.channelUsed(channel_1.Channel.X) || specM.channelUsed(channel_1.Channel.Y);\r\n            }\r\n            /* istanbul ignore next */\r\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + mark);\r\n        }\r\n    },\r\n    {\r\n        name: 'omitAggregate',\r\n        description: 'Omit aggregate plots.',\r\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\r\n        allowEnumSpecForProperties: true,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            if (specM.isAggregate()) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitAggregatePlotWithDimensionOnlyOnFacet',\r\n        description: 'All required channels for the specified mark should be specified',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            if (specM.isAggregate()) {\r\n                var hasNonFacetDim_1 = false, hasDim_1 = false, hasEnumeratedFacetDim_1 = false;\r\n                specM.specQuery.encodings.forEach(function (encQ, index) {\r\n                    if (encQ.autoCount === false)\r\n                        return; // skip unused field\r\n                    if (!encQ.aggregate && !encQ.autoCount) {\r\n                        hasDim_1 = true;\r\n                        if (util_1.contains([channel_1.Channel.ROW, channel_1.Channel.COLUMN], encQ.channel)) {\r\n                            if (specM.enumSpecIndex.hasEncodingProperty(index, property_1.Property.CHANNEL)) {\r\n                                hasEnumeratedFacetDim_1 = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            hasNonFacetDim_1 = true;\r\n                        }\r\n                    }\r\n                });\r\n                if (hasDim_1 && !hasNonFacetDim_1) {\r\n                    if (hasEnumeratedFacetDim_1 || opt.constraintManuallySpecifiedValue) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitAggregatePlotWithoutDimension',\r\n        description: 'Aggregate plots without dimension should be omitted',\r\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.TYPE],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            if (specM.isAggregate()) {\r\n                // TODO relax\r\n                return util_1.some(specM.getEncodings(), function (encQ) {\r\n                    if (encoding_1.isDimension(encQ)) {\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                });\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        // TODO: we can be smarter and check if bar has occlusion based on profiling statistics\r\n        name: 'omitBarLineAreaWithOcclusion',\r\n        description: 'Don\\'t use bar, line or area to visualize raw plot as they often lead to occlusion.',\r\n        properties: [property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            if (util_1.contains([mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA], specM.getMark())) {\r\n                return specM.isAggregate();\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitBarTickWithSize',\r\n        description: 'Do not map field to size channel with bar and tick mark',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\r\n        allowEnumSpecForProperties: true,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            var mark = specM.getMark();\r\n            if (util_1.contains([mark_1.Mark.TICK, mark_1.Mark.BAR], mark)) {\r\n                if (specM.channelUsed(channel_1.Channel.SIZE)) {\r\n                    if (opt.constraintManuallySpecifiedValue) {\r\n                        // If size is used and we constraintManuallySpecifiedValue,\r\n                        // then the spec violates this constraint.\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        // Otherwise have to search for the size channel and check if it is enumerated\r\n                        var encodings = specM.specQuery.encodings;\r\n                        for (var i = 0; i < encodings.length; i++) {\r\n                            var encQ = encodings[i];\r\n                            if (encQ.channel === channel_1.Channel.SIZE) {\r\n                                if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\r\n                                    // If enumerated, then this is bad\r\n                                    return false;\r\n                                }\r\n                                else {\r\n                                    // If it's manually specified, no need to continue searching, just return.\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true; // skip\r\n        }\r\n    },\r\n    {\r\n        name: 'omitBarAreaForLogScale',\r\n        description: 'Do not use bar and area mark for x and y\\'s log scale',\r\n        properties: [property_1.Property.MARK, property_1.Property.CHANNEL, property_1.Property.SCALE, property_1.Property.SCALE_TYPE, property_1.Property.TYPE],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (specM, schema, opt) {\r\n            var mark = specM.getMark();\r\n            var encodings = specM.getEncodings();\r\n            // TODO: mark or scale type should be enumerated\r\n            if (mark === mark_1.Mark.AREA || mark === mark_1.Mark.BAR) {\r\n                for (var _i = 0, encodings_2 = encodings; _i < encodings_2.length; _i++) {\r\n                    var encQ = encodings_2[_i];\r\n                    if ((encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) && encQ.scale) {\r\n                        var sType = encoding_2.scaleType(encQ);\r\n                        if (sType === scale_1.ScaleType.LOG) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitMultipleNonPositionalChannels',\r\n        description: 'Unless manually specified, do not use multiple non-positional encoding channel to avoid over-encoding.',\r\n        properties: [property_1.Property.CHANNEL],\r\n        allowEnumSpecForProperties: true,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            // have to use specM.specQuery.encodings insetad of specM.getEncodings()\r\n            // since specM.getEncodings() remove encQ with autoCount===false from the array\r\n            // and thus might shift the index\r\n            var encodings = specM.specQuery.encodings;\r\n            var nonPositionChannelCount = 0;\r\n            var hasEnumeratedNonPositionChannel = false;\r\n            for (var i = 0; i < encodings.length; i++) {\r\n                var encQ = encodings[i];\r\n                if (encQ.autoCount === false)\r\n                    continue; // ignore skipped encoding\r\n                var channel = encQ.channel;\r\n                if (!enumspec_1.isEnumSpec(channel)) {\r\n                    if (NONSPATIAL_CHANNELS_INDEX[channel]) {\r\n                        nonPositionChannelCount += 1;\r\n                        if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\r\n                            hasEnumeratedNonPositionChannel = true;\r\n                        }\r\n                        if (nonPositionChannelCount > 1 &&\r\n                            (hasEnumeratedNonPositionChannel || opt.constraintManuallySpecifiedValue)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitNonPositionalOrFacetOverPositionalChannels',\r\n        description: 'Do not use non-positional channels unless all positional channels are used',\r\n        properties: [property_1.Property.CHANNEL],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            var encodings = specM.specQuery.encodings;\r\n            var hasNonPositionalChannelOrFacet = false;\r\n            var hasEnumeratedNonPositionOrFacetChannel = false;\r\n            var hasX = false, hasY = false;\r\n            for (var i = 0; i < encodings.length; i++) {\r\n                var encQ = encodings[i];\r\n                if (encQ.autoCount === false)\r\n                    continue; // ignore skipped encoding\r\n                var channel = encQ.channel;\r\n                if (channel === channel_1.Channel.X) {\r\n                    hasX = true;\r\n                }\r\n                else if (channel === channel_1.Channel.Y) {\r\n                    hasY = true;\r\n                }\r\n                else if (!enumspec_1.isEnumSpec(channel)) {\r\n                    // All non positional channel / Facet\r\n                    hasNonPositionalChannelOrFacet = true;\r\n                    if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\r\n                        hasEnumeratedNonPositionOrFacetChannel = true;\r\n                    }\r\n                }\r\n            }\r\n            if (hasEnumeratedNonPositionOrFacetChannel ||\r\n                (opt.constraintManuallySpecifiedValue && hasNonPositionalChannelOrFacet)) {\r\n                return hasX && hasY;\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitRaw',\r\n        description: 'Omit raw plots.',\r\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            if (!specM.isAggregate()) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitRawContinuousFieldForAggregatePlot',\r\n        description: 'Aggregate plot should not use raw continuous field as group by values. ' +\r\n            '(Quantitative should be binned. Temporal should have time unit.)',\r\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.TYPE],\r\n        allowEnumSpecForProperties: true,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            if (specM.isAggregate()) {\r\n                var encodings = specM.specQuery.encodings;\r\n                for (var i = 0; i < encodings.length; i++) {\r\n                    var encQ = encodings[i];\r\n                    if (encQ.autoCount === false)\r\n                        continue; // skip unused encoding\r\n                    // TODO: aggregate for ordinal and temporal\r\n                    if (encQ.type === type_1.Type.TEMPORAL) {\r\n                        // Temporal fields should have timeUnit or is still an enumSpec\r\n                        if (!encQ.timeUnit && (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.TIMEUNIT) ||\r\n                            opt.constraintManuallySpecifiedValue)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    if (encQ.type === type_1.Type.QUANTITATIVE) {\r\n                        if (!encQ.bin && !encQ.aggregate && !encQ.autoCount) {\r\n                            // If Raw Q\r\n                            if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.BIN) ||\r\n                                specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.AGGREGATE) ||\r\n                                specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.AUTOCOUNT)) {\r\n                                // and it's raw from enumeration\r\n                                return false;\r\n                            }\r\n                            if (opt.constraintManuallySpecifiedValue) {\r\n                                // or if we constraintManuallySpecifiedValue\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitRawDetail',\r\n        description: 'Do not use detail channel with raw plot.',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (specM, schema, opt) {\r\n            if (specM.isAggregate()) {\r\n                return true;\r\n            }\r\n            return util_1.every(specM.specQuery.encodings, function (encQ, index) {\r\n                if (encQ.autoCount === false)\r\n                    return true; // ignore autoCount field\r\n                if (encQ.channel === channel_1.Channel.DETAIL) {\r\n                    // Detail channel for raw plot is not good, except when its enumerated\r\n                    // or when it's manually specified but we constraintManuallySpecifiedValue.\r\n                    if (specM.enumSpecIndex.hasEncodingProperty(index, property_1.Property.CHANNEL) ||\r\n                        opt.constraintManuallySpecifiedValue) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n    },\r\n    {\r\n        name: 'omitRepeatedField',\r\n        description: 'Each field should be mapped to only one channel',\r\n        properties: [property_1.Property.FIELD],\r\n        allowEnumSpecForProperties: true,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            var fieldUsed = {};\r\n            var fieldEnumerated = {};\r\n            var encodings = specM.specQuery.encodings;\r\n            for (var i = 0; i < encodings.length; i++) {\r\n                var encQ = encodings[i];\r\n                if (encQ.field && !enumspec_1.isEnumSpec(encQ.field)) {\r\n                    var field = encQ.field;\r\n                    if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.FIELD)) {\r\n                        fieldEnumerated[field] = true;\r\n                    }\r\n                    // When the field is specified previously,\r\n                    // if it is enumerated (either previously or in this encQ)\r\n                    // or if the opt.constraintManuallySpecifiedValue is true,\r\n                    // then it violates the constraint.\r\n                    if (fieldUsed[field]) {\r\n                        if (fieldEnumerated[field] || opt.constraintManuallySpecifiedValue) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    fieldUsed[field] = true;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    // TODO: omitShapeWithBin\r\n    {\r\n        name: 'omitVerticalDotPlot',\r\n        description: 'Do not output vertical dot plot.',\r\n        properties: [property_1.Property.CHANNEL],\r\n        allowEnumSpecForProperties: true,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            var encodings = specM.getEncodings();\r\n            if (encodings.length === 1 && encodings[0].channel === channel_1.Channel.Y) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    // EXPENSIVE CONSTRAINTS -- check them later!\r\n    {\r\n        name: 'hasAppropriateGraphicTypeForMark',\r\n        description: 'Has appropriate graphic type for mark',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            var mark = specM.getMark();\r\n            switch (mark) {\r\n                case mark_1.Mark.AREA:\r\n                case mark_1.Mark.LINE:\r\n                    if (specM.isAggregate()) {\r\n                        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\r\n                        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\r\n                        var xIsMeasure = xEncQ && encoding_2.isMeasure(xEncQ);\r\n                        var yIsMeasure = yEncQ && encoding_2.isMeasure(yEncQ);\r\n                        // for aggregate line / area, we need at least one group-by axis and one measure axis.\r\n                        return xEncQ && yEncQ && (xIsMeasure !== yIsMeasure) &&\r\n                            // and the dimension axis should not be nominal\r\n                            // TODO: make this clause optional\r\n                            !(!xIsMeasure && xEncQ.type === type_1.Type.NOMINAL) &&\r\n                            !(!yIsMeasure && yEncQ.type === type_1.Type.NOMINAL);\r\n                    }\r\n                    return true;\r\n                case mark_1.Mark.TEXT:\r\n                    // FIXME correctly when we add text\r\n                    return true;\r\n                case mark_1.Mark.BAR:\r\n                case mark_1.Mark.TICK:\r\n                    // Bar and tick should not use size.\r\n                    if (specM.channelUsed(channel_1.Channel.SIZE)) {\r\n                        return false;\r\n                    }\r\n                    // Tick and Bar should have one and only one measure\r\n                    if (specM.isMeasure(channel_1.Channel.X) !== specM.isMeasure(channel_1.Channel.Y)) {\r\n                        // TODO: Bar and tick's dimension should not be continuous (quant/time) scale\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                case mark_1.Mark.CIRCLE:\r\n                case mark_1.Mark.POINT:\r\n                case mark_1.Mark.SQUARE:\r\n                case mark_1.Mark.RULE:\r\n                    return true;\r\n            }\r\n            /* istanbul ignore next */\r\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + mark);\r\n        }\r\n    },\r\n    {\r\n        name: 'omitNonLinearScaleTypeWithStack',\r\n        description: 'Stacked plot should only use linear scale',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.SCALE, property_1.Property.SCALE_TYPE, property_1.Property.TYPE],\r\n        // TODO: Property.STACK\r\n        allowEnumSpecForProperties: false,\r\n        strict: true,\r\n        satisfy: function (specM, schema, opt) {\r\n            var stack = specM.stack();\r\n            if (stack) {\r\n                for (var _i = 0, _a = specM.getEncodings(); _i < _a.length; _i++) {\r\n                    var encQ = _a[_i];\r\n                    if ((!!encQ.aggregate || encQ.autoCount === true) &&\r\n                        encQ.type === type_1.Type.QUANTITATIVE &&\r\n                        util_1.contains([channel_1.Channel.X, channel_1.Channel.Y], encQ.channel)) {\r\n                        if (encoding_2.scaleType(encQ) !== scale_1.ScaleType.LINEAR) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitNonSumStack',\r\n        description: 'Stacked plot should use summative aggregation such as sum, count, or distinct',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            var stack = specM.stack();\r\n            if (stack) {\r\n                var measureEncQ = specM.getEncodingQueryByChannel(stack.fieldChannel);\r\n                return util_1.contains(aggregate_1.SUM_OPS, measureEncQ.aggregate) || !!measureEncQ.autoCount;\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    {\r\n        name: 'omitTableWithOcclusionIfAutoAddCount',\r\n        description: 'Plots without aggregation or autocount where x and y are both dimensions should be omitted if autoAddCount is enabled as they often lead to occlusion',\r\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\r\n        allowEnumSpecForProperties: false,\r\n        strict: false,\r\n        satisfy: function (specM, schema, opt) {\r\n            if (opt.autoAddCount) {\r\n                // TODO(#186): take mark properties channel into account\r\n                if (specM.isDimension(channel_1.Channel.X) &&\r\n                    specM.isDimension(channel_1.Channel.Y) &&\r\n                    !specM.isAggregate() // TODO: refactor based on statistics\r\n                ) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n].map(function (sc) { return new SpecConstraintModel(sc); });\r\n// For testing\r\nexports.SPEC_CONSTRAINT_INDEX = exports.SPEC_CONSTRAINTS.reduce(function (m, c) {\r\n    m[c.name()] = c;\r\n    return m;\r\n}, {});\r\n//\r\nexports.SPEC_CONSTRAINTS_BY_PROPERTY = exports.SPEC_CONSTRAINTS.reduce(function (m, c) {\r\n    c.properties().forEach(function (prop) {\r\n        m[prop] = m[prop] || [];\r\n        m[prop].push(c);\r\n    });\r\n    return m;\r\n}, {});\r\n/**\r\n * Check all encoding constraints for a particular property and index tuple\r\n */\r\nfunction checkSpec(prop, enumSpec, specM, schema, opt) {\r\n    // Check encoding constraint\r\n    var specConstraints = exports.SPEC_CONSTRAINTS_BY_PROPERTY[prop] || [];\r\n    for (var i = 0; i < specConstraints.length; i++) {\r\n        var c = specConstraints[i];\r\n        // Check if the constraint is enabled\r\n        if (c.strict() || !!opt[c.name()]) {\r\n            // For strict constraint, or enabled non-strict, check the constraints\r\n            var satisfy = c.satisfy(specM, schema, opt);\r\n            if (!satisfy) {\r\n                var violatedConstraint = '(spec) ' + c.name();\r\n                /* istanbul ignore if */\r\n                if (opt.verbose) {\r\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + enumSpec.name);\r\n                }\r\n                return violatedConstraint;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.checkSpec = checkSpec;\r\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\r\nexports.version = '0.6.7';\r\nvar util_1 = require('./util');\r\nexports.config = require('./config');\r\nexports.constraint = require('./constraint/constraint');\r\nexports.enumerate = require('./enumerator');\r\nexports.enumSpec = require('./enumspec');\r\nvar generate_1 = require('./generate');\r\nexports.generate = generate_1.generate;\r\nexports.model = require('./model');\r\nexports.nest = require('./nest');\r\nexports.property = require('./property');\r\n// Make it so that we can call cql.query() as method, or access other methods inside cql.query\r\nvar cqlQuery = require('./query/query');\r\nvar query_1 = require('./query/query');\r\nexports.query = util_1.extend(query_1.query, cqlQuery);\r\nexports.ranking = require('./ranking/ranking');\r\nexports.schema = require('./schema');\r\nexports.util = require('./util');\r\n//# sourceMappingURL=cql.js.map",
    "\"use strict\";\r\nvar encoding_1 = require('./constraint/encoding');\r\nvar spec_1 = require('./constraint/spec');\r\nvar property_1 = require('./property');\r\nexports.ENUMERATOR_INDEX = {};\r\nexports.ENUMERATOR_INDEX[property_1.Property.MARK] = function (enumSpecIndex, schema, opt) {\r\n    return function (answerSet, specM) {\r\n        var markEnumSpec = specM.getMark();\r\n        // enumerate the value\r\n        markEnumSpec.enum.forEach(function (mark) {\r\n            specM.setMark(mark);\r\n            // Check spec constraint\r\n            var violatedSpecConstraint = spec_1.checkSpec(property_1.Property.MARK, enumSpecIndex.mark, specM, schema, opt);\r\n            if (!violatedSpecConstraint) {\r\n                // emit\r\n                answerSet.push(specM.duplicate());\r\n            }\r\n        });\r\n        // Reset to avoid side effect\r\n        specM.resetMark();\r\n        return answerSet;\r\n    };\r\n};\r\nproperty_1.ENCODING_PROPERTIES.forEach(function (prop) {\r\n    exports.ENUMERATOR_INDEX[prop] = EncodingPropertyGeneratorFactory(prop);\r\n});\r\nproperty_1.NESTED_ENCODING_PROPERTIES.forEach(function (nestedProp) {\r\n    exports.ENUMERATOR_INDEX[nestedProp.property] = EncodingPropertyGeneratorFactory(nestedProp.property);\r\n});\r\n/**\r\n * @param prop property type.\r\n * @return an answer set reducer factory for the given prop.\r\n */\r\nfunction EncodingPropertyGeneratorFactory(prop) {\r\n    /**\r\n     * @return as reducer that takes a specQueryModel as input and output an answer set array.\r\n     */\r\n    return function (enumSpecIndex, schema, opt) {\r\n        return function (answerSet, specM) {\r\n            // index of encoding mappings that require enumeration\r\n            var indices = enumSpecIndex.encodingIndicesByProperty[prop];\r\n            function enumerate(jobIndex) {\r\n                if (jobIndex === indices.length) {\r\n                    // emit and terminate\r\n                    answerSet.push(specM.duplicate());\r\n                    return;\r\n                }\r\n                var index = indices[jobIndex];\r\n                var enumSpec = enumSpecIndex.encodings[index][prop];\r\n                var encQ = specM.getEncodingQueryByIndex(index);\r\n                var propEnumSpec = specM.getEncodingProperty(index, prop);\r\n                if (\r\n                // TODO: encQ.exclude\r\n                // If this encoding query is an excluded autoCount, there is no point enumerating other properties\r\n                // for this encoding query because they will be excluded anyway.\r\n                // Thus, we can just move on to the next encoding to enumerate.\r\n                encQ.autoCount === false ||\r\n                    // nested encoding property might have its parent set to false\r\n                    // therefore, we no longer have to enumerate them\r\n                    !propEnumSpec) {\r\n                    enumerate(jobIndex + 1);\r\n                }\r\n                else {\r\n                    enumSpec.enum.forEach(function (propVal) {\r\n                        if (propVal === null) {\r\n                            // our duplicate() method use JSON.stringify, parse and thus can accidentally\r\n                            // convert undefined in an array into null\r\n                            propVal = undefined;\r\n                        }\r\n                        specM.setEncodingProperty(index, prop, propVal, enumSpec);\r\n                        // Check encoding constraint\r\n                        var violatedEncodingConstraint = encoding_1.checkEncoding(prop, enumSpec, index, specM, schema, opt);\r\n                        if (violatedEncodingConstraint) {\r\n                            return; // do not keep searching\r\n                        }\r\n                        // Check spec constraint\r\n                        var violatedSpecConstraint = spec_1.checkSpec(prop, enumSpec, specM, schema, opt);\r\n                        if (violatedSpecConstraint) {\r\n                            return; // do not keep searching\r\n                        }\r\n                        // If qualify all of the constraints, keep enumerating\r\n                        enumerate(jobIndex + 1);\r\n                    });\r\n                    // Reset to avoid side effect\r\n                    specM.resetEncodingProperty(index, prop, enumSpec);\r\n                }\r\n            }\r\n            // start enumerating from 0\r\n            enumerate(0);\r\n            return answerSet;\r\n        };\r\n    };\r\n}\r\nexports.EncodingPropertyGeneratorFactory = EncodingPropertyGeneratorFactory;\r\n//# sourceMappingURL=enumerator.js.map",
    "\"use strict\";\r\nvar util_1 = require('./util');\r\n/** Enum for a short form of the enumeration spec. */\r\n(function (ShortEnumSpec) {\r\n    ShortEnumSpec[ShortEnumSpec[\"ENUMSPEC\"] = '?'] = \"ENUMSPEC\";\r\n})(exports.ShortEnumSpec || (exports.ShortEnumSpec = {}));\r\nvar ShortEnumSpec = exports.ShortEnumSpec;\r\nexports.SHORT_ENUM_SPEC = ShortEnumSpec.ENUMSPEC;\r\nfunction isEnumSpec(prop) {\r\n    return prop === exports.SHORT_ENUM_SPEC || (prop !== undefined && (!!prop.enum || !!prop.name) && !util_1.isArray(prop));\r\n}\r\nexports.isEnumSpec = isEnumSpec;\r\nfunction initEnumSpec(prop, defaultName, defaultEnumValues) {\r\n    return util_1.extend({}, {\r\n        name: defaultName,\r\n        enum: defaultEnumValues\r\n    }, prop === exports.SHORT_ENUM_SPEC ? {} : prop);\r\n}\r\nexports.initEnumSpec = initEnumSpec;\r\n//# sourceMappingURL=enumspec.js.map",
    "\"use strict\";\r\nvar property_1 = require('./property');\r\nvar util_1 = require('./util');\r\nvar EnumSpecIndex = (function () {\r\n    function EnumSpecIndex() {\r\n        this._mark = undefined;\r\n        this._encodings = {};\r\n        this._encodingIndicesByProperty = {};\r\n    }\r\n    EnumSpecIndex.prototype.setEncodingProperty = function (index, prop, enumSpec) {\r\n        var encodingsIndex = this._encodings;\r\n        // Init encoding index and set prop\r\n        var encIndex = encodingsIndex[index] = encodingsIndex[index] || {};\r\n        encIndex[prop] = enumSpec;\r\n        // Initialize indicesByProperty[prop] and add index\r\n        var encodingIndicesByProperty = this._encodingIndicesByProperty;\r\n        (encodingIndicesByProperty[prop] = encodingIndicesByProperty[prop] || []).push(index);\r\n        return this;\r\n    };\r\n    EnumSpecIndex.prototype.hasEncodingProperty = function (index, prop) {\r\n        return !!(this._encodings[index] || {})[prop];\r\n    };\r\n    EnumSpecIndex.prototype.hasProperty = function (prop) {\r\n        if (property_1.isEncodingProperty(prop)) {\r\n            return !!this.encodingIndicesByProperty[prop];\r\n        }\r\n        if (prop === property_1.Property.MARK) {\r\n            return !!this.mark;\r\n        }\r\n        /* istanbul ignore next */\r\n        throw new Error('Unimplemented for property ' + prop);\r\n    };\r\n    EnumSpecIndex.prototype.isEmpty = function () {\r\n        return !this.mark && util_1.keys(this.encodingIndicesByProperty).length === 0;\r\n    };\r\n    EnumSpecIndex.prototype.setMark = function (mark) {\r\n        this._mark = mark;\r\n        return this;\r\n    };\r\n    Object.defineProperty(EnumSpecIndex.prototype, \"mark\", {\r\n        get: function () {\r\n            return this._mark;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(EnumSpecIndex.prototype, \"encodings\", {\r\n        get: function () {\r\n            return this._encodings;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(EnumSpecIndex.prototype, \"encodingIndicesByProperty\", {\r\n        get: function () {\r\n            return this._encodingIndicesByProperty;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return EnumSpecIndex;\r\n}());\r\nexports.EnumSpecIndex = EnumSpecIndex;\r\n//# sourceMappingURL=enumspecindex.js.map",
    "\"use strict\";\r\nvar enumerator_1 = require('../src/enumerator');\r\nvar config_1 = require('./config');\r\nvar model_1 = require('./model');\r\nvar stylize_1 = require('./stylize');\r\nfunction generate(specQ, schema, opt) {\r\n    if (opt === void 0) { opt = config_1.DEFAULT_QUERY_CONFIG; }\r\n    // 1. Build a SpecQueryModel, which also contains enumSpecIndex\r\n    var specM = model_1.SpecQueryModel.build(specQ, schema, opt);\r\n    var enumSpecIndex = specM.enumSpecIndex;\r\n    // 2. Enumerate each of the properties based on propPrecedence.\r\n    var answerSet = [specM]; // Initialize Answer Set with only the input spec query.\r\n    opt.propertyPrecedence.forEach(function (prop) {\r\n        // If the original specQuery contains enumSpec for this prop\r\n        if (enumSpecIndex.hasProperty(prop)) {\r\n            // update answerset\r\n            var reducer = enumerator_1.ENUMERATOR_INDEX[prop](enumSpecIndex, schema, opt);\r\n            answerSet = answerSet.reduce(reducer, []);\r\n        }\r\n    });\r\n    if (opt.stylize) {\r\n        if ((opt.nominalColorScaleForHighCardinality !== null) ||\r\n            (opt.smallBandSizeForHighCardinalityOrFacet !== null) ||\r\n            (opt.xAxisOnTopForHighYCardinalityWithoutColumn !== null)) {\r\n            return stylize_1.stylize(answerSet, schema, opt);\r\n        }\r\n    }\r\n    return answerSet;\r\n}\r\nexports.generate = generate;\r\n//# sourceMappingURL=generate.js.map",
    "\"use strict\";\r\nvar aggregate_1 = require('vega-lite/src/aggregate');\r\nvar type_1 = require('vega-lite/src/type');\r\nvar property_1 = require('./property');\r\nvar enumspec_1 = require('./enumspec');\r\nvar enumspecindex_1 = require('./enumspecindex');\r\nvar spec_1 = require('./query/spec');\r\nvar encoding_1 = require('./query/encoding');\r\nvar groupby_1 = require('./query/groupby');\r\nvar shorthand_1 = require('./query/shorthand');\r\nvar util_1 = require('./util');\r\nfunction getDefaultName(prop) {\r\n    switch (prop) {\r\n        case property_1.Property.MARK:\r\n            return 'm';\r\n        case property_1.Property.CHANNEL:\r\n            return 'c';\r\n        case property_1.Property.AGGREGATE:\r\n            return 'a';\r\n        case property_1.Property.AUTOCOUNT:\r\n            return '#';\r\n        case property_1.Property.BIN:\r\n            return 'b';\r\n        case property_1.Property.BIN_MAXBINS:\r\n            return 'b-mb';\r\n        case property_1.Property.SORT:\r\n            return 'so';\r\n        case property_1.Property.SORT_FIELD:\r\n            return 'so-f';\r\n        case property_1.Property.SORT_OP:\r\n            return 'so-op';\r\n        case property_1.Property.SORT_ORDER:\r\n            return 'so-or';\r\n        case property_1.Property.SCALE:\r\n            return 's';\r\n        case property_1.Property.SCALE_BANDSIZE:\r\n            return 's-bs';\r\n        case property_1.Property.SCALE_CLAMP:\r\n            return 's-c';\r\n        case property_1.Property.SCALE_DOMAIN:\r\n            return 's-d';\r\n        case property_1.Property.SCALE_EXPONENT:\r\n            return 's-e';\r\n        case property_1.Property.SCALE_NICE:\r\n            return 's-n';\r\n        case property_1.Property.SCALE_RANGE:\r\n            return 's-ra';\r\n        case property_1.Property.SCALE_ROUND:\r\n            return 's-r';\r\n        case property_1.Property.SCALE_TYPE:\r\n            return 's-t';\r\n        case property_1.Property.SCALE_USERAWDOMAIN:\r\n            return 's-u';\r\n        case property_1.Property.SCALE_ZERO:\r\n            return 's-z';\r\n        case property_1.Property.AXIS:\r\n            return 'ax';\r\n        case property_1.Property.AXIS_AXISCOLOR:\r\n            return 'ax-ac';\r\n        case property_1.Property.AXIS_AXISWIDTH:\r\n            return 'ax-aw';\r\n        case property_1.Property.AXIS_LAYER:\r\n            return 'ax-lay';\r\n        case property_1.Property.AXIS_OFFSET:\r\n            return 'ax-of';\r\n        case property_1.Property.AXIS_ORIENT:\r\n            return 'ax-or';\r\n        case property_1.Property.AXIS_GRID:\r\n            return 'ax-g';\r\n        case property_1.Property.AXIS_GRIDCOLOR:\r\n            return 'ax-gc';\r\n        case property_1.Property.AXIS_GRIDDASH:\r\n            return 'ax-gd';\r\n        case property_1.Property.AXIS_GRIDOPACITY:\r\n            return 'ax-go';\r\n        case property_1.Property.AXIS_GRIDWIDTH:\r\n            return 'ax-gw';\r\n        case property_1.Property.AXIS_LABELS:\r\n            return 'ax-lab';\r\n        case property_1.Property.AXIS_FORMAT:\r\n            return 'ax-f';\r\n        case property_1.Property.AXIS_LABELANGLE:\r\n            return 'ax-laba';\r\n        case property_1.Property.AXIS_LABELMAXLENGTH:\r\n            return 'ax-labm';\r\n        case property_1.Property.AXIS_SHORTTIMELABELS:\r\n            return 'ax-stl';\r\n        case property_1.Property.AXIS_SUBDIVIDE:\r\n            return 'ax-sub';\r\n        case property_1.Property.AXIS_TICKS:\r\n            return 'ax-t';\r\n        case property_1.Property.AXIS_TICKCOLOR:\r\n            return 'ax-tc';\r\n        case property_1.Property.AXIS_TICKLABELCOLOR:\r\n            return 'ax-tlc';\r\n        case property_1.Property.AXIS_TICKLABELFONT:\r\n            return 'ax-tlf';\r\n        case property_1.Property.AXIS_TICKLABELFONTSIZE:\r\n            return 'ax-tlfs';\r\n        case property_1.Property.AXIS_TICKPADDING:\r\n            return 'ax-tp';\r\n        case property_1.Property.AXIS_TICKSIZE:\r\n            return 'ax-ts';\r\n        case property_1.Property.AXIS_TICKSIZEMAJOR:\r\n            return 'ax-tsma';\r\n        case property_1.Property.AXIS_TICKSIZEMINOR:\r\n            return 'ax-tsmi';\r\n        case property_1.Property.AXIS_TICKSIZEEND:\r\n            return 'ax-tse';\r\n        case property_1.Property.AXIS_TICKWIDTH:\r\n            return 'ax-tw';\r\n        case property_1.Property.AXIS_VALUES:\r\n            return 'ax-v';\r\n        case property_1.Property.AXIS_TITLE:\r\n            return 'ax-ti';\r\n        case property_1.Property.AXIS_TITLECOLOR:\r\n            return 'ax-tic';\r\n        case property_1.Property.AXIS_TITLEFONT:\r\n            return 'ax-tif';\r\n        case property_1.Property.AXIS_TITLEFONTSIZE:\r\n            return 'ax-tifs';\r\n        case property_1.Property.AXIS_TITLEFONTWEIGHT:\r\n            return 'ax-tifw';\r\n        case property_1.Property.AXIS_TITLEOFFSET:\r\n            return 'ax-tio';\r\n        case property_1.Property.AXIS_TITLEMAXLENGTH:\r\n            return 'ax-timl';\r\n        case property_1.Property.AXIS_CHARACTERWIDTH:\r\n            return 'ax-cw';\r\n        case property_1.Property.LEGEND:\r\n            return 'l';\r\n        case property_1.Property.LEGEND_ORIENT:\r\n            return 'l-or';\r\n        case property_1.Property.LEGEND_OFFSET:\r\n            return 'l-of';\r\n        case property_1.Property.LEGEND_VALUES:\r\n            return 'l-v';\r\n        case property_1.Property.LEGEND_FORMAT:\r\n            return 'l-f';\r\n        case property_1.Property.LEGEND_LABELALIGN:\r\n            return 'l-la';\r\n        case property_1.Property.LEGEND_LABELBASELINE:\r\n            return 'l-lb';\r\n        case property_1.Property.LEGEND_LABELCOLOR:\r\n            return 'l-lc';\r\n        case property_1.Property.LEGEND_LABELFONT:\r\n            return 'l-lf';\r\n        case property_1.Property.LEGEND_LABELFONTSIZE:\r\n            return 'l-lfs';\r\n        case property_1.Property.LEGEND_SHORTTIMELABELS:\r\n            return 'l-stl';\r\n        case property_1.Property.LEGEND_SYMBOLCOLOR:\r\n            return 'l-syc';\r\n        case property_1.Property.LEGEND_SYMBOLSHAPE:\r\n            return 'l-sysh';\r\n        case property_1.Property.LEGEND_SYMBOLSIZE:\r\n            return 'l-sysi';\r\n        case property_1.Property.LEGEND_SYMBOLSTROKEWIDTH:\r\n            return 'l-sysw';\r\n        case property_1.Property.LEGEND_TITLE:\r\n            return 'l-ti';\r\n        case property_1.Property.LEGEND_TITLECOLOR:\r\n            return 'l-tic';\r\n        case property_1.Property.LEGEND_TITLEFONT:\r\n            return 'l-tif';\r\n        case property_1.Property.LEGEND_TITLEFONTSIZE:\r\n            return 'l-tifs';\r\n        case property_1.Property.LEGEND_TITLEFONTWEIGHT:\r\n            return 'l-tifw';\r\n        case property_1.Property.TIMEUNIT:\r\n            return 'tu';\r\n        case property_1.Property.FIELD:\r\n            return 'f';\r\n        case property_1.Property.TYPE:\r\n            return 't';\r\n    }\r\n    /* istanbul ignore next */\r\n    throw new Error('Default name undefined');\r\n}\r\nexports.getDefaultName = getDefaultName;\r\nfunction getDefaultEnumValues(prop, schema, opt) {\r\n    switch (prop) {\r\n        case property_1.Property.FIELD: // For field, by default enumerate all fields\r\n        case property_1.Property.SORT_FIELD:\r\n            return schema.fields();\r\n        // True, False for boolean values\r\n        case property_1.Property.AXIS:\r\n        case property_1.Property.AXIS_GRID:\r\n        case property_1.Property.AXIS_LABELS:\r\n        case property_1.Property.AXIS_SHORTTIMELABELS:\r\n        case property_1.Property.BIN:\r\n        case property_1.Property.LEGEND:\r\n        case property_1.Property.LEGEND_SHORTTIMELABELS:\r\n        case property_1.Property.SCALE:\r\n        case property_1.Property.SCALE_CLAMP:\r\n        case property_1.Property.SCALE_NICE:\r\n        case property_1.Property.SCALE_ROUND:\r\n        case property_1.Property.SCALE_USERAWDOMAIN:\r\n        case property_1.Property.SCALE_ZERO:\r\n        case property_1.Property.AUTOCOUNT:\r\n            return [false, true];\r\n        // For other properties, take default enumValues from config.\r\n        // The config name for each prop is a plural form of the prop.\r\n        case property_1.Property.AGGREGATE:\r\n            return opt.aggregates;\r\n        case property_1.Property.AXIS_AXISCOLOR:\r\n            return opt.axisAxisColors;\r\n        case property_1.Property.AXIS_AXISWIDTH:\r\n            return opt.axisAxisWidths;\r\n        case property_1.Property.AXIS_LAYER:\r\n            return opt.axisLayers;\r\n        case property_1.Property.AXIS_OFFSET:\r\n            return opt.axisOffsets;\r\n        case property_1.Property.AXIS_ORIENT:\r\n            return opt.axisOrients;\r\n        case property_1.Property.AXIS_GRIDCOLOR:\r\n            return opt.axisGridColors;\r\n        case property_1.Property.AXIS_GRIDDASH:\r\n            return opt.axisGridDashes;\r\n        case property_1.Property.AXIS_GRIDOPACITY:\r\n            return opt.axisGridOpacities;\r\n        case property_1.Property.AXIS_GRIDWIDTH:\r\n            return opt.axisGridWidths;\r\n        case property_1.Property.AXIS_FORMAT:\r\n            return opt.axisFormats;\r\n        case property_1.Property.AXIS_LABELANGLE:\r\n            return opt.axisLabelAngles;\r\n        case property_1.Property.AXIS_LABELMAXLENGTH:\r\n            return opt.axisLabelMaxLengths;\r\n        case property_1.Property.AXIS_SUBDIVIDE:\r\n            return opt.axisSubDivides;\r\n        case property_1.Property.AXIS_TICKS:\r\n            return opt.axisTicks;\r\n        case property_1.Property.AXIS_TICKCOLOR:\r\n            return opt.axisTickColors;\r\n        case property_1.Property.AXIS_TICKLABELCOLOR:\r\n            return opt.axisTickLabelColors;\r\n        case property_1.Property.AXIS_TICKLABELFONT:\r\n            return opt.axisTickLabelFonts;\r\n        case property_1.Property.AXIS_TICKLABELFONTSIZE:\r\n            return opt.axisTickLabelFontSizes;\r\n        case property_1.Property.AXIS_TICKPADDING:\r\n            return opt.axisTickPaddings;\r\n        case property_1.Property.AXIS_TICKSIZE:\r\n            return opt.axisTickSizes;\r\n        case property_1.Property.AXIS_TICKSIZEMAJOR:\r\n            return opt.axisTickSizeMajors;\r\n        case property_1.Property.AXIS_TICKSIZEMINOR:\r\n            return opt.axisTickSizeMinors;\r\n        case property_1.Property.AXIS_TICKSIZEEND:\r\n            return opt.axisTickSizeEnds;\r\n        case property_1.Property.AXIS_TICKWIDTH:\r\n            return opt.axisTickWidths;\r\n        case property_1.Property.AXIS_VALUES:\r\n            return opt.axisValuesList;\r\n        case property_1.Property.AXIS_TITLE:\r\n            return opt.axisTitles;\r\n        case property_1.Property.AXIS_TITLECOLOR:\r\n            return opt.axisTitleColors;\r\n        case property_1.Property.AXIS_TITLEFONT:\r\n            return opt.axisTitleFonts;\r\n        case property_1.Property.AXIS_TITLEFONTWEIGHT:\r\n            return opt.axisTitleFontWeights;\r\n        case property_1.Property.AXIS_TITLEFONTSIZE:\r\n            return opt.axisTitleFontSizes;\r\n        case property_1.Property.AXIS_TITLEOFFSET:\r\n            return opt.axisTitleOffsets;\r\n        case property_1.Property.AXIS_TITLEMAXLENGTH:\r\n            return opt.axisTitleMaxLengths;\r\n        case property_1.Property.AXIS_CHARACTERWIDTH:\r\n            return opt.axisCharacterWidths;\r\n        case property_1.Property.BIN_MAXBINS:\r\n            return opt.maxBinsList;\r\n        case property_1.Property.CHANNEL:\r\n            return opt.channels;\r\n        case property_1.Property.MARK:\r\n            return opt.marks;\r\n        case property_1.Property.LEGEND_ORIENT:\r\n            return opt.legendOrients;\r\n        case property_1.Property.LEGEND_OFFSET:\r\n            return opt.legendOffsets;\r\n        case property_1.Property.LEGEND_VALUES:\r\n            return opt.legendValuesList;\r\n        case property_1.Property.LEGEND_FORMAT:\r\n            return opt.legendFormats;\r\n        case property_1.Property.LEGEND_LABELALIGN:\r\n            return opt.legendLabelAligns;\r\n        case property_1.Property.LEGEND_LABELBASELINE:\r\n            return opt.legendLabelBaselines;\r\n        case property_1.Property.LEGEND_LABELCOLOR:\r\n            return opt.legendLabelColors;\r\n        case property_1.Property.LEGEND_LABELFONT:\r\n            return opt.legendLabelFonts;\r\n        case property_1.Property.LEGEND_LABELFONTSIZE:\r\n            return opt.legendLabelFontSizes;\r\n        case property_1.Property.LEGEND_SYMBOLCOLOR:\r\n            return opt.legendSymbolColors;\r\n        case property_1.Property.LEGEND_SYMBOLSHAPE:\r\n            return opt.legendSymbolShapes;\r\n        case property_1.Property.LEGEND_SYMBOLSIZE:\r\n            return opt.legendSymbolSizes;\r\n        case property_1.Property.LEGEND_SYMBOLSTROKEWIDTH:\r\n            return opt.legendSymbolStrokeWidths;\r\n        case property_1.Property.LEGEND_TITLE:\r\n            return opt.legendTitles;\r\n        case property_1.Property.LEGEND_TITLECOLOR:\r\n            return opt.legendTitleColors;\r\n        case property_1.Property.LEGEND_TITLEFONT:\r\n            return opt.legendTitleFonts;\r\n        case property_1.Property.LEGEND_TITLEFONTSIZE:\r\n            return opt.legendTitleFontSizes;\r\n        case property_1.Property.LEGEND_TITLEFONTWEIGHT:\r\n            return opt.legendTitleFontWeights;\r\n        case property_1.Property.SORT:\r\n            return opt.sorts;\r\n        case property_1.Property.SORT_OP:\r\n            return opt.sortOps;\r\n        case property_1.Property.SORT_ORDER:\r\n            return opt.sortOrders;\r\n        case property_1.Property.SCALE_BANDSIZE:\r\n            return opt.scaleBandSizes;\r\n        case property_1.Property.SCALE_DOMAIN:\r\n            return opt.scaleDomains;\r\n        case property_1.Property.SCALE_EXPONENT:\r\n            return opt.scaleExponents;\r\n        case property_1.Property.SCALE_RANGE:\r\n            return opt.scaleRanges;\r\n        case property_1.Property.SCALE_TYPE:\r\n            return opt.scaleTypes;\r\n        case property_1.Property.TIMEUNIT:\r\n            return opt.timeUnits;\r\n        case property_1.Property.TYPE:\r\n            return opt.types;\r\n    }\r\n    /* istanbul ignore next */\r\n    throw new Error('No default enumValues for ' + prop);\r\n}\r\nexports.getDefaultEnumValues = getDefaultEnumValues;\r\n/**\r\n * Internal class for specQuery that provides helper for the enumeration process.\r\n */\r\nvar SpecQueryModel = (function () {\r\n    function SpecQueryModel(spec, enumSpecIndex, schema, opt, enumSpecAssignment) {\r\n        this._rankingScore = {};\r\n        this._spec = spec;\r\n        this._channelCount = spec.encodings.reduce(function (m, encQ) {\r\n            if (!enumspec_1.isEnumSpec(encQ.channel) && encQ.autoCount !== false) {\r\n                m[encQ.channel] = 1;\r\n            }\r\n            return m;\r\n        }, {});\r\n        this._enumSpecIndex = enumSpecIndex;\r\n        this._enumSpecAssignment = enumSpecAssignment;\r\n        this._opt = opt;\r\n        this._schema = schema;\r\n    }\r\n    /**\r\n     * Build an enumSpecIndex by detecting enumeration specifiers\r\n     * in the input specQuery and replace short enum specs with\r\n     * full ones that includes both names and enumValues.\r\n     *\r\n     * @return a SpecQueryModel that wraps the specQuery and the enumSpecIndex.\r\n     */\r\n    SpecQueryModel.build = function (specQ, schema, opt) {\r\n        var enumSpecIndex = new enumspecindex_1.EnumSpecIndex();\r\n        // mark\r\n        if (enumspec_1.isEnumSpec(specQ.mark)) {\r\n            var name_1 = getDefaultName(property_1.Property.MARK);\r\n            specQ.mark = enumspec_1.initEnumSpec(specQ.mark, name_1, opt.marks);\r\n            enumSpecIndex.setMark(specQ.mark);\r\n        }\r\n        // TODO: transform\r\n        // encodings\r\n        specQ.encodings.forEach(function (encQ, index) {\r\n            if (encQ.autoCount !== undefined) {\r\n                // This is only for testing purpose\r\n                console.warn('A field with autoCount should not be included as autoCount meant to be an internal object.');\r\n                encQ.type = type_1.Type.QUANTITATIVE; // autoCount is always quantitative\r\n            }\r\n            if (encQ.type === undefined) {\r\n                // type is optional -- we automatically augment enum spec if not specified\r\n                encQ.type = enumspec_1.SHORT_ENUM_SPEC;\r\n            }\r\n            // For each property of the encodingQuery, enumerate\r\n            property_1.ENCODING_PROPERTIES.forEach(function (prop) {\r\n                if (enumspec_1.isEnumSpec(encQ[prop])) {\r\n                    // Assign default enum spec name and enum values.\r\n                    var defaultEnumSpecName = getDefaultName(prop) + index;\r\n                    var defaultEnumValues = getDefaultEnumValues(prop, schema, opt);\r\n                    var enumSpec = encQ[prop] = enumspec_1.initEnumSpec(encQ[prop], defaultEnumSpecName, defaultEnumValues);\r\n                    // Add index of the encoding mapping to the property's enum spec index.\r\n                    enumSpecIndex.setEncodingProperty(index, prop, enumSpec);\r\n                }\r\n            });\r\n            // For each nested property of the encoding query  (e.g., encQ.bin.maxbins)\r\n            property_1.NESTED_ENCODING_PROPERTIES.forEach(function (nestedProp) {\r\n                var propObj = encQ[nestedProp.parent]; // the property object e.g., encQ.bin\r\n                if (propObj) {\r\n                    var prop = nestedProp.property;\r\n                    var child = nestedProp.child;\r\n                    if (enumspec_1.isEnumSpec(propObj[child])) {\r\n                        // Assign default enum spec name and enum values.\r\n                        var defaultEnumSpecName = getDefaultName(prop) + index;\r\n                        var defaultEnumValues = getDefaultEnumValues(prop, schema, opt);\r\n                        var enumSpec = propObj[child] = enumspec_1.initEnumSpec(propObj[child], defaultEnumSpecName, defaultEnumValues);\r\n                        // Add index of the encoding mapping to the property's enum spec index.\r\n                        enumSpecIndex.setEncodingProperty(index, prop, enumSpec);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        // AUTO COUNT\r\n        // Add Auto Count Field\r\n        if (opt.autoAddCount) {\r\n            var countEncQ = {\r\n                channel: {\r\n                    name: getDefaultName(property_1.Property.CHANNEL) + specQ.encodings.length,\r\n                    enum: getDefaultEnumValues(property_1.Property.CHANNEL, schema, opt)\r\n                },\r\n                autoCount: {\r\n                    name: getDefaultName(property_1.Property.AUTOCOUNT) + specQ.encodings.length,\r\n                    enum: [false, true]\r\n                },\r\n                type: type_1.Type.QUANTITATIVE\r\n            };\r\n            specQ.encodings.push(countEncQ);\r\n            var index = specQ.encodings.length - 1;\r\n            // Add index of the encoding mapping to the property's enum spec index.\r\n            enumSpecIndex.setEncodingProperty(index, property_1.Property.CHANNEL, countEncQ.channel);\r\n            enumSpecIndex.setEncodingProperty(index, property_1.Property.AUTOCOUNT, countEncQ.autoCount);\r\n        }\r\n        return new SpecQueryModel(specQ, enumSpecIndex, schema, opt, {});\r\n    };\r\n    Object.defineProperty(SpecQueryModel.prototype, \"enumSpecIndex\", {\r\n        get: function () {\r\n            return this._enumSpecIndex;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SpecQueryModel.prototype, \"schema\", {\r\n        get: function () {\r\n            return this._schema;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SpecQueryModel.prototype, \"specQuery\", {\r\n        get: function () {\r\n            return this._spec;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SpecQueryModel.prototype.duplicate = function () {\r\n        return new SpecQueryModel(util_1.duplicate(this._spec), this._enumSpecIndex, this._schema, this._opt, util_1.duplicate(this._enumSpecAssignment));\r\n    };\r\n    SpecQueryModel.prototype.setMark = function (mark) {\r\n        var name = this._spec.mark.name;\r\n        this._enumSpecAssignment[name] = this._spec.mark = mark;\r\n    };\r\n    SpecQueryModel.prototype.resetMark = function () {\r\n        var enumSpec = this._spec.mark = this._enumSpecIndex.mark;\r\n        delete this._enumSpecAssignment[enumSpec.name];\r\n    };\r\n    SpecQueryModel.prototype.getMark = function () {\r\n        return this._spec.mark;\r\n    };\r\n    SpecQueryModel.prototype.getEncodingProperty = function (index, prop) {\r\n        var encQ = this._spec.encodings[index];\r\n        var nestedProp = property_1.getNestedEncodingProperty(prop);\r\n        if (nestedProp) {\r\n            return encQ[nestedProp.parent][nestedProp.child];\r\n        }\r\n        return encQ[prop]; // encoding property (non-nested)\r\n    };\r\n    SpecQueryModel.prototype.setEncodingProperty = function (index, prop, value, enumSpec) {\r\n        var encQ = this._spec.encodings[index];\r\n        var nestedProp = property_1.getNestedEncodingProperty(prop);\r\n        if (prop === property_1.Property.CHANNEL && encQ.channel && !enumspec_1.isEnumSpec(encQ.channel)) {\r\n            // If there is an old channel\r\n            this._channelCount[encQ.channel]--;\r\n        }\r\n        if (nestedProp) {\r\n            encQ[nestedProp.parent][nestedProp.child] = value;\r\n        }\r\n        else if (property_1.hasNestedProperty(prop) && value === true) {\r\n            encQ[prop] = util_1.extend({}, encQ[prop], // copy all existing properties\r\n            { enum: undefined, name: undefined } // except name and values to it no longer an enumSpec\r\n            );\r\n        }\r\n        else {\r\n            encQ[prop] = value;\r\n        }\r\n        this._enumSpecAssignment[enumSpec.name] = value;\r\n        if (prop === property_1.Property.CHANNEL) {\r\n            // If there is a new channel, make sure it exists and add it to the count.\r\n            this._channelCount[value] = (this._channelCount[value] || 0) + 1;\r\n        }\r\n    };\r\n    SpecQueryModel.prototype.resetEncodingProperty = function (index, prop, enumSpec) {\r\n        var encQ = this._spec.encodings[index];\r\n        var nestedProp = property_1.getNestedEncodingProperty(prop);\r\n        if (prop === property_1.Property.CHANNEL) {\r\n            this._channelCount[encQ.channel]--;\r\n        }\r\n        // reset it to enumSpec\r\n        if (nestedProp) {\r\n            encQ[nestedProp.parent][nestedProp.child] = enumSpec;\r\n        }\r\n        else {\r\n            encQ[prop] = enumSpec;\r\n        }\r\n        // add remove value that is reset from the assignment map\r\n        delete this._enumSpecAssignment[enumSpec.name];\r\n    };\r\n    SpecQueryModel.prototype.channelUsed = function (channel) {\r\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\r\n        return this._channelCount[channel] > 0;\r\n    };\r\n    SpecQueryModel.prototype.stack = function () {\r\n        return spec_1.stack(this._spec);\r\n    };\r\n    SpecQueryModel.prototype.getEncodings = function () {\r\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\r\n        return this._spec.encodings.filter(function (encQ) { return encQ.autoCount !== false; });\r\n    };\r\n    SpecQueryModel.prototype.getEncodingQueryByChannel = function (channel) {\r\n        for (var i = 0; i < this._spec.encodings.length; i++) {\r\n            if (this._spec.encodings[i].channel === channel) {\r\n                return this._spec.encodings[i];\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    SpecQueryModel.prototype.getEncodingQueryByIndex = function (i) {\r\n        return this._spec.encodings[i];\r\n    };\r\n    SpecQueryModel.prototype.isDimension = function (channel) {\r\n        var encQ = this.getEncodingQueryByChannel(channel);\r\n        return encQ && encoding_1.isDimension(encQ);\r\n    };\r\n    SpecQueryModel.prototype.isMeasure = function (channel) {\r\n        var encQ = this.getEncodingQueryByChannel(channel);\r\n        return encQ && encoding_1.isMeasure(encQ);\r\n    };\r\n    SpecQueryModel.prototype.isAggregate = function () {\r\n        return spec_1.isAggregate(this._spec);\r\n    };\r\n    SpecQueryModel.prototype.toShorthand = function (groupBy) {\r\n        if (groupBy) {\r\n            var include = {}, replace = {};\r\n            groupby_1.parse(groupBy, include, replace);\r\n            return shorthand_1.spec(this._spec, include, shorthand_1.getReplacerIndex(replace));\r\n        }\r\n        return shorthand_1.spec(this._spec);\r\n    };\r\n    SpecQueryModel.prototype._encoding = function () {\r\n        var encoding = {};\r\n        for (var i = 0; i < this._spec.encodings.length; i++) {\r\n            var encQ = this._spec.encodings[i];\r\n            var fieldDef = {};\r\n            // For count field that is automatically added, convert to correct vega-lite fieldDef\r\n            if (encQ.autoCount === true) {\r\n                fieldDef.aggregate = aggregate_1.AggregateOp.COUNT;\r\n                fieldDef.field = '*';\r\n                fieldDef.type = type_1.Type.QUANTITATIVE;\r\n            }\r\n            else if (encQ.autoCount === false) {\r\n                continue; // Do not include this in the output.\r\n            }\r\n            // if channel is an enum spec, return null\r\n            if (enumspec_1.isEnumSpec(encQ.channel))\r\n                return null;\r\n            // assemble other property into a field def.\r\n            var PROPERTIES = [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.FIELD, property_1.Property.TYPE, property_1.Property.SCALE, property_1.Property.SORT, property_1.Property.AXIS, property_1.Property.LEGEND];\r\n            // TODO(#226):\r\n            // write toSpec() and toShorthand() in a way that prevents outputting inapplicable scale, sort, axis / legend\r\n            for (var j = 0; j < PROPERTIES.length; j++) {\r\n                var prop = PROPERTIES[j];\r\n                // if the property is an enum spec, return null\r\n                if (enumspec_1.isEnumSpec(encQ[prop]))\r\n                    return null;\r\n                // otherwise, assign the proper to the field def\r\n                if (encQ[prop] !== undefined) {\r\n                    if (!shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop] ||\r\n                        shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop][encQ.channel]) {\r\n                        fieldDef[prop] = encQ[prop];\r\n                    }\r\n                }\r\n            }\r\n            if (fieldDef.bin === false) {\r\n                // exclude bin false\r\n                delete fieldDef.bin;\r\n            }\r\n            encoding[encQ.channel] = fieldDef;\r\n        }\r\n        return encoding;\r\n    };\r\n    /**\r\n     * Convert a query to a Vega-Lite spec if it is completed.\r\n     * @return a Vega-Lite spec if completed, null otherwise.\r\n     */\r\n    SpecQueryModel.prototype.toSpec = function (data) {\r\n        if (enumspec_1.isEnumSpec(this._spec.mark))\r\n            return null;\r\n        var spec = {};\r\n        data = data || this._spec.data;\r\n        if (data) {\r\n            spec.data = data;\r\n        }\r\n        if (this._spec.transform) {\r\n            spec.transform = this._spec.transform;\r\n        }\r\n        spec.mark = this._spec.mark;\r\n        spec.encoding = this._encoding();\r\n        if (spec.encoding === null) {\r\n            return null;\r\n        }\r\n        if (this._spec.config || this._opt.defaultSpecConfig)\r\n            spec.config = util_1.extend({}, this._opt.defaultSpecConfig, this._spec.config);\r\n        return spec;\r\n    };\r\n    SpecQueryModel.prototype.getRankingScore = function (rankingName) {\r\n        return this._rankingScore[rankingName];\r\n    };\r\n    SpecQueryModel.prototype.setRankingScore = function (rankingName, score) {\r\n        this._rankingScore[rankingName] = score;\r\n    };\r\n    return SpecQueryModel;\r\n}());\r\nexports.SpecQueryModel = SpecQueryModel;\r\nvar SpecQueryModelGroup = (function () {\r\n    function SpecQueryModelGroup(name, path, items, groupBy, orderGroupBy) {\r\n        if (name === void 0) { name = ''; }\r\n        if (path === void 0) { path = ''; }\r\n        if (items === void 0) { items = []; }\r\n        if (groupBy === void 0) { groupBy = undefined; }\r\n        if (orderGroupBy === void 0) { orderGroupBy = undefined; }\r\n        this._name = name;\r\n        this._path = path;\r\n        this._items = items;\r\n        this._groupBy = groupBy;\r\n        this._orderGroupBy = orderGroupBy;\r\n    }\r\n    SpecQueryModelGroup.prototype.getTopSpecQueryModel = function () {\r\n        var topItem = this._items[0];\r\n        if (topItem instanceof SpecQueryModelGroup) {\r\n            return topItem.getTopSpecQueryModel();\r\n        }\r\n        else {\r\n            return topItem;\r\n        }\r\n    };\r\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"name\", {\r\n        get: function () {\r\n            return this._name;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"items\", {\r\n        get: function () {\r\n            return this._items;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"groupBy\", {\r\n        get: function () {\r\n            return this._groupBy;\r\n        },\r\n        set: function (groupBy) {\r\n            this._groupBy = groupBy;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"orderGroupBy\", {\r\n        get: function () {\r\n            return this._orderGroupBy;\r\n        },\r\n        set: function (orderGroupBy) {\r\n            this._orderGroupBy = orderGroupBy;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return SpecQueryModelGroup;\r\n}());\r\nexports.SpecQueryModelGroup = SpecQueryModelGroup;\r\n//# sourceMappingURL=model.js.map",
    "\"use strict\";\r\nvar channel_1 = require('vega-lite/src/channel');\r\nvar util_1 = require('datalib/src/util');\r\nvar enumspec_1 = require('./enumspec');\r\nvar model_1 = require('./model');\r\nvar util_2 = require('./util');\r\nvar groupby_1 = require('./query/groupby');\r\nvar shorthand_1 = require('./query/shorthand');\r\nvar spec_1 = require('./query/spec');\r\n/**\r\n * Registry for all possible grouping key functions.\r\n */\r\nvar groupRegistry = {};\r\n/**\r\n * Add a grouping function to the registry.\r\n */\r\nfunction registerKeyFn(name, keyFn) {\r\n    groupRegistry[name] = keyFn;\r\n}\r\nexports.registerKeyFn = registerKeyFn;\r\nexports.FIELD = 'field';\r\nexports.FIELD_TRANSFORM = 'fieldTransform';\r\nexports.ENCODING = 'encoding';\r\nexports.TRANSPOSE = 'transpose';\r\nexports.SPEC = 'spec';\r\n/**\r\n * Group the input spec query model by a key function registered in the group registry\r\n * @return\r\n */\r\nfunction nest(specModels, query) {\r\n    if (query.nest) {\r\n        var rootGroup_1 = new model_1.SpecQueryModelGroup();\r\n        var groupIndex_1 = {};\r\n        // global `includes` and `replaces` will get augmented by each level's groupBy.\r\n        // Upper level's `groupBy` will get cascaded to lower-level groupBy.\r\n        // `replace` can be overriden in a lower-level to support different grouping.\r\n        var includes_1 = [];\r\n        var replaces = [];\r\n        var replacers_1 = [];\r\n        for (var l = 0; l < query.nest.length; l++) {\r\n            includes_1.push(l > 0 ? util_2.duplicate(includes_1[l - 1]) : {});\r\n            replaces.push(l > 0 ? util_2.duplicate(replaces[l - 1]) : {});\r\n            var groupBy = query.nest[l].groupBy;\r\n            if (util_1.isArray(groupBy)) {\r\n                groupby_1.parse(groupBy, includes_1[l], replaces[l]);\r\n                replacers_1.push(shorthand_1.getReplacerIndex(replaces[l]));\r\n            }\r\n        }\r\n        // With includes and replacers, now we can construct the nesting tree\r\n        specModels.forEach(function (specM) {\r\n            var path = '';\r\n            var group = rootGroup_1;\r\n            for (var l = 0; l < query.nest.length; l++) {\r\n                var groupBy = group.groupBy = query.nest[l].groupBy;\r\n                group.orderGroupBy = query.nest[l].orderGroupBy;\r\n                var key = util_1.isArray(groupBy) ?\r\n                    shorthand_1.spec(specM.specQuery, includes_1[l], replacers_1[l]) :\r\n                    groupRegistry[groupBy](specM);\r\n                path += '/' + key;\r\n                if (!groupIndex_1[path]) {\r\n                    groupIndex_1[path] = new model_1.SpecQueryModelGroup(key, path, []);\r\n                    group.items.push(groupIndex_1[path]);\r\n                }\r\n                group = groupIndex_1[path];\r\n            }\r\n            group.items.push(specM);\r\n        });\r\n        return rootGroup_1;\r\n    }\r\n    else {\r\n        // no nesting, just return a flat group\r\n        return new model_1.SpecQueryModelGroup('', '', specModels);\r\n    }\r\n}\r\nexports.nest = nest;\r\nregisterKeyFn(exports.FIELD, function (specM) {\r\n    return specM.getEncodings().map(function (encQ) { return encQ.field; })\r\n        .filter(function (field) { return field && field !== '*'; })\r\n        .sort()\r\n        .join('|');\r\n});\r\nregisterKeyFn(exports.FIELD_TRANSFORM, function (specM) {\r\n    return specM.getEncodings().map(function (encQ) { return shorthand_1.fieldDef(encQ); })\r\n        .sort()\r\n        .join('|');\r\n});\r\nfunction channelType(channel) {\r\n    if (enumspec_1.isEnumSpec(channel)) {\r\n        return enumspec_1.SHORT_ENUM_SPEC + '';\r\n    }\r\n    var c = channel;\r\n    switch (c) {\r\n        case channel_1.Channel.X:\r\n        case channel_1.Channel.Y:\r\n            return 'xy';\r\n        case channel_1.Channel.ROW:\r\n        case channel_1.Channel.COLUMN:\r\n            return 'facet';\r\n        case channel_1.Channel.COLOR:\r\n        case channel_1.Channel.SIZE:\r\n        case channel_1.Channel.SHAPE:\r\n        case channel_1.Channel.OPACITY:\r\n            return 'non-xy';\r\n        case channel_1.Channel.TEXT:\r\n        case channel_1.Channel.DETAIL:\r\n        case channel_1.Channel.PATH:\r\n        case channel_1.Channel.ORDER:\r\n            return c + '';\r\n        /* istanbul ignore next */\r\n        default:\r\n            console.warn('channel type not implemented for ' + c);\r\n            return c + '';\r\n    }\r\n}\r\nfunction stringifyStack(specM) {\r\n    var _stack = spec_1.stack(specM.specQuery);\r\n    return (!!_stack ? 'stack=' + _stack.offset + '|' : '');\r\n}\r\nregisterKeyFn(exports.ENCODING, function (specM) {\r\n    // mark does not matter\r\n    return stringifyStack(specM) +\r\n        specM.getEncodings().map(function (encQ) {\r\n            var fieldDef = shorthand_1.fieldDef(encQ);\r\n            return channelType(encQ.channel) + ':' + fieldDef;\r\n        })\r\n            .sort()\r\n            .join('|');\r\n});\r\nregisterKeyFn(exports.TRANSPOSE, function (specM) {\r\n    return specM.getMark() + '|' +\r\n        stringifyStack(specM) +\r\n        specM.getEncodings().map(function (encQ) {\r\n            var fieldDef = shorthand_1.fieldDef(encQ);\r\n            var channel = (encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) ? 'xy' :\r\n                (encQ.channel === channel_1.Channel.ROW || encQ.channel === channel_1.Channel.COLUMN) ? 'facet' :\r\n                    encQ.channel;\r\n            return channel + ':' + fieldDef;\r\n        })\r\n            .sort()\r\n            .join('|');\r\n});\r\nregisterKeyFn(exports.SPEC, function (specM) { return JSON.stringify(specM.specQuery); });\r\n//# sourceMappingURL=nest.js.map",
    "\"use strict\";\r\nvar scale_1 = require('vega-lite/src/scale');\r\n(function (Property) {\r\n    Property[Property[\"MARK\"] = 'mark'] = \"MARK\";\r\n    Property[Property[\"FILTER\"] = 'filter'] = \"FILTER\";\r\n    // TODO: Sub-properties for filter\r\n    Property[Property[\"CALCULATE\"] = 'calculate'] = \"CALCULATE\";\r\n    // TODO: Sub-properties for calculate\r\n    Property[Property[\"FILTERINVALID\"] = 'filterInvalid'] = \"FILTERINVALID\";\r\n    // Layout\r\n    Property[Property[\"STACK\"] = 'stack'] = \"STACK\";\r\n    // TODO: sub parts of stack\r\n    // Encoding Properties\r\n    Property[Property[\"CHANNEL\"] = 'channel'] = \"CHANNEL\";\r\n    Property[Property[\"AGGREGATE\"] = 'aggregate'] = \"AGGREGATE\";\r\n    Property[Property[\"AUTOCOUNT\"] = 'autoCount'] = \"AUTOCOUNT\";\r\n    Property[Property[\"BIN\"] = 'bin'] = \"BIN\";\r\n    Property[Property[\"BIN_MAXBINS\"] = 'binMaxBins'] = \"BIN_MAXBINS\";\r\n    Property[Property[\"HAS_FN\"] = 'hasFn'] = \"HAS_FN\";\r\n    Property[Property[\"TIMEUNIT\"] = 'timeUnit'] = \"TIMEUNIT\";\r\n    Property[Property[\"FIELD\"] = 'field'] = \"FIELD\";\r\n    Property[Property[\"TYPE\"] = 'type'] = \"TYPE\";\r\n    // - Sort\r\n    Property[Property[\"SORT\"] = 'sort'] = \"SORT\";\r\n    Property[Property[\"SORT_FIELD\"] = 'sortField'] = \"SORT_FIELD\";\r\n    Property[Property[\"SORT_OP\"] = 'sortOp'] = \"SORT_OP\";\r\n    Property[Property[\"SORT_ORDER\"] = 'sortOrder'] = \"SORT_ORDER\";\r\n    // - Scale\r\n    Property[Property[\"SCALE\"] = 'scale'] = \"SCALE\";\r\n    Property[Property[\"SCALE_BANDSIZE\"] = 'scaleBandSize'] = \"SCALE_BANDSIZE\";\r\n    Property[Property[\"SCALE_CLAMP\"] = 'scaleClamp'] = \"SCALE_CLAMP\";\r\n    Property[Property[\"SCALE_DOMAIN\"] = 'scaleDomain'] = \"SCALE_DOMAIN\";\r\n    Property[Property[\"SCALE_EXPONENT\"] = 'scaleExponent'] = \"SCALE_EXPONENT\";\r\n    Property[Property[\"SCALE_NICE\"] = 'scaleNice'] = \"SCALE_NICE\";\r\n    Property[Property[\"SCALE_RANGE\"] = 'scaleRange'] = \"SCALE_RANGE\";\r\n    Property[Property[\"SCALE_ROUND\"] = 'scaleRound'] = \"SCALE_ROUND\";\r\n    Property[Property[\"SCALE_TYPE\"] = 'scaleType'] = \"SCALE_TYPE\";\r\n    Property[Property[\"SCALE_USERAWDOMAIN\"] = 'scaleUseRawDomain'] = \"SCALE_USERAWDOMAIN\";\r\n    Property[Property[\"SCALE_ZERO\"] = 'scaleZero'] = \"SCALE_ZERO\";\r\n    // - Axis\r\n    Property[Property[\"AXIS\"] = 'axis'] = \"AXIS\";\r\n    // General Axis Properties\r\n    Property[Property[\"AXIS_AXISCOLOR\"] = 'axisAxisColor'] = \"AXIS_AXISCOLOR\";\r\n    Property[Property[\"AXIS_AXISWIDTH\"] = 'axisAxisWidth'] = \"AXIS_AXISWIDTH\";\r\n    Property[Property[\"AXIS_LAYER\"] = 'axisLayer'] = \"AXIS_LAYER\";\r\n    Property[Property[\"AXIS_OFFSET\"] = 'axisOffset'] = \"AXIS_OFFSET\";\r\n    Property[Property[\"AXIS_ORIENT\"] = 'axisOrient'] = \"AXIS_ORIENT\";\r\n    // Axis_Grid Properties\r\n    Property[Property[\"AXIS_GRID\"] = 'axisGrid'] = \"AXIS_GRID\";\r\n    Property[Property[\"AXIS_GRIDCOLOR\"] = 'axisGridColor'] = \"AXIS_GRIDCOLOR\";\r\n    Property[Property[\"AXIS_GRIDDASH\"] = 'axisGridDash'] = \"AXIS_GRIDDASH\";\r\n    Property[Property[\"AXIS_GRIDOPACITY\"] = 'axisGridOpacity'] = \"AXIS_GRIDOPACITY\";\r\n    Property[Property[\"AXIS_GRIDWIDTH\"] = 'axisGridWidth'] = \"AXIS_GRIDWIDTH\";\r\n    // Axis Properties\r\n    Property[Property[\"AXIS_LABELS\"] = 'axisLabels'] = \"AXIS_LABELS\";\r\n    Property[Property[\"AXIS_FORMAT\"] = 'axisFormat'] = \"AXIS_FORMAT\";\r\n    Property[Property[\"AXIS_LABELANGLE\"] = 'axisLabelAngle'] = \"AXIS_LABELANGLE\";\r\n    Property[Property[\"AXIS_LABELMAXLENGTH\"] = 'axisLabelMaxLength'] = \"AXIS_LABELMAXLENGTH\";\r\n    Property[Property[\"AXIS_SHORTTIMELABELS\"] = 'axisShortTimeLabels'] = \"AXIS_SHORTTIMELABELS\";\r\n    // Axis_Tick Properties\r\n    Property[Property[\"AXIS_SUBDIVIDE\"] = 'axisSubdivide'] = \"AXIS_SUBDIVIDE\";\r\n    Property[Property[\"AXIS_TICKS\"] = 'axisTicks'] = \"AXIS_TICKS\";\r\n    Property[Property[\"AXIS_TICKCOLOR\"] = 'axisTickColor'] = \"AXIS_TICKCOLOR\";\r\n    Property[Property[\"AXIS_TICKLABELCOLOR\"] = 'axisTickLabelColor'] = \"AXIS_TICKLABELCOLOR\";\r\n    Property[Property[\"AXIS_TICKLABELFONT\"] = 'axisTickLabelFont'] = \"AXIS_TICKLABELFONT\";\r\n    Property[Property[\"AXIS_TICKLABELFONTSIZE\"] = 'axisTickLabelFontSize'] = \"AXIS_TICKLABELFONTSIZE\";\r\n    Property[Property[\"AXIS_TICKPADDING\"] = 'axisTickPadding'] = \"AXIS_TICKPADDING\";\r\n    Property[Property[\"AXIS_TICKSIZE\"] = 'axisTickSize'] = \"AXIS_TICKSIZE\";\r\n    Property[Property[\"AXIS_TICKSIZEMAJOR\"] = 'axisTickSizeMajor'] = \"AXIS_TICKSIZEMAJOR\";\r\n    Property[Property[\"AXIS_TICKSIZEMINOR\"] = 'axisTickSizeMinor'] = \"AXIS_TICKSIZEMINOR\";\r\n    Property[Property[\"AXIS_TICKSIZEEND\"] = 'axisTickSizeEnd'] = \"AXIS_TICKSIZEEND\";\r\n    Property[Property[\"AXIS_TICKWIDTH\"] = 'axisTickWidth'] = \"AXIS_TICKWIDTH\";\r\n    Property[Property[\"AXIS_VALUES\"] = 'axisValues'] = \"AXIS_VALUES\";\r\n    // Axis_Title Properties\r\n    Property[Property[\"AXIS_TITLE\"] = 'axisTitle'] = \"AXIS_TITLE\";\r\n    Property[Property[\"AXIS_TITLECOLOR\"] = 'axisTitleColor'] = \"AXIS_TITLECOLOR\";\r\n    Property[Property[\"AXIS_TITLEFONT\"] = 'axisTitleFont'] = \"AXIS_TITLEFONT\";\r\n    Property[Property[\"AXIS_TITLEFONTSIZE\"] = 'axisTitleFontSize'] = \"AXIS_TITLEFONTSIZE\";\r\n    Property[Property[\"AXIS_TITLEFONTWEIGHT\"] = 'axisTitleFontWeight'] = \"AXIS_TITLEFONTWEIGHT\";\r\n    Property[Property[\"AXIS_TITLEOFFSET\"] = 'axisTitleOffset'] = \"AXIS_TITLEOFFSET\";\r\n    Property[Property[\"AXIS_TITLEMAXLENGTH\"] = 'axisTitleMaxLength'] = \"AXIS_TITLEMAXLENGTH\";\r\n    Property[Property[\"AXIS_CHARACTERWIDTH\"] = 'axisCharacterWidth'] = \"AXIS_CHARACTERWIDTH\";\r\n    // - Legend\r\n    Property[Property[\"LEGEND\"] = 'legend'] = \"LEGEND\";\r\n    // General Legend Properties\r\n    Property[Property[\"LEGEND_ORIENT\"] = 'legendOrient'] = \"LEGEND_ORIENT\";\r\n    Property[Property[\"LEGEND_OFFSET\"] = 'legendOffset'] = \"LEGEND_OFFSET\";\r\n    Property[Property[\"LEGEND_VALUES\"] = 'legendValues'] = \"LEGEND_VALUES\";\r\n    // Legend_Label Properties\r\n    Property[Property[\"LEGEND_FORMAT\"] = 'legendFormat'] = \"LEGEND_FORMAT\";\r\n    Property[Property[\"LEGEND_LABELALIGN\"] = 'legendLabelAlign'] = \"LEGEND_LABELALIGN\";\r\n    Property[Property[\"LEGEND_LABELBASELINE\"] = 'legendLabelBaseline'] = \"LEGEND_LABELBASELINE\";\r\n    Property[Property[\"LEGEND_LABELCOLOR\"] = 'legendLabelColor'] = \"LEGEND_LABELCOLOR\";\r\n    Property[Property[\"LEGEND_LABELFONT\"] = 'legendLabelFont'] = \"LEGEND_LABELFONT\";\r\n    Property[Property[\"LEGEND_LABELFONTSIZE\"] = 'legendLabelFontSize'] = \"LEGEND_LABELFONTSIZE\";\r\n    Property[Property[\"LEGEND_SHORTTIMELABELS\"] = 'legendShortTimeLabels'] = \"LEGEND_SHORTTIMELABELS\";\r\n    // Legend_Symbol Properties\r\n    Property[Property[\"LEGEND_SYMBOLCOLOR\"] = 'legendSymbolColor'] = \"LEGEND_SYMBOLCOLOR\";\r\n    Property[Property[\"LEGEND_SYMBOLSHAPE\"] = 'legendSymbolShape'] = \"LEGEND_SYMBOLSHAPE\";\r\n    Property[Property[\"LEGEND_SYMBOLSIZE\"] = 'legendSymbolSize'] = \"LEGEND_SYMBOLSIZE\";\r\n    Property[Property[\"LEGEND_SYMBOLSTROKEWIDTH\"] = 'legendSymbolStrokeWidth'] = \"LEGEND_SYMBOLSTROKEWIDTH\";\r\n    // Legend_Title Properties\r\n    Property[Property[\"LEGEND_TITLE\"] = 'legendTitle'] = \"LEGEND_TITLE\";\r\n    Property[Property[\"LEGEND_TITLECOLOR\"] = 'legendTitleColor'] = \"LEGEND_TITLECOLOR\";\r\n    Property[Property[\"LEGEND_TITLEFONT\"] = 'legendTitleFont'] = \"LEGEND_TITLEFONT\";\r\n    Property[Property[\"LEGEND_TITLEFONTSIZE\"] = 'legendTitleFontSize'] = \"LEGEND_TITLEFONTSIZE\";\r\n    Property[Property[\"LEGEND_TITLEFONTWEIGHT\"] = 'legendTitleFontWeight'] = \"LEGEND_TITLEFONTWEIGHT\";\r\n})(exports.Property || (exports.Property = {}));\r\nvar Property = exports.Property;\r\nfunction hasNestedProperty(prop) {\r\n    switch (prop) {\r\n        case Property.BIN:\r\n        case Property.SCALE:\r\n        case Property.SORT:\r\n        case Property.AXIS:\r\n        case Property.LEGEND:\r\n            return true;\r\n        case Property.MARK:\r\n        case Property.FILTER:\r\n        case Property.CALCULATE:\r\n        case Property.FILTERINVALID:\r\n        case Property.STACK:\r\n        case Property.CHANNEL:\r\n        case Property.AGGREGATE:\r\n        case Property.AUTOCOUNT:\r\n        case Property.TIMEUNIT:\r\n        case Property.FIELD:\r\n        case Property.TYPE:\r\n        case Property.BIN_MAXBINS:\r\n        case Property.SCALE_BANDSIZE:\r\n        case Property.SCALE_CLAMP:\r\n        case Property.SCALE_DOMAIN:\r\n        case Property.SCALE_EXPONENT:\r\n        case Property.SCALE_NICE:\r\n        case Property.SCALE_RANGE:\r\n        case Property.SCALE_ROUND:\r\n        case Property.SCALE_TYPE:\r\n        case Property.SCALE_USERAWDOMAIN:\r\n        case Property.SCALE_ZERO:\r\n        case Property.AXIS_AXISCOLOR:\r\n        case Property.AXIS_AXISWIDTH:\r\n        case Property.AXIS_LAYER:\r\n        case Property.AXIS_OFFSET:\r\n        case Property.AXIS_ORIENT:\r\n        case Property.AXIS_GRID:\r\n        case Property.AXIS_GRIDCOLOR:\r\n        case Property.AXIS_GRIDDASH:\r\n        case Property.AXIS_GRIDOPACITY:\r\n        case Property.AXIS_GRIDWIDTH:\r\n        case Property.AXIS_LABELS:\r\n        case Property.AXIS_FORMAT:\r\n        case Property.AXIS_LABELANGLE:\r\n        case Property.AXIS_LABELMAXLENGTH:\r\n        case Property.AXIS_SHORTTIMELABELS:\r\n        case Property.AXIS_TICKS:\r\n        case Property.AXIS_SUBDIVIDE:\r\n        case Property.AXIS_TICKCOLOR:\r\n        case Property.AXIS_TICKLABELCOLOR:\r\n        case Property.AXIS_TICKLABELFONT:\r\n        case Property.AXIS_TICKLABELFONTSIZE:\r\n        case Property.AXIS_TICKPADDING:\r\n        case Property.AXIS_TICKSIZE:\r\n        case Property.AXIS_TICKSIZEMAJOR:\r\n        case Property.AXIS_TICKSIZEMINOR:\r\n        case Property.AXIS_TICKSIZEEND:\r\n        case Property.AXIS_TICKWIDTH:\r\n        case Property.AXIS_VALUES:\r\n        case Property.AXIS_TITLE:\r\n        case Property.AXIS_TITLECOLOR:\r\n        case Property.AXIS_TITLEFONT:\r\n        case Property.AXIS_TITLEFONTSIZE:\r\n        case Property.AXIS_TITLEFONTWEIGHT:\r\n        case Property.AXIS_CHARACTERWIDTH:\r\n        case Property.AXIS_TITLEMAXLENGTH:\r\n        case Property.AXIS_TITLEOFFSET:\r\n        case Property.LEGEND_ORIENT:\r\n        case Property.LEGEND_OFFSET:\r\n        case Property.LEGEND_VALUES:\r\n        case Property.LEGEND_FORMAT:\r\n        case Property.LEGEND_LABELALIGN:\r\n        case Property.LEGEND_LABELBASELINE:\r\n        case Property.LEGEND_LABELCOLOR:\r\n        case Property.LEGEND_LABELFONT:\r\n        case Property.LEGEND_LABELFONTSIZE:\r\n        case Property.LEGEND_SHORTTIMELABELS:\r\n        case Property.LEGEND_SYMBOLCOLOR:\r\n        case Property.LEGEND_SYMBOLSHAPE:\r\n        case Property.LEGEND_SYMBOLSIZE:\r\n        case Property.LEGEND_SYMBOLSTROKEWIDTH:\r\n        case Property.LEGEND_TITLE:\r\n        case Property.LEGEND_TITLECOLOR:\r\n        case Property.LEGEND_TITLEFONT:\r\n        case Property.LEGEND_TITLEFONTSIZE:\r\n        case Property.LEGEND_TITLEFONTWEIGHT:\r\n            return false;\r\n    }\r\n    /* istanbul ignore next */\r\n    throw new Error('hasNestedProperty undefined for property ' + prop);\r\n}\r\nexports.hasNestedProperty = hasNestedProperty;\r\nexports.ENCODING_PROPERTIES = [\r\n    Property.CHANNEL,\r\n    Property.BIN,\r\n    Property.BIN_MAXBINS,\r\n    Property.TIMEUNIT,\r\n    Property.AGGREGATE,\r\n    Property.AUTOCOUNT,\r\n    Property.FIELD,\r\n    Property.TYPE,\r\n    Property.SORT,\r\n    Property.SORT_FIELD,\r\n    Property.SORT_OP,\r\n    Property.SORT_ORDER,\r\n    Property.SCALE,\r\n    Property.SCALE_BANDSIZE,\r\n    Property.SCALE_CLAMP,\r\n    Property.SCALE_DOMAIN,\r\n    Property.SCALE_EXPONENT,\r\n    Property.SCALE_NICE,\r\n    Property.SCALE_RANGE,\r\n    Property.SCALE_ROUND,\r\n    Property.SCALE_TYPE,\r\n    Property.SCALE_USERAWDOMAIN,\r\n    Property.SCALE_ZERO,\r\n    Property.AXIS,\r\n    Property.AXIS_AXISCOLOR,\r\n    Property.AXIS_AXISWIDTH,\r\n    Property.AXIS_CHARACTERWIDTH,\r\n    Property.AXIS_FORMAT,\r\n    Property.AXIS_GRID,\r\n    Property.AXIS_GRIDCOLOR,\r\n    Property.AXIS_GRIDDASH,\r\n    Property.AXIS_GRIDOPACITY,\r\n    Property.AXIS_GRIDWIDTH,\r\n    Property.AXIS_LABELANGLE,\r\n    Property.AXIS_LABELMAXLENGTH,\r\n    Property.AXIS_LABELS,\r\n    Property.AXIS_LAYER,\r\n    Property.AXIS_OFFSET,\r\n    Property.AXIS_ORIENT,\r\n    Property.AXIS_SHORTTIMELABELS,\r\n    Property.AXIS_SUBDIVIDE,\r\n    Property.AXIS_TICKCOLOR,\r\n    Property.AXIS_TICKLABELCOLOR,\r\n    Property.AXIS_TICKLABELFONT,\r\n    Property.AXIS_TICKLABELFONTSIZE,\r\n    Property.AXIS_TICKPADDING,\r\n    Property.AXIS_TICKS,\r\n    Property.AXIS_TICKSIZE,\r\n    Property.AXIS_TICKSIZEEND,\r\n    Property.AXIS_TICKSIZEMAJOR,\r\n    Property.AXIS_TICKSIZEMINOR,\r\n    Property.AXIS_TICKWIDTH,\r\n    Property.AXIS_TITLE,\r\n    Property.AXIS_TITLECOLOR,\r\n    Property.AXIS_TITLEFONT,\r\n    Property.AXIS_TITLEFONTSIZE,\r\n    Property.AXIS_TITLEFONTWEIGHT,\r\n    Property.AXIS_TITLEMAXLENGTH,\r\n    Property.AXIS_TITLEOFFSET,\r\n    Property.AXIS_VALUES,\r\n    Property.LEGEND,\r\n    Property.LEGEND_ORIENT,\r\n    Property.LEGEND_OFFSET,\r\n    Property.LEGEND_VALUES,\r\n    Property.LEGEND_FORMAT,\r\n    Property.LEGEND_LABELALIGN,\r\n    Property.LEGEND_LABELBASELINE,\r\n    Property.LEGEND_LABELCOLOR,\r\n    Property.LEGEND_LABELFONT,\r\n    Property.LEGEND_LABELFONTSIZE,\r\n    Property.LEGEND_SHORTTIMELABELS,\r\n    Property.LEGEND_SYMBOLCOLOR,\r\n    Property.LEGEND_SYMBOLSHAPE,\r\n    Property.LEGEND_SYMBOLSIZE,\r\n    Property.LEGEND_SYMBOLSTROKEWIDTH,\r\n    Property.LEGEND_TITLE,\r\n    Property.LEGEND_TITLECOLOR,\r\n    Property.LEGEND_TITLEFONT,\r\n    Property.LEGEND_TITLEFONTSIZE,\r\n    Property.LEGEND_TITLEFONTWEIGHT\r\n];\r\nexports.DEFAULT_PROPERTY_PRECEDENCE = [\r\n    // Projection\r\n    Property.TYPE,\r\n    Property.FIELD,\r\n    // TODO: Add stack and remove it from INCLUDE_ALL in shorthand\r\n    // TODO: Add filter and remove it from INCLUDE_ALL in shorthand\r\n    // TODO: Add calculate and remove it from INCLUDE_ALL in shorthand\r\n    // TODO: Add filterInvalid and remove it from INCLUDE_ALL in shorthand\r\n    // Field Transform\r\n    Property.BIN,\r\n    Property.TIMEUNIT,\r\n    Property.AGGREGATE,\r\n    Property.AUTOCOUNT,\r\n    Property.SORT,\r\n    Property.SORT_FIELD,\r\n    Property.SORT_OP,\r\n    Property.SORT_ORDER,\r\n    // Nested Transform Property\r\n    Property.BIN_MAXBINS,\r\n    // Encoding\r\n    Property.CHANNEL,\r\n    Property.MARK,\r\n    Property.SCALE,\r\n    Property.AXIS,\r\n    Property.LEGEND,\r\n    // Nested Encoding Property\r\n    // - Scale\r\n    Property.SCALE_BANDSIZE,\r\n    Property.SCALE_CLAMP,\r\n    Property.SCALE_DOMAIN,\r\n    Property.SCALE_EXPONENT,\r\n    Property.SCALE_NICE,\r\n    Property.SCALE_RANGE,\r\n    Property.SCALE_ROUND,\r\n    Property.SCALE_TYPE,\r\n    Property.SCALE_USERAWDOMAIN,\r\n    Property.SCALE_ZERO,\r\n    // - Axis\r\n    Property.AXIS_AXISCOLOR,\r\n    Property.AXIS_AXISWIDTH,\r\n    Property.AXIS_CHARACTERWIDTH,\r\n    Property.AXIS_FORMAT,\r\n    Property.AXIS_GRID,\r\n    Property.AXIS_GRIDCOLOR,\r\n    Property.AXIS_GRIDDASH,\r\n    Property.AXIS_GRIDOPACITY,\r\n    Property.AXIS_GRIDWIDTH,\r\n    Property.AXIS_LABELANGLE,\r\n    Property.AXIS_LABELMAXLENGTH,\r\n    Property.AXIS_LABELS,\r\n    Property.AXIS_LAYER,\r\n    Property.AXIS_OFFSET,\r\n    Property.AXIS_ORIENT,\r\n    Property.AXIS_SHORTTIMELABELS,\r\n    Property.AXIS_SUBDIVIDE,\r\n    Property.AXIS_TICKCOLOR,\r\n    Property.AXIS_TICKLABELCOLOR,\r\n    Property.AXIS_TICKLABELFONT,\r\n    Property.AXIS_TICKLABELFONTSIZE,\r\n    Property.AXIS_TICKPADDING,\r\n    Property.AXIS_TICKS,\r\n    Property.AXIS_TICKSIZE,\r\n    Property.AXIS_TICKSIZEEND,\r\n    Property.AXIS_TICKSIZEMAJOR,\r\n    Property.AXIS_TICKSIZEMINOR,\r\n    Property.AXIS_TICKWIDTH,\r\n    Property.AXIS_TITLE,\r\n    Property.AXIS_TITLECOLOR,\r\n    Property.AXIS_TITLEFONT,\r\n    Property.AXIS_TITLEFONTSIZE,\r\n    Property.AXIS_TITLEFONTWEIGHT,\r\n    Property.AXIS_TITLEMAXLENGTH,\r\n    Property.AXIS_TITLEOFFSET,\r\n    Property.AXIS_VALUES,\r\n    // - Legend\r\n    Property.LEGEND_ORIENT,\r\n    Property.LEGEND_OFFSET,\r\n    Property.LEGEND_VALUES,\r\n    Property.LEGEND_FORMAT,\r\n    Property.LEGEND_LABELALIGN,\r\n    Property.LEGEND_LABELBASELINE,\r\n    Property.LEGEND_LABELCOLOR,\r\n    Property.LEGEND_LABELFONT,\r\n    Property.LEGEND_LABELFONTSIZE,\r\n    Property.LEGEND_SHORTTIMELABELS,\r\n    Property.LEGEND_SYMBOLCOLOR,\r\n    Property.LEGEND_SYMBOLSHAPE,\r\n    Property.LEGEND_SYMBOLSIZE,\r\n    Property.LEGEND_SYMBOLSTROKEWIDTH,\r\n    Property.LEGEND_TITLE,\r\n    Property.LEGEND_TITLECOLOR,\r\n    Property.LEGEND_TITLEFONT,\r\n    Property.LEGEND_TITLEFONTSIZE,\r\n    Property.LEGEND_TITLEFONTWEIGHT\r\n];\r\nexports.NESTED_ENCODING_PROPERTIES = [\r\n    {\r\n        property: Property.BIN_MAXBINS,\r\n        parent: 'bin',\r\n        child: 'maxbins'\r\n    },\r\n    {\r\n        property: Property.SORT_FIELD,\r\n        parent: 'sort',\r\n        child: 'field'\r\n    },\r\n    {\r\n        property: Property.SORT_OP,\r\n        parent: 'sort',\r\n        child: 'op'\r\n    },\r\n    {\r\n        property: Property.SORT_ORDER,\r\n        parent: 'sort',\r\n        child: 'order'\r\n    },\r\n    {\r\n        property: Property.SCALE_BANDSIZE,\r\n        parent: 'scale',\r\n        child: 'bandSize'\r\n    },\r\n    {\r\n        property: Property.SCALE_CLAMP,\r\n        parent: 'scale',\r\n        child: 'clamp'\r\n    },\r\n    {\r\n        property: Property.SCALE_DOMAIN,\r\n        parent: 'scale',\r\n        child: 'domain'\r\n    },\r\n    {\r\n        property: Property.SCALE_EXPONENT,\r\n        parent: 'scale',\r\n        child: 'exponent'\r\n    },\r\n    {\r\n        property: Property.SCALE_NICE,\r\n        parent: 'scale',\r\n        child: 'nice'\r\n    },\r\n    {\r\n        property: Property.SCALE_RANGE,\r\n        parent: 'scale',\r\n        child: 'range'\r\n    },\r\n    {\r\n        property: Property.SCALE_ROUND,\r\n        parent: 'scale',\r\n        child: 'round'\r\n    },\r\n    {\r\n        property: Property.SCALE_TYPE,\r\n        parent: 'scale',\r\n        child: 'type'\r\n    },\r\n    {\r\n        property: Property.SCALE_USERAWDOMAIN,\r\n        parent: 'scale',\r\n        child: 'useRawDomain'\r\n    },\r\n    {\r\n        property: Property.SCALE_ZERO,\r\n        parent: 'scale',\r\n        child: 'zero'\r\n    },\r\n    {\r\n        property: Property.AXIS_AXISCOLOR,\r\n        parent: 'axis',\r\n        child: 'axisColor'\r\n    },\r\n    {\r\n        property: Property.AXIS_AXISWIDTH,\r\n        parent: 'axis',\r\n        child: 'axisWidth'\r\n    },\r\n    {\r\n        property: Property.AXIS_LAYER,\r\n        parent: 'axis',\r\n        child: 'layer'\r\n    },\r\n    {\r\n        property: Property.AXIS_OFFSET,\r\n        parent: 'axis',\r\n        child: 'offset'\r\n    },\r\n    {\r\n        property: Property.AXIS_ORIENT,\r\n        parent: 'axis',\r\n        child: 'orient'\r\n    },\r\n    {\r\n        property: Property.AXIS_GRID,\r\n        parent: 'axis',\r\n        child: 'grid'\r\n    },\r\n    {\r\n        property: Property.AXIS_GRIDCOLOR,\r\n        parent: 'axis',\r\n        child: 'gridColor'\r\n    },\r\n    {\r\n        property: Property.AXIS_GRIDDASH,\r\n        parent: 'axis',\r\n        child: 'gridDash'\r\n    },\r\n    {\r\n        property: Property.AXIS_GRIDOPACITY,\r\n        parent: 'axis',\r\n        child: 'gridOpacity'\r\n    },\r\n    {\r\n        property: Property.AXIS_GRIDWIDTH,\r\n        parent: 'axis',\r\n        child: 'gridWidth'\r\n    },\r\n    {\r\n        property: Property.AXIS_LABELS,\r\n        parent: 'axis',\r\n        child: 'labels'\r\n    },\r\n    {\r\n        property: Property.AXIS_FORMAT,\r\n        parent: 'axis',\r\n        child: 'format'\r\n    },\r\n    {\r\n        property: Property.AXIS_LABELANGLE,\r\n        parent: 'axis',\r\n        child: 'labelAngle'\r\n    },\r\n    {\r\n        property: Property.AXIS_LABELMAXLENGTH,\r\n        parent: 'axis',\r\n        child: 'labelMaxLength'\r\n    },\r\n    {\r\n        property: Property.AXIS_SHORTTIMELABELS,\r\n        parent: 'axis',\r\n        child: 'shortTimeLabels'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKS,\r\n        parent: 'axis',\r\n        child: 'ticks'\r\n    },\r\n    {\r\n        property: Property.AXIS_SUBDIVIDE,\r\n        parent: 'axis',\r\n        child: 'subdivide'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKCOLOR,\r\n        parent: 'axis',\r\n        child: 'tickColor'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKLABELCOLOR,\r\n        parent: 'axis',\r\n        child: 'tickLabelColor'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKLABELFONT,\r\n        parent: 'axis',\r\n        child: 'tickLabelFont'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKLABELFONTSIZE,\r\n        parent: 'axis',\r\n        child: 'tickLabelFontSize'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKPADDING,\r\n        parent: 'axis',\r\n        child: 'tickPadding'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKSIZE,\r\n        parent: 'axis',\r\n        child: 'tickSize'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKSIZEMAJOR,\r\n        parent: 'axis',\r\n        child: 'tickSizeMajor'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKSIZEMINOR,\r\n        parent: 'axis',\r\n        child: 'tickSizeMinor'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKSIZEEND,\r\n        parent: 'axis',\r\n        child: 'tickSizeEnd'\r\n    },\r\n    {\r\n        property: Property.AXIS_TICKWIDTH,\r\n        parent: 'axis',\r\n        child: 'tickWidth'\r\n    },\r\n    {\r\n        property: Property.AXIS_VALUES,\r\n        parent: 'axis',\r\n        child: 'values'\r\n    },\r\n    {\r\n        property: Property.AXIS_TITLE,\r\n        parent: 'axis',\r\n        child: 'title'\r\n    },\r\n    {\r\n        property: Property.AXIS_TITLECOLOR,\r\n        parent: 'axis',\r\n        child: 'titleColor'\r\n    },\r\n    {\r\n        property: Property.AXIS_TITLEFONT,\r\n        parent: 'axis',\r\n        child: 'titleFont'\r\n    },\r\n    {\r\n        property: Property.AXIS_TITLEFONTSIZE,\r\n        parent: 'axis',\r\n        child: 'titleFontSize'\r\n    },\r\n    {\r\n        property: Property.AXIS_TITLEFONTWEIGHT,\r\n        parent: 'axis',\r\n        child: 'titleFontWeight'\r\n    },\r\n    {\r\n        property: Property.AXIS_CHARACTERWIDTH,\r\n        parent: 'axis',\r\n        child: 'characterWidth'\r\n    },\r\n    {\r\n        property: Property.AXIS_TITLEMAXLENGTH,\r\n        parent: 'axis',\r\n        child: 'titleMaxLength'\r\n    },\r\n    {\r\n        property: Property.AXIS_TITLEOFFSET,\r\n        parent: 'axis',\r\n        child: 'titleOffset'\r\n    },\r\n    {\r\n        property: Property.LEGEND_ORIENT,\r\n        parent: 'legend',\r\n        child: 'orient'\r\n    },\r\n    {\r\n        property: Property.LEGEND_OFFSET,\r\n        parent: 'legend',\r\n        child: 'offset',\r\n    },\r\n    {\r\n        property: Property.LEGEND_VALUES,\r\n        parent: 'legend',\r\n        child: 'values'\r\n    },\r\n    {\r\n        property: Property.LEGEND_FORMAT,\r\n        parent: 'legend',\r\n        child: 'format'\r\n    },\r\n    {\r\n        property: Property.LEGEND_LABELALIGN,\r\n        parent: 'legend',\r\n        child: 'labelAlign'\r\n    },\r\n    {\r\n        property: Property.LEGEND_LABELBASELINE,\r\n        parent: 'legend',\r\n        child: 'labelBaseline'\r\n    },\r\n    {\r\n        property: Property.LEGEND_LABELFONT,\r\n        parent: 'legend',\r\n        child: 'labelFont'\r\n    },\r\n    {\r\n        property: Property.LEGEND_LABELFONTSIZE,\r\n        parent: 'legend',\r\n        child: 'labelFontSize'\r\n    },\r\n    {\r\n        property: Property.LEGEND_SHORTTIMELABELS,\r\n        parent: 'legend',\r\n        child: 'shortTimeLabels'\r\n    },\r\n    {\r\n        property: Property.LEGEND_SYMBOLCOLOR,\r\n        parent: 'legend',\r\n        child: 'symbolColor'\r\n    },\r\n    {\r\n        property: Property.LEGEND_SYMBOLSHAPE,\r\n        parent: 'legend',\r\n        child: 'symbolShape'\r\n    },\r\n    {\r\n        property: Property.LEGEND_SYMBOLSIZE,\r\n        parent: 'legend',\r\n        child: 'symbolSize'\r\n    },\r\n    {\r\n        property: Property.LEGEND_SYMBOLSTROKEWIDTH,\r\n        parent: 'legend',\r\n        child: 'symbolStrokeWidth'\r\n    },\r\n    {\r\n        property: Property.LEGEND_TITLE,\r\n        parent: 'legend',\r\n        child: 'title'\r\n    },\r\n    {\r\n        property: Property.LEGEND_TITLECOLOR,\r\n        parent: 'legend',\r\n        child: 'titleColor'\r\n    },\r\n    {\r\n        property: Property.LEGEND_TITLEFONT,\r\n        parent: 'legend',\r\n        child: 'titleFont'\r\n    },\r\n    {\r\n        property: Property.LEGEND_TITLEFONTSIZE,\r\n        parent: 'legend',\r\n        child: 'titleFontSize'\r\n    },\r\n    {\r\n        property: Property.LEGEND_TITLEFONTWEIGHT,\r\n        parent: 'legend',\r\n        child: 'titleFontWeight'\r\n    }\r\n];\r\nvar NESTED_ENCODING_INDEX = exports.NESTED_ENCODING_PROPERTIES.reduce(function (m, nestedProp) {\r\n    m[nestedProp.property] = nestedProp;\r\n    return m;\r\n}, {});\r\nvar NESTED_ENCODING_PROPERTY_PARENT_INDEX = exports.NESTED_ENCODING_PROPERTIES.reduce(function (m, nestedProp) {\r\n    var parent = nestedProp.parent;\r\n    // if the parent does not exist in m yet, add it as a key in m with empty [] as value\r\n    if (!(parent in m)) {\r\n        m[parent] = [];\r\n    }\r\n    m[nestedProp.parent].push(nestedProp);\r\n    return m;\r\n}, {}); // as Dict<Array<String>>);\r\nexports.SCALE_PROPERTIES = NESTED_ENCODING_PROPERTY_PARENT_INDEX['scale'].map(function (nestedProp) {\r\n    return nestedProp.property;\r\n});\r\nvar ENCODING_INDEX = exports.ENCODING_PROPERTIES.reduce(function (m, prop) {\r\n    m[prop] = prop;\r\n    return m;\r\n}, {});\r\nfunction isEncodingProperty(prop) {\r\n    return ENCODING_INDEX[prop] !== undefined;\r\n}\r\nexports.isEncodingProperty = isEncodingProperty;\r\nfunction getNestedEncodingProperty(prop) {\r\n    return NESTED_ENCODING_INDEX[prop];\r\n}\r\nexports.getNestedEncodingProperty = getNestedEncodingProperty;\r\nfunction getNestedEncodingPropertyChildren(parent) {\r\n    return NESTED_ENCODING_PROPERTY_PARENT_INDEX[parent];\r\n}\r\nexports.getNestedEncodingPropertyChildren = getNestedEncodingPropertyChildren;\r\nfunction isNestedEncodingProperty(prop) {\r\n    return prop in NESTED_ENCODING_INDEX;\r\n}\r\nexports.isNestedEncodingProperty = isNestedEncodingProperty;\r\nvar SUPPORTED_SCALE_PROPERTY = [\r\n    {\r\n        property: 'bandSize',\r\n        supportedScaleType: [\r\n            scale_1.ScaleType.ORDINAL\r\n        ]\r\n    },\r\n    {\r\n        property: 'clamp',\r\n        supportedScaleType: [\r\n            scale_1.ScaleType.LINEAR,\r\n            scale_1.ScaleType.LOG,\r\n            scale_1.ScaleType.POW,\r\n            scale_1.ScaleType.TIME,\r\n            scale_1.ScaleType.UTC\r\n        ]\r\n    },\r\n    {\r\n        property: 'domain',\r\n        supportedScaleType: [\r\n            scale_1.ScaleType.LINEAR,\r\n            scale_1.ScaleType.LOG,\r\n            scale_1.ScaleType.POW,\r\n            scale_1.ScaleType.QUANTILE,\r\n            scale_1.ScaleType.QUANTIZE,\r\n            scale_1.ScaleType.ORDINAL,\r\n            scale_1.ScaleType.SQRT,\r\n            scale_1.ScaleType.TIME,\r\n            scale_1.ScaleType.UTC\r\n        ]\r\n    },\r\n    {\r\n        property: 'exponent',\r\n        supportedScaleType: [\r\n            scale_1.ScaleType.LOG,\r\n            scale_1.ScaleType.POW,\r\n            scale_1.ScaleType.SQRT\r\n        ]\r\n    },\r\n    {\r\n        property: 'nice',\r\n        supportedScaleType: [\r\n            scale_1.ScaleType.LINEAR,\r\n            scale_1.ScaleType.LOG,\r\n            scale_1.ScaleType.POW,\r\n            scale_1.ScaleType.TIME,\r\n            scale_1.ScaleType.UTC\r\n        ]\r\n    },\r\n    {\r\n        property: 'range',\r\n        supportedScaleType: [\r\n            scale_1.ScaleType.LINEAR,\r\n            scale_1.ScaleType.LOG,\r\n            scale_1.ScaleType.POW,\r\n            scale_1.ScaleType.QUANTILE,\r\n            scale_1.ScaleType.QUANTIZE,\r\n            scale_1.ScaleType.ORDINAL,\r\n            scale_1.ScaleType.SQRT,\r\n            scale_1.ScaleType.TIME,\r\n            scale_1.ScaleType.UTC\r\n        ]\r\n    },\r\n    {\r\n        property: 'round',\r\n        supportedScaleType: [\r\n            scale_1.ScaleType.LINEAR,\r\n            scale_1.ScaleType.LOG,\r\n            scale_1.ScaleType.POW,\r\n            scale_1.ScaleType.SQRT,\r\n            scale_1.ScaleType.TIME,\r\n            scale_1.ScaleType.UTC\r\n        ]\r\n    },\r\n    {\r\n        property: 'useRawDomain',\r\n        supportedScaleType: [\r\n            scale_1.ScaleType.LINEAR,\r\n            scale_1.ScaleType.LOG,\r\n            scale_1.ScaleType.POW,\r\n            scale_1.ScaleType.QUANTILE,\r\n            scale_1.ScaleType.QUANTIZE,\r\n            scale_1.ScaleType.ORDINAL,\r\n            scale_1.ScaleType.SQRT,\r\n            scale_1.ScaleType.TIME,\r\n            scale_1.ScaleType.UTC\r\n        ]\r\n    },\r\n    {\r\n        property: 'zero',\r\n        supportedScaleType: [\r\n            scale_1.ScaleType.LINEAR,\r\n            scale_1.ScaleType.POW,\r\n            scale_1.ScaleType.SQRT\r\n        ]\r\n    }\r\n];\r\nexports.SUPPORTED_SCALE_PROPERTY_INDEX = SUPPORTED_SCALE_PROPERTY.reduce(function (m, scaleProp) {\r\n    var prop = scaleProp.property;\r\n    m[prop] = scaleProp.supportedScaleType;\r\n    return m;\r\n}, {});\r\n//# sourceMappingURL=property.js.map",
    "\"use strict\";\r\nvar scale_1 = require('vega-lite/src/scale');\r\nvar timeunit_1 = require('vega-lite/src/timeunit');\r\nvar type_1 = require('vega-lite/src/type');\r\nvar enumspec_1 = require('../enumspec');\r\nvar util_1 = require('../util');\r\nfunction isDimension(encQ) {\r\n    return util_1.contains([type_1.Type.NOMINAL, type_1.Type.ORDINAL], encQ.type) ||\r\n        (!enumspec_1.isEnumSpec(encQ.bin) && !!encQ.bin) ||\r\n        (!enumspec_1.isEnumSpec(encQ.timeUnit) && !!encQ.timeUnit); // surely T type\r\n}\r\nexports.isDimension = isDimension;\r\nfunction isMeasure(encQ) {\r\n    return (encQ.type === type_1.Type.QUANTITATIVE && !encQ.bin) ||\r\n        (encQ.type === type_1.Type.TEMPORAL && !encQ.timeUnit);\r\n}\r\nexports.isMeasure = isMeasure;\r\n/**\r\n *  Returns the true scale type of an encoding.\r\n *  @returns {ScaleType} If the scale type was not specified, it is inferred from the encoding's Type.\r\n *  @returns {undefined} If the scale type was not specified and Type (or TimeUnit if applicable) is an EnumSpec, there is no clear scale type\r\n */\r\nfunction scaleType(encQ) {\r\n    var scale = encQ.scale === true || encQ.scale === enumspec_1.SHORT_ENUM_SPEC ? {} : encQ.scale;\r\n    var type = encQ.type;\r\n    var timeUnit = encQ.timeUnit;\r\n    if (scale && scale.type !== undefined) {\r\n        return scale.type;\r\n    }\r\n    if (enumspec_1.isEnumSpec(type)) {\r\n        return undefined;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (type === type_1.Type.QUANTITATIVE) {\r\n        return scale_1.ScaleType.LINEAR;\r\n    }\r\n    else if (type === type_1.Type.ORDINAL || type === type_1.Type.NOMINAL) {\r\n        return scale_1.ScaleType.ORDINAL;\r\n    }\r\n    else if (type === type_1.Type.TEMPORAL) {\r\n        if (timeUnit !== undefined) {\r\n            if (enumspec_1.isEnumSpec(timeUnit)) {\r\n                return undefined;\r\n            }\r\n            return timeunit_1.defaultScaleType(timeUnit);\r\n        }\r\n        else {\r\n            return scale_1.ScaleType.TIME;\r\n        }\r\n    }\r\n    else {\r\n        throw new Error('Unsupported type: ' + type + ' in scaleType');\r\n    }\r\n}\r\nexports.scaleType = scaleType;\r\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\r\nvar util_1 = require('datalib/src/util');\r\nvar util_2 = require('../util');\r\nexports.REPLACE_BLANK_FIELDS = { '*': '' };\r\nexports.REPLACE_XY_CHANNELS = { x: 'xy', y: 'xy' };\r\nexports.REPLACE_FACET_CHANNELS = { row: 'facet', column: 'facet' };\r\nexports.REPLACE_MARK_STYLE_CHANNELS = { color: 'style', opacity: 'style', shape: 'style', size: 'style' };\r\nfunction isExtendedGroupBy(g) {\r\n    return util_1.isObject(g) && !!g['property'];\r\n}\r\nexports.isExtendedGroupBy = isExtendedGroupBy;\r\nfunction parse(groupBy, include, replaceIndex) {\r\n    groupBy.forEach(function (grpBy) {\r\n        if (isExtendedGroupBy(grpBy)) {\r\n            include[grpBy.property] = true;\r\n            replaceIndex[grpBy.property] = grpBy.replace;\r\n        }\r\n        else {\r\n            include[grpBy] = true;\r\n        }\r\n    });\r\n}\r\nexports.parse = parse;\r\nfunction toString(groupBy) {\r\n    if (util_1.isArray(groupBy)) {\r\n        return groupBy.map(function (g) {\r\n            if (isExtendedGroupBy(g)) {\r\n                if (g.replace) {\r\n                    var replaceIndex = util_2.keys(g.replace).reduce(function (index, valFrom) {\r\n                        var valTo = g.replace[valFrom];\r\n                        (index[valTo] = index[valTo] || []).push(valFrom);\r\n                        return index;\r\n                    }, {});\r\n                    return g.property + '[' + util_2.keys(replaceIndex).map(function (valTo) {\r\n                        var valsFrom = replaceIndex[valTo].sort();\r\n                        return valsFrom.join(',') + '=>' + valTo;\r\n                    }).join(';') + ']';\r\n                }\r\n                return g.property;\r\n            }\r\n            return g;\r\n        }).join(',');\r\n    }\r\n    else {\r\n        return groupBy;\r\n    }\r\n}\r\nexports.toString = toString;\r\n//# sourceMappingURL=groupby.js.map",
    "\"use strict\";\r\nvar config_1 = require('../config');\r\nvar generate_1 = require('../generate');\r\nvar nest_1 = require('../nest');\r\nvar ranking_1 = require('../ranking/ranking');\r\nvar util_1 = require('../util');\r\nexports.encoding = require('./encoding');\r\nexports.groupBy = require('./groupby');\r\nexports.shorthand = require('./shorthand');\r\nexports.spec = require('./spec');\r\nexports.transform = require('./transform');\r\nfunction query(q, schema, config) {\r\n    // 1. Normalize non-nested `groupBy` to always have `groupBy` inside `nest`\r\n    //    and merge config with the following precedence\r\n    //    query.config > config > DEFAULT_QUERY_CONFIG\r\n    q = util_1.extend({}, normalize(q), {\r\n        config: util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, config, q.config)\r\n    });\r\n    // 2. Generate\r\n    var answerSet = generate_1.generate(q.spec, schema, q.config);\r\n    var nestedAnswerSet = nest_1.nest(answerSet, q);\r\n    var result = ranking_1.rank(nestedAnswerSet, q, schema, 0);\r\n    return {\r\n        query: q,\r\n        result: result\r\n    };\r\n}\r\nexports.query = query;\r\n/**\r\n * Normalize the non-nested version of the query to a standardize nested\r\n */\r\nfunction normalize(q) {\r\n    if (q.groupBy) {\r\n        var nest_2 = {\r\n            groupBy: q.groupBy\r\n        };\r\n        if (q.orderBy) {\r\n            nest_2.orderGroupBy = q.orderBy;\r\n        }\r\n        var normalizedQ = {\r\n            spec: util_1.duplicate(q.spec),\r\n            nest: [nest_2],\r\n        };\r\n        if (q.chooseBy) {\r\n            normalizedQ.chooseBy = q.chooseBy;\r\n        }\r\n        if (q.config) {\r\n            normalizedQ.config = q.config;\r\n        }\r\n        return normalizedQ;\r\n    }\r\n    return util_1.duplicate(q); // We will cause side effect to q.spec in SpecQueryModel.build\r\n}\r\nexports.normalize = normalize;\r\n//# sourceMappingURL=query.js.map",
    "\"use strict\";\r\nvar type_1 = require('vega-lite/src/type');\r\nvar util_1 = require('datalib/src/util');\r\nvar spec_1 = require('./spec');\r\nvar enumspec_1 = require('../enumspec');\r\nvar property_1 = require('../property');\r\nvar util_2 = require('../util');\r\nfunction getReplacerIndex(replaceIndex) {\r\n    return util_2.keys(replaceIndex).reduce(function (fnIndex, prop) {\r\n        fnIndex[prop] = getReplacer(replaceIndex[prop]);\r\n        return fnIndex;\r\n    }, {});\r\n}\r\nexports.getReplacerIndex = getReplacerIndex;\r\nfunction getReplacer(replace) {\r\n    return function (s) {\r\n        if (replace[s] !== undefined) {\r\n            return replace[s];\r\n        }\r\n        return s;\r\n    };\r\n}\r\nexports.getReplacer = getReplacer;\r\nfunction value(v, replacer) {\r\n    if (enumspec_1.isEnumSpec(v)) {\r\n        // Return the enum array if it's a full enum spec, or just return SHORT_ENUM_SPEC for short ones.\r\n        if (v.enum) {\r\n            return enumspec_1.SHORT_ENUM_SPEC + JSON.stringify(v.enum);\r\n        }\r\n        else {\r\n            return enumspec_1.SHORT_ENUM_SPEC;\r\n        }\r\n    }\r\n    if (replacer) {\r\n        return replacer(v);\r\n    }\r\n    return v;\r\n}\r\nexports.value = value;\r\nfunction replace(v, replacer) {\r\n    if (replacer) {\r\n        return replacer(v);\r\n    }\r\n    return v;\r\n}\r\nexports.replace = replace;\r\nexports.INCLUDE_ALL = \r\n// TODO: remove manual STACK, FILTER, CALCULATE concat once we really support enumerating it.\r\nproperty_1.DEFAULT_PROPERTY_PRECEDENCE.concat([property_1.Property.CALCULATE, property_1.Property.FILTER, property_1.Property.FILTERINVALID, property_1.Property.STACK])\r\n    .reduce(function (m, prop) {\r\n    m[prop] = true;\r\n    return m;\r\n}, {});\r\nfunction vlSpec(vlspec, include, replace) {\r\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\r\n    if (replace === void 0) { replace = {}; }\r\n    var specQ = spec_1.fromSpec(vlspec);\r\n    return spec(specQ);\r\n}\r\nexports.vlSpec = vlSpec;\r\nexports.PROPERTY_SUPPORTED_CHANNELS = {\r\n    axis: { x: true, y: true, row: true, column: true },\r\n    legend: { color: true, opacity: true, size: true, shape: true },\r\n    scale: { x: true, y: true, color: true, opacity: true, row: true, column: true, size: true, shape: true },\r\n    sort: { x: true, y: true, path: true, order: true }\r\n};\r\n/**\r\n * Returns a shorthand for a spec query\r\n * @param specQ a spec query\r\n * @param include Dict Set listing property types (key) to be included in the shorthand\r\n * @param replace Dictionary of replace function for values of a particular property type (key)\r\n */\r\nfunction spec(specQ, include, replace) {\r\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\r\n    if (replace === void 0) { replace = {}; }\r\n    var parts = [];\r\n    if (include[property_1.Property.MARK]) {\r\n        parts.push(value(specQ.mark, replace[property_1.Property.MARK]));\r\n    }\r\n    if (specQ.transform) {\r\n        if (include[property_1.Property.CALCULATE]) {\r\n            if (specQ.transform.calculate !== undefined) {\r\n                parts.push('calculate:' + calculate(specQ.transform.calculate));\r\n            }\r\n        }\r\n        if (include[property_1.Property.FILTER]) {\r\n            if (specQ.transform.filter !== undefined) {\r\n                parts.push('filter:' + JSON.stringify(specQ.transform.filter));\r\n            }\r\n        }\r\n        if (include[property_1.Property.FILTERINVALID]) {\r\n            if (specQ.transform.filterInvalid !== undefined) {\r\n                parts.push('filterInvalid:' + specQ.transform.filterInvalid);\r\n            }\r\n        }\r\n    }\r\n    // TODO: extract this to its own stack method\r\n    if (include[property_1.Property.STACK]) {\r\n        var _stack = spec_1.stack(specQ);\r\n        if (_stack) {\r\n            // TODO: Refactor this once we have child stack property.\r\n            // Exclude type since we don't care about type in stack\r\n            var includeExceptType = util_2.extend({}, include, { type: false });\r\n            var field = fieldDef(_stack.fieldEncQ, includeExceptType, replace);\r\n            var groupby = fieldDef(_stack.groupByEncQ, includeExceptType, replace);\r\n            parts.push('stack={field:' + field + ',' +\r\n                (groupby ? 'by:' + groupby + ',' : '') +\r\n                'offset:' + _stack.offset + '}');\r\n        }\r\n    }\r\n    parts.push(specQ.encodings.reduce(function (encQs, encQ) {\r\n        // Exclude encoding mapping with autoCount=false as they are basically disabled.\r\n        if (encQ.autoCount !== false) {\r\n            var str = encoding(encQ, include, replace);\r\n            if (str) {\r\n                encQs.push(str);\r\n            }\r\n        }\r\n        return encQs;\r\n    }, [])\r\n        .sort() // sort at the end to ignore order\r\n        .join('|'));\r\n    return parts.join('|');\r\n}\r\nexports.spec = spec;\r\nfunction calculate(formulaArr) {\r\n    return formulaArr.map(function (calculateItem) {\r\n        return \"{\" + calculateItem.field + \":\" + calculateItem.expr + \"}\";\r\n    }).join(',');\r\n}\r\nexports.calculate = calculate;\r\n/**\r\n * Returns a shorthand for an encoding query\r\n * @param encQ an encoding query\r\n * @param include Dict Set listing property types (key) to be included in the shorthand\r\n * @param replace Dictionary of replace function for values of a particular property type (key)\r\n */\r\nfunction encoding(encQ, include, replace) {\r\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\r\n    if (replace === void 0) { replace = {}; }\r\n    var parts = [];\r\n    if (include[property_1.Property.CHANNEL]) {\r\n        parts.push(value(encQ.channel, replace[property_1.Property.CHANNEL]));\r\n    }\r\n    var fieldDefStr = fieldDef(encQ, include, replace);\r\n    if (fieldDefStr) {\r\n        parts.push(fieldDefStr);\r\n    }\r\n    return parts.join(':');\r\n}\r\nexports.encoding = encoding;\r\n/**\r\n * Returns a field definiton shorthand for an encoding query\r\n * @param encQ an encoding query\r\n * @param include Dict Set listing property types (key) to be included in the shorthand\r\n * @param replace Dictionary of replace function for values of a particular property type (key)\r\n */\r\nfunction fieldDef(encQ, include, replacer) {\r\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\r\n    if (replacer === void 0) { replacer = {}; }\r\n    var fn = null, fnEnumIndex = null;\r\n    /** Encoding properties e.g., Scale, Axis, Legend */\r\n    var props = [];\r\n    if (include[property_1.Property.AGGREGATE] && encQ.autoCount === false) {\r\n        return '-';\r\n    }\r\n    else if (include[property_1.Property.AGGREGATE] && encQ.aggregate && !enumspec_1.isEnumSpec(encQ.aggregate)) {\r\n        fn = replace(encQ.aggregate, replacer[property_1.Property.AGGREGATE]);\r\n    }\r\n    else if (include[property_1.Property.AGGREGATE] && encQ.autoCount && !enumspec_1.isEnumSpec(encQ.autoCount)) {\r\n        fn = replace('count', replacer[property_1.Property.AGGREGATE]);\r\n        ;\r\n    }\r\n    else if (include[property_1.Property.TIMEUNIT] && encQ.timeUnit && !enumspec_1.isEnumSpec(encQ.timeUnit)) {\r\n        fn = replace(encQ.timeUnit, replacer[property_1.Property.TIMEUNIT]);\r\n    }\r\n    else if (include[property_1.Property.BIN] && encQ.bin && !enumspec_1.isEnumSpec(encQ.bin)) {\r\n        fn = 'bin';\r\n        // TODO(https://github.com/uwdata/compassql/issues/97):\r\n        // extract this as a method that support other bin properties\r\n        if (include[property_1.Property.BIN_MAXBINS] && encQ.bin['maxbins']) {\r\n            props.push({\r\n                key: 'maxbins',\r\n                value: value(encQ.bin['maxbins'], replacer[property_1.Property.BIN_MAXBINS])\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        for (var _i = 0, _a = [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN]; _i < _a.length; _i++) {\r\n            var prop = _a[_i];\r\n            if (include[prop] && encQ[prop] && enumspec_1.isEnumSpec(encQ[prop])) {\r\n                fn = enumspec_1.SHORT_ENUM_SPEC + '';\r\n                // assign fnEnumIndex[prop] = array of enum values or just \"?\" if it is SHORT_ENUM_SPEC\r\n                fnEnumIndex = fnEnumIndex || {};\r\n                fnEnumIndex[prop] = encQ[prop].enum || encQ[prop];\r\n                if (prop === property_1.Property.BIN) {\r\n                    // TODO(https://github.com/uwdata/compassql/issues/97):\r\n                    // extract this as a method that support other bin properties\r\n                    if (include[property_1.Property.BIN_MAXBINS] && encQ.bin['maxbins']) {\r\n                        props.push({\r\n                            key: 'maxbins',\r\n                            value: value(encQ.bin['maxbins'], replacer[property_1.Property.BIN_MAXBINS])\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (fnEnumIndex && encQ.hasFn) {\r\n            fnEnumIndex.hasFn = true;\r\n        }\r\n    }\r\n    var _loop_1 = function(nestedPropParent) {\r\n        if (!enumspec_1.isEnumSpec(encQ.channel) && !exports.PROPERTY_SUPPORTED_CHANNELS[nestedPropParent][encQ.channel]) {\r\n            return \"continue\";\r\n        }\r\n        if (include[nestedPropParent]) {\r\n            if (encQ[nestedPropParent] && !enumspec_1.isEnumSpec(encQ[nestedPropParent])) {\r\n                // `sort` can be a string (ascending/descending).\r\n                if (util_1.isString(encQ[nestedPropParent])) {\r\n                    props.push({\r\n                        key: nestedPropParent + '',\r\n                        value: JSON.stringify(encQ[nestedPropParent])\r\n                    });\r\n                }\r\n                else {\r\n                    var nestedProps = property_1.getNestedEncodingPropertyChildren(nestedPropParent);\r\n                    var nestedPropChildren = nestedProps.reduce(function (p, nestedProp) {\r\n                        if (include[nestedProp.property] && encQ[nestedPropParent][nestedProp.child] !== undefined) {\r\n                            p[nestedProp.child] = replace(encQ[nestedPropParent][nestedProp.child], replacer[nestedProp.property]);\r\n                        }\r\n                        return p;\r\n                    }, {});\r\n                    if (util_2.keys(nestedPropChildren).length > 0) {\r\n                        props.push({\r\n                            key: nestedPropParent + '',\r\n                            value: JSON.stringify(nestedPropChildren)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else if (encQ[nestedPropParent] === false || encQ[nestedPropParent] === null) {\r\n                // `scale`, `axis`, `legend` can be false/null.\r\n                props.push({\r\n                    key: nestedPropParent + '',\r\n                    value: false\r\n                });\r\n            }\r\n        }\r\n    };\r\n    for (var _b = 0, _c = [property_1.Property.SCALE, property_1.Property.SORT, property_1.Property.AXIS, property_1.Property.LEGEND]; _b < _c.length; _b++) {\r\n        var nestedPropParent = _c[_b];\r\n        var state_1 = _loop_1(nestedPropParent);\r\n        if (state_1 === \"continue\") continue;\r\n    }\r\n    // field\r\n    var fieldAndParams = include[property_1.Property.FIELD] ? value(encQ.field || '*', replacer[property_1.Property.FIELD]) : '...';\r\n    // type\r\n    if (include[property_1.Property.TYPE]) {\r\n        if (enumspec_1.isEnumSpec(encQ.type)) {\r\n            fieldAndParams += ',' + value(encQ.type, replacer[property_1.Property.TYPE]);\r\n        }\r\n        else {\r\n            var typeShort = ((encQ.type || type_1.Type.QUANTITATIVE) + '').substr(0, 1);\r\n            fieldAndParams += ',' + value(typeShort, replacer[property_1.Property.TYPE]);\r\n        }\r\n    }\r\n    // encoding properties\r\n    fieldAndParams += props.map(function (p) { return ',' + p.key + '=' + p.value; }).join('');\r\n    if (fn) {\r\n        return fn + (fnEnumIndex ? JSON.stringify(fnEnumIndex) : '') + '(' + fieldAndParams + ')';\r\n    }\r\n    return fieldAndParams;\r\n}\r\nexports.fieldDef = fieldDef;\r\n//# sourceMappingURL=shorthand.js.map",
    "\"use strict\";\r\nvar channel_1 = require('vega-lite/src/channel');\r\nvar mark_1 = require('vega-lite/src/mark');\r\nvar stack_1 = require('vega-lite/src/stack');\r\nvar enumspec_1 = require('../enumspec');\r\nvar property_1 = require('../property');\r\nvar util_1 = require('../util');\r\n/**\r\n * Convert a Vega-Lite's ExtendedUnitSpec into a CompassQL's SpecQuery\r\n * @param {ExtendedUnitSpec} spec\r\n * @returns\r\n */\r\nfunction fromSpec(spec) {\r\n    return util_1.extend(spec.data ? { data: spec.data } : {}, spec.transform ? { transform: spec.transform } : {}, {\r\n        mark: spec.mark,\r\n        encodings: util_1.keys(spec.encoding).map(function (channel) {\r\n            var encQ = { channel: channel };\r\n            var channelDef = spec.encoding[channel];\r\n            for (var _i = 0, ENCODING_PROPERTIES_1 = property_1.ENCODING_PROPERTIES; _i < ENCODING_PROPERTIES_1.length; _i++) {\r\n                var prop = ENCODING_PROPERTIES_1[_i];\r\n                if (!property_1.isNestedEncodingProperty(prop) && channelDef[prop] !== undefined) {\r\n                    encQ[prop] = channelDef[prop];\r\n                }\r\n                // Currently scale, axis, legend only support boolean, but not null.\r\n                // Therefore convert null to false.\r\n                if (util_1.contains([property_1.Property.SCALE, property_1.Property.AXIS, property_1.Property.LEGEND], prop) && encQ[prop] === null) {\r\n                    encQ[prop] = false;\r\n                }\r\n            }\r\n            return encQ;\r\n        })\r\n    }, spec.config ? { config: spec.config } : {});\r\n}\r\nexports.fromSpec = fromSpec;\r\nfunction isAggregate(specQ) {\r\n    return util_1.some(specQ.encodings, function (encQ) {\r\n        return (!enumspec_1.isEnumSpec(encQ.aggregate) && !!encQ.aggregate) || encQ.autoCount === true;\r\n    });\r\n}\r\nexports.isAggregate = isAggregate;\r\n/**\r\n * @return the stack offset type for the specQuery\r\n */\r\nfunction stack(specQ) {\r\n    var config = specQ.config;\r\n    var stacked = (config && config.mark) ? config.mark.stacked : undefined;\r\n    // Should not have stack explicitly disabled\r\n    if (util_1.contains([stack_1.StackOffset.NONE, null, false], stacked)) {\r\n        return null;\r\n    }\r\n    // Should have stackable mark\r\n    if (!util_1.contains([mark_1.BAR, mark_1.AREA], specQ.mark)) {\r\n        return null;\r\n    }\r\n    // Should be aggregate plot\r\n    if (!isAggregate(specQ)) {\r\n        return null;\r\n    }\r\n    var stackByChannels = specQ.encodings.reduce(function (sc, encQ) {\r\n        if (util_1.contains(channel_1.STACK_GROUP_CHANNELS, encQ.channel) && !encQ.aggregate) {\r\n            sc.push(encQ.channel);\r\n        }\r\n        return sc;\r\n    }, []);\r\n    if (stackByChannels.length === 0) {\r\n        return null;\r\n    }\r\n    // Has only one aggregate axis\r\n    var xEncQ = specQ.encodings.reduce(function (f, encQ) {\r\n        return f || (encQ.channel === channel_1.Channel.X ? encQ : null);\r\n    }, null);\r\n    var yEncQ = specQ.encodings.reduce(function (f, encQ) {\r\n        return f || (encQ.channel === channel_1.Channel.Y ? encQ : null);\r\n    }, null);\r\n    var xIsAggregate = !!xEncQ && (!!xEncQ.aggregate || !!xEncQ.autoCount);\r\n    var yIsAggregate = !!yEncQ && (!!yEncQ.aggregate || !!yEncQ.autoCount);\r\n    if (xIsAggregate !== yIsAggregate) {\r\n        return {\r\n            groupbyChannel: xIsAggregate ? (!!yEncQ ? channel_1.Y : null) : (!!xEncQ ? channel_1.X : null),\r\n            groupByEncQ: xIsAggregate ? yEncQ : xEncQ,\r\n            fieldChannel: xIsAggregate ? channel_1.X : channel_1.Y,\r\n            fieldEncQ: xIsAggregate ? xEncQ : yEncQ,\r\n            stackByChannels: stackByChannels,\r\n            offset: stacked || stack_1.StackOffset.ZERO\r\n        };\r\n    }\r\n    return null;\r\n}\r\nexports.stack = stack;\r\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\r\n//# sourceMappingURL=transform.js.map",
    "\"use strict\";\r\nvar aggregate_1 = require('vega-lite/src/aggregate');\r\nvar type_1 = require('vega-lite/src/type');\r\nvar util_1 = require('../util');\r\nvar encoding_1 = require('../query/encoding');\r\nexports.name = 'aggregationQuality';\r\nfunction score(specM, schema, opt) {\r\n    var feature = aggregationQualityFeature(specM, schema, opt);\r\n    return {\r\n        score: feature.score,\r\n        features: [feature]\r\n    };\r\n}\r\nexports.score = score;\r\nfunction aggregationQualityFeature(specM, schema, opt) {\r\n    var encodings = specM.getEncodings();\r\n    if (specM.isAggregate()) {\r\n        var isRawContinuous = function (encQ) {\r\n            return (encQ.type === type_1.Type.QUANTITATIVE && !encQ.bin && !encQ.aggregate && !encQ.autoCount) ||\r\n                (encQ.type === type_1.Type.TEMPORAL && !encQ.timeUnit);\r\n        };\r\n        if (util_1.some(encodings, isRawContinuous)) {\r\n            // These are plots that pollute continuous fields as dimension.\r\n            // They are often intermediate visualizations rather than what users actually want.\r\n            return {\r\n                type: exports.name,\r\n                score: 0.1,\r\n                feature: 'Aggregate with raw continuous'\r\n            };\r\n        }\r\n        if (util_1.some(encodings, encoding_1.isDimension)) {\r\n            var hasCount = util_1.some(encodings, function (encQ) {\r\n                return encQ.aggregate === aggregate_1.AggregateOp.COUNT || encQ.autoCount === true;\r\n            });\r\n            var hasBin = util_1.some(encodings, function (encQ) {\r\n                return !!encQ.bin;\r\n            });\r\n            if (hasCount) {\r\n                // If there is count, we might add additional count field, making it a little less simple\r\n                // then when we just apply aggregate to Q field\r\n                return {\r\n                    type: exports.name,\r\n                    score: 0.8,\r\n                    feature: 'Aggregate with count'\r\n                };\r\n            }\r\n            else if (hasBin) {\r\n                // This is not as good as binning all the Q and show heatmap\r\n                return {\r\n                    type: exports.name,\r\n                    score: 0.7,\r\n                    feature: 'Aggregate with bin but without count'\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: exports.name,\r\n                    score: 0.9,\r\n                    feature: 'Aggregate without count and without bin'\r\n                };\r\n            }\r\n        }\r\n        // no dimension -- often not very useful\r\n        return {\r\n            type: exports.name,\r\n            score: 0.3,\r\n            feature: 'Aggregate without dimension'\r\n        };\r\n    }\r\n    else {\r\n        if (util_1.some(encodings, encoding_1.isMeasure)) {\r\n            // raw plots with measure -- simplest of all!\r\n            return {\r\n                type: exports.name,\r\n                score: 1,\r\n                feature: 'Raw with measure'\r\n            };\r\n        }\r\n        // raw plots with no measure -- often a lot of occlusion\r\n        return {\r\n            type: exports.name,\r\n            score: 0.2,\r\n            feature: 'Raw without measure'\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=aggregation.js.map",
    "\"use strict\";\r\nvar channel_1 = require('vega-lite/src/channel');\r\nvar config_1 = require('../../config');\r\nvar shorthand_1 = require('../../query/shorthand');\r\nvar util_1 = require('../../util');\r\nvar effectiveness_1 = require('./effectiveness');\r\nvar type_1 = require('./type');\r\n/**\r\n * Field Type (with Bin and TimeUnit) and Channel Score (Cleveland / Mackinlay based)\r\n */\r\nvar TypeChannelScore;\r\n(function (TypeChannelScore) {\r\n    TypeChannelScore.TYPE_CHANNEL = 'typeChannel';\r\n    function init() {\r\n        var SCORE = {};\r\n        var ORDERED_TYPE_CHANNEL_SCORE = {\r\n            x: 0,\r\n            y: 0,\r\n            size: -0.575,\r\n            color: -0.725,\r\n            opacity: -0.85,\r\n            text: -0.875,\r\n            row: -0.9,\r\n            column: -0.9,\r\n            shape: -2.5,\r\n            detail: -3\r\n        };\r\n        [type_1.Q, type_1.BIN_Q, type_1.T, type_1.TIMEUNIT_T, type_1.TIMEUNIT_O, type_1.O].forEach(function (type) {\r\n            util_1.keys(ORDERED_TYPE_CHANNEL_SCORE).forEach(function (channel) {\r\n                SCORE[featurize(type, channel)] = ORDERED_TYPE_CHANNEL_SCORE[channel];\r\n            });\r\n        });\r\n        // Penalize row/column for bin quantitative / timeUnit_temporal / O less\r\n        [type_1.BIN_Q, type_1.TIMEUNIT_T, type_1.TIMEUNIT_O, type_1.O].forEach(function (type) {\r\n            [channel_1.Channel.ROW, channel_1.Channel.COLUMN].forEach(function (channel) {\r\n                SCORE[featurize(type, channel)] += 0.15;\r\n            });\r\n        });\r\n        var NOMINAL_TYPE_CHANNEL_SCORE = {\r\n            x: 0,\r\n            y: 0,\r\n            color: -0.6,\r\n            shape: -0.65,\r\n            row: -0.7,\r\n            column: -0.7,\r\n            text: -0.8,\r\n            size: -1.8,\r\n            detail: -2,\r\n            opacity: -2.1\r\n        };\r\n        util_1.keys(NOMINAL_TYPE_CHANNEL_SCORE).forEach(function (channel) {\r\n            SCORE[featurize(type_1.N, channel)] = NOMINAL_TYPE_CHANNEL_SCORE[channel];\r\n        });\r\n        return SCORE;\r\n    }\r\n    TypeChannelScore.init = init;\r\n    function featurize(type, channel) {\r\n        return type + '_' + channel;\r\n    }\r\n    TypeChannelScore.featurize = featurize;\r\n    function getScore(specM, schema, opt) {\r\n        var encodingQueryByField = specM.getEncodings().reduce(function (m, encQ) {\r\n            var fieldKey = shorthand_1.fieldDef(encQ);\r\n            (m[fieldKey] = m[fieldKey] || []).push(encQ);\r\n            return m;\r\n        }, {});\r\n        var features = [];\r\n        util_1.forEach(encodingQueryByField, function (encQs) {\r\n            var bestFieldFeature = encQs.reduce(function (best, encQ) {\r\n                var type = type_1.getExtendedType(encQ);\r\n                var feature = featurize(type, encQ.channel);\r\n                var featureScore = effectiveness_1.getFeatureScore(TypeChannelScore.TYPE_CHANNEL, feature);\r\n                if (best === null || featureScore.score > best.score) {\r\n                    return featureScore;\r\n                }\r\n                return best;\r\n            }, null);\r\n            features.push(bestFieldFeature);\r\n            // TODO: add plus for over-encoding of one field\r\n        });\r\n        return features;\r\n    }\r\n    TypeChannelScore.getScore = getScore;\r\n})(TypeChannelScore = exports.TypeChannelScore || (exports.TypeChannelScore = {}));\r\nvar PreferredAxisScore;\r\n(function (PreferredAxisScore) {\r\n    PreferredAxisScore.PREFERRED_AXIS = 'preferredAxis';\r\n    // FIXME support doing this at runtime\r\n    function init(opt) {\r\n        if (opt === void 0) { opt = {}; }\r\n        opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\r\n        var score = {};\r\n        var preferredAxes = [{\r\n                feature: type_1.BIN_Q,\r\n                opt: 'preferredBinAxis'\r\n            }, {\r\n                feature: type_1.T,\r\n                opt: 'preferredTemporalAxis'\r\n            }, {\r\n                feature: type_1.TIMEUNIT_T,\r\n                opt: 'preferredTemporalAxis'\r\n            }, {\r\n                feature: type_1.TIMEUNIT_O,\r\n                opt: 'preferredTemporalAxis'\r\n            }, {\r\n                feature: type_1.O,\r\n                opt: 'preferredOrdinalAxis'\r\n            }, {\r\n                feature: type_1.N,\r\n                opt: 'preferredNominalAxis'\r\n            }];\r\n        preferredAxes.forEach(function (preferredAxis) {\r\n            if (opt[preferredAxis.opt] === channel_1.Channel.X) {\r\n                // penalize the other axis\r\n                score[preferredAxis.feature + '_' + channel_1.Channel.Y] = -0.01;\r\n            }\r\n            else if (opt[preferredAxis.opt] === channel_1.Channel.Y) {\r\n                // penalize the other axis\r\n                score[preferredAxis.feature + '_' + channel_1.Channel.X] = -0.01;\r\n            }\r\n        });\r\n        return score;\r\n    }\r\n    PreferredAxisScore.init = init;\r\n    function featurize(type, channel) {\r\n        return type + '_' + channel;\r\n    }\r\n    PreferredAxisScore.featurize = featurize;\r\n    function getScore(specM, schema, opt) {\r\n        return specM.getEncodings().reduce(function (features, encQ) {\r\n            var type = type_1.getExtendedType(encQ);\r\n            var feature = featurize(type, encQ.channel);\r\n            var featureScore = effectiveness_1.getFeatureScore(PreferredAxisScore.PREFERRED_AXIS, feature);\r\n            if (featureScore) {\r\n                features.push(featureScore);\r\n            }\r\n            return features;\r\n        }, []);\r\n    }\r\n    PreferredAxisScore.getScore = getScore;\r\n})(PreferredAxisScore = exports.PreferredAxisScore || (exports.PreferredAxisScore = {}));\r\nvar PreferredFacetScore;\r\n(function (PreferredFacetScore) {\r\n    PreferredFacetScore.PREFERRED_FACET = 'preferredFacet';\r\n    // FIXME support doing this at runtime\r\n    function init(opt) {\r\n        opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\r\n        var score = {};\r\n        if (opt.preferredFacet === channel_1.Channel.ROW) {\r\n            // penalize the other axis\r\n            score[channel_1.Channel.COLUMN] = -0.01;\r\n        }\r\n        else if (opt.preferredFacet === channel_1.Channel.COLUMN) {\r\n            // penalize the other axis\r\n            score[channel_1.Channel.ROW] = -0.01;\r\n        }\r\n        return score;\r\n    }\r\n    PreferredFacetScore.init = init;\r\n    function getScore(specM, schema, opt) {\r\n        return specM.getEncodings().reduce(function (features, encQ) {\r\n            var featureScore = effectiveness_1.getFeatureScore(PreferredFacetScore.PREFERRED_FACET, encQ.channel);\r\n            if (featureScore) {\r\n                features.push(featureScore);\r\n            }\r\n            return features;\r\n        }, []);\r\n    }\r\n    PreferredFacetScore.getScore = getScore;\r\n})(PreferredFacetScore = exports.PreferredFacetScore || (exports.PreferredFacetScore = {}));\r\nvar MarkChannelScore;\r\n(function (MarkChannelScore) {\r\n    // Penalty for certain channel for certain mark types\r\n    MarkChannelScore.MARK_CHANNEL = 'markChannel';\r\n    function init() {\r\n        return {\r\n            bar_size: -2,\r\n            tick_size: -2\r\n        };\r\n    }\r\n    MarkChannelScore.init = init;\r\n    function getScore(specM, schema, opt) {\r\n        var mark = specM.getMark();\r\n        return specM.getEncodings().reduce(function (featureScores, encQ) {\r\n            var feature = mark + '_' + encQ.channel;\r\n            var featureScore = effectiveness_1.getFeatureScore(MarkChannelScore.MARK_CHANNEL, feature);\r\n            if (featureScore) {\r\n                featureScores.push(featureScore);\r\n            }\r\n            return featureScores;\r\n        }, []);\r\n    }\r\n    MarkChannelScore.getScore = getScore;\r\n})(MarkChannelScore = exports.MarkChannelScore || (exports.MarkChannelScore = {}));\r\n/**\r\n * Penalize if facet channels are the only dimensions\r\n */\r\nvar DimensionScore;\r\n(function (DimensionScore) {\r\n    DimensionScore.DIMENSION = 'dimension';\r\n    function init() {\r\n        return {\r\n            row: -2,\r\n            column: -2,\r\n            color: 0,\r\n            opacity: 0,\r\n            size: 0,\r\n            shape: 0\r\n        };\r\n    }\r\n    DimensionScore.init = init;\r\n    function getScore(specM, schema, opt) {\r\n        if (specM.isAggregate()) {\r\n            specM.getEncodings().reduce(function (maxFScore, encQ) {\r\n                if (!encQ.aggregate && !encQ.autoCount) {\r\n                    var featureScore = effectiveness_1.getFeatureScore(DimensionScore.DIMENSION, encQ.channel + '');\r\n                    if (featureScore.score > maxFScore.score) {\r\n                        return featureScore;\r\n                    }\r\n                }\r\n                return maxFScore;\r\n            }, { type: DimensionScore.DIMENSION, feature: 'No Dimension', score: -5 });\r\n        }\r\n        return [];\r\n    }\r\n    DimensionScore.getScore = getScore;\r\n})(DimensionScore = exports.DimensionScore || (exports.DimensionScore = {}));\r\n//# sourceMappingURL=channel.js.map",
    "\"use strict\";\r\nvar channel_1 = require('./channel');\r\nvar mark_1 = require('./mark');\r\nexports.FEATURE_INDEX = {};\r\nvar FEATURE_FACTORIES = [];\r\nfunction getFeatureScore(type, feature) {\r\n    var score = exports.FEATURE_INDEX[type][feature];\r\n    if (score !== undefined) {\r\n        return {\r\n            score: score,\r\n            type: type,\r\n            feature: feature\r\n        };\r\n    }\r\n    return null;\r\n}\r\nexports.getFeatureScore = getFeatureScore;\r\nfunction addFeatureFactory(factory) {\r\n    FEATURE_FACTORIES.push(factory);\r\n    exports.FEATURE_INDEX[factory.type] = factory.init();\r\n}\r\nexports.addFeatureFactory = addFeatureFactory;\r\naddFeatureFactory({\r\n    type: channel_1.TypeChannelScore.TYPE_CHANNEL,\r\n    init: channel_1.TypeChannelScore.init,\r\n    getScore: channel_1.TypeChannelScore.getScore\r\n});\r\naddFeatureFactory({\r\n    type: channel_1.PreferredAxisScore.PREFERRED_AXIS,\r\n    init: channel_1.PreferredAxisScore.init,\r\n    getScore: channel_1.PreferredAxisScore.getScore\r\n});\r\naddFeatureFactory({\r\n    type: channel_1.PreferredFacetScore.PREFERRED_FACET,\r\n    init: channel_1.PreferredFacetScore.init,\r\n    getScore: channel_1.PreferredFacetScore.getScore\r\n});\r\naddFeatureFactory({\r\n    type: channel_1.MarkChannelScore.MARK_CHANNEL,\r\n    init: channel_1.MarkChannelScore.init,\r\n    getScore: channel_1.MarkChannelScore.getScore\r\n});\r\naddFeatureFactory({\r\n    type: mark_1.MarkScore.MARK_SCORE,\r\n    init: mark_1.MarkScore.init,\r\n    getScore: mark_1.MarkScore.getScore\r\n});\r\n// TODO: x/y, row/column preference\r\n// TODO: stacking\r\n// TODO: Channel, Cardinality\r\n// TODO: Penalize over encoding\r\nfunction default_1(specM, schema, opt) {\r\n    var features = FEATURE_FACTORIES.reduce(function (f, factory) {\r\n        var scores = factory.getScore(specM, schema, opt);\r\n        return f.concat(scores);\r\n    }, []);\r\n    return {\r\n        score: features.reduce(function (s, f) {\r\n            return s + f.score;\r\n        }, 0),\r\n        features: features\r\n    };\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = default_1;\r\n//# sourceMappingURL=effectiveness.js.map",
    "\"use strict\";\r\nvar channel_1 = require('vega-lite/src/channel');\r\nvar mark_1 = require('vega-lite/src/mark');\r\nvar util_1 = require('../../util');\r\nvar effectiveness_1 = require('./effectiveness');\r\nvar type_1 = require('./type');\r\nvar MarkScore;\r\n(function (MarkScore) {\r\n    MarkScore.MARK_SCORE = 'markScore';\r\n    function featurize(xType, yType, hasOcclusion, mark) {\r\n        return xType + '_' + yType + '_' + hasOcclusion + '_' + mark;\r\n    }\r\n    MarkScore.featurize = featurize;\r\n    function init() {\r\n        var MEASURES = [type_1.Q, type_1.T];\r\n        var DISCRETE = [type_1.BIN_Q, type_1.TIMEUNIT_O, type_1.O, type_1.N];\r\n        var DISCRETE_OR_NONE = DISCRETE.concat([type_1.NONE]);\r\n        var SCORE = {};\r\n        // QxQ\r\n        MEASURES.forEach(function (xType) {\r\n            MEASURES.forEach(function (yType) {\r\n                // has occlusion\r\n                var occludedQQMark = {\r\n                    point: 0,\r\n                    text: -0.2,\r\n                    tick: -0.5,\r\n                    rect: -1,\r\n                    bar: -2,\r\n                    line: -2,\r\n                    area: -2,\r\n                    rule: -2.5\r\n                };\r\n                util_1.forEach(occludedQQMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, true, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n                // no occlusion\r\n                // TODO: possible to use connected scatter plot\r\n                var noOccludedQQMark = {\r\n                    point: 0,\r\n                    text: -0.2,\r\n                    tick: -0.5,\r\n                    bar: -2,\r\n                    line: -2,\r\n                    area: -2,\r\n                    rule: -2.5\r\n                };\r\n                util_1.forEach(noOccludedQQMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, false, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n            });\r\n        });\r\n        // DxQ, QxD\r\n        MEASURES.forEach(function (xType) {\r\n            // HAS OCCLUSION\r\n            DISCRETE_OR_NONE.forEach(function (yType) {\r\n                var occludedDimensionMeasureMark = {\r\n                    tick: 0,\r\n                    point: -0.2,\r\n                    text: -0.5,\r\n                    bar: -2,\r\n                    line: -2,\r\n                    area: -2,\r\n                    rule: -2.5\r\n                };\r\n                util_1.forEach(occludedDimensionMeasureMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, true, mark);\r\n                    SCORE[feature] = score;\r\n                    // also do the inverse\r\n                    var feature2 = featurize(yType, xType, true, mark);\r\n                    SCORE[feature2] = score;\r\n                });\r\n            });\r\n            [type_1.TIMEUNIT_T].forEach(function (yType) {\r\n                var occludedDimensionMeasureMark = {\r\n                    // For Time Dimension with time scale, tick is not good\r\n                    point: 0,\r\n                    text: -0.5,\r\n                    tick: -1,\r\n                    bar: -2,\r\n                    line: -2,\r\n                    area: -2,\r\n                    rule: -2.5\r\n                };\r\n                util_1.forEach(occludedDimensionMeasureMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, true, mark);\r\n                    SCORE[feature] = score;\r\n                    // also do the inverse\r\n                    var feature2 = featurize(yType, xType, true, mark);\r\n                    SCORE[feature2] = score;\r\n                });\r\n            });\r\n            // NO OCCLUSION\r\n            [type_1.NONE, type_1.N, type_1.O].forEach(function (yType) {\r\n                var noOccludedQxN = {\r\n                    bar: 0,\r\n                    point: -0.2,\r\n                    tick: -0.25,\r\n                    text: -0.3,\r\n                    // Line / Area can mislead trend for N\r\n                    line: -2,\r\n                    area: -2,\r\n                    // Non-sense to use rule here\r\n                    rule: -2.5\r\n                };\r\n                util_1.forEach(noOccludedQxN, function (score, mark) {\r\n                    var feature = featurize(xType, yType, false, mark);\r\n                    SCORE[feature] = score;\r\n                    // also do the inverse\r\n                    var feature2 = featurize(yType, xType, false, mark);\r\n                    SCORE[feature2] = score;\r\n                });\r\n            });\r\n            [type_1.BIN_Q].forEach(function (yType) {\r\n                var noOccludedQxBinQ = {\r\n                    bar: 0,\r\n                    point: -0.2,\r\n                    tick: -0.25,\r\n                    text: -0.3,\r\n                    // Line / Area isn't the best fit for bin\r\n                    line: -0.5,\r\n                    area: -0.5,\r\n                    // Non-sense to use rule here\r\n                    rule: -2.5\r\n                };\r\n                util_1.forEach(noOccludedQxBinQ, function (score, mark) {\r\n                    var feature = featurize(xType, yType, false, mark);\r\n                    SCORE[feature] = score;\r\n                    // also do the inverse\r\n                    var feature2 = featurize(yType, xType, false, mark);\r\n                    SCORE[feature2] = score;\r\n                });\r\n            });\r\n            [type_1.TIMEUNIT_T, type_1.TIMEUNIT_O].forEach(function (yType) {\r\n                // For aggregate / surely no occlusion plot, Temporal with time or ordinal\r\n                // are not that different.\r\n                var noOccludedQxBinQ = {\r\n                    line: 0,\r\n                    area: -0.1,\r\n                    bar: -0.2,\r\n                    point: -0.3,\r\n                    tick: -0.35,\r\n                    text: -0.4,\r\n                    // Non-sense to use rule here\r\n                    rule: -2.5\r\n                };\r\n                util_1.forEach(noOccludedQxBinQ, function (score, mark) {\r\n                    var feature = featurize(xType, yType, false, mark);\r\n                    SCORE[feature] = score;\r\n                    // also do the inverse\r\n                    var feature2 = featurize(yType, xType, false, mark);\r\n                    SCORE[feature2] = score;\r\n                });\r\n            });\r\n        });\r\n        [type_1.TIMEUNIT_T].forEach(function (xType) {\r\n            [type_1.TIMEUNIT_T].forEach(function (yType) {\r\n                // has occlusion\r\n                var ttMark = {\r\n                    point: 0,\r\n                    rect: -0.1,\r\n                    text: -0.5,\r\n                    tick: -1,\r\n                    bar: -2,\r\n                    line: -2,\r\n                    area: -2,\r\n                    rule: -2.5\r\n                };\r\n                // No difference between has occlusion and no occlusion\r\n                // as most of the time, it will be the occluded case.\r\n                util_1.forEach(ttMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, true, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n                util_1.forEach(ttMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, false, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n            });\r\n            DISCRETE_OR_NONE.forEach(function (yType) {\r\n                // has occlusion\r\n                var tdMark = {\r\n                    tick: 0,\r\n                    point: -0.2,\r\n                    text: -0.5,\r\n                    rect: -1,\r\n                    bar: -2,\r\n                    line: -2,\r\n                    area: -2,\r\n                    rule: -2.5\r\n                };\r\n                // No difference between has occlusion and no occlusion\r\n                // as most of the time, it will be the occluded case.\r\n                util_1.forEach(tdMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, true, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n                util_1.forEach(tdMark, function (score, mark) {\r\n                    var feature = featurize(yType, xType, true, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n                util_1.forEach(tdMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, false, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n                util_1.forEach(tdMark, function (score, mark) {\r\n                    var feature = featurize(yType, xType, false, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n            });\r\n        });\r\n        // DxD\r\n        DISCRETE_OR_NONE.forEach(function (xType) {\r\n            DISCRETE_OR_NONE.forEach(function (yType) {\r\n                // has occlusion\r\n                var ddMark = {\r\n                    point: 0,\r\n                    rect: 0,\r\n                    text: -0.1,\r\n                    tick: -1,\r\n                    bar: -2,\r\n                    line: -2,\r\n                    area: -2,\r\n                    rule: -2.5\r\n                };\r\n                // No difference between has occlusion and no occlusion\r\n                util_1.forEach(ddMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, true, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n                util_1.forEach(ddMark, function (score, mark) {\r\n                    var feature = featurize(xType, yType, false, mark);\r\n                    SCORE[feature] = score;\r\n                });\r\n            });\r\n        });\r\n        return SCORE;\r\n    }\r\n    MarkScore.init = init;\r\n    function getScore(specM, schema, opt) {\r\n        var mark = specM.getMark();\r\n        if (mark === mark_1.Mark.CIRCLE || mark === mark_1.Mark.SQUARE) {\r\n            mark = mark_1.Mark.POINT;\r\n        }\r\n        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\r\n        var xType = xEncQ ? type_1.getExtendedType(xEncQ) : type_1.NONE;\r\n        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\r\n        var yType = yEncQ ? type_1.getExtendedType(yEncQ) : type_1.NONE;\r\n        var isOccluded = !specM.isAggregate(); // FIXME\r\n        var feature = xType + '_' + yType + '_' + isOccluded + '_' + mark;\r\n        var featureScore = effectiveness_1.getFeatureScore(MarkScore.MARK_SCORE, feature);\r\n        return [featureScore];\r\n    }\r\n    MarkScore.getScore = getScore;\r\n})(MarkScore = exports.MarkScore || (exports.MarkScore = {}));\r\n//# sourceMappingURL=mark.js.map",
    "\"use strict\";\r\nvar scale_1 = require('vega-lite/src/scale');\r\nvar type_1 = require('vega-lite/src/type');\r\nvar encoding_1 = require('../../query/encoding');\r\n/**\r\n * Finer grained data types that takes binning and timeUnit into account.\r\n */\r\n(function (ExtendedType) {\r\n    ExtendedType[ExtendedType[\"Q\"] = type_1.Type.QUANTITATIVE] = \"Q\";\r\n    ExtendedType[ExtendedType[\"BIN_Q\"] = 'bin_' + type_1.Type.QUANTITATIVE] = \"BIN_Q\";\r\n    ExtendedType[ExtendedType[\"T\"] = type_1.Type.TEMPORAL] = \"T\";\r\n    /**\r\n     * Time Unit Temporal Field with time scale.\r\n     */\r\n    ExtendedType[ExtendedType[\"TIMEUNIT_T\"] = 'timeUnit_time'] = \"TIMEUNIT_T\";\r\n    /**\r\n     * Time Unit Temporal Field with ordinal scale.\r\n     */\r\n    ExtendedType[ExtendedType[\"TIMEUNIT_O\"] = 'timeUnit_' + type_1.Type.ORDINAL] = \"TIMEUNIT_O\";\r\n    ExtendedType[ExtendedType[\"O\"] = type_1.Type.ORDINAL] = \"O\";\r\n    ExtendedType[ExtendedType[\"N\"] = type_1.Type.NOMINAL] = \"N\";\r\n    ExtendedType[ExtendedType[\"NONE\"] = '-'] = \"NONE\";\r\n})(exports.ExtendedType || (exports.ExtendedType = {}));\r\nvar ExtendedType = exports.ExtendedType;\r\nexports.Q = ExtendedType.Q;\r\nexports.BIN_Q = ExtendedType.BIN_Q;\r\nexports.T = ExtendedType.T;\r\nexports.TIMEUNIT_T = ExtendedType.TIMEUNIT_T;\r\nexports.TIMEUNIT_O = ExtendedType.TIMEUNIT_O;\r\nexports.O = ExtendedType.O;\r\nexports.N = ExtendedType.N;\r\nexports.NONE = ExtendedType.NONE;\r\nfunction getExtendedType(encQ) {\r\n    if (encQ.bin) {\r\n        return ExtendedType.BIN_Q;\r\n    }\r\n    else if (encQ.timeUnit) {\r\n        return encoding_1.scaleType(encQ) === scale_1.ScaleType.ORDINAL ? ExtendedType.TIMEUNIT_O : ExtendedType.TIMEUNIT_T;\r\n    }\r\n    return encQ.type;\r\n}\r\nexports.getExtendedType = getExtendedType;\r\n//# sourceMappingURL=type.js.map",
    "\"use strict\";\r\nvar property_1 = require('../property');\r\nexports.name = 'fieldOrder';\r\nfunction score(specM, schema, opt) {\r\n    var fieldEnumSpecIndices = specM.enumSpecIndex.encodingIndicesByProperty[property_1.Property.FIELD];\r\n    if (!fieldEnumSpecIndices) {\r\n        return {\r\n            score: 0,\r\n            features: []\r\n        };\r\n    }\r\n    var encodings = specM.specQuery.encodings;\r\n    var numFields = schema.fieldSchemas.length;\r\n    var features = [];\r\n    var totalScore = 0, base = 1;\r\n    for (var i = fieldEnumSpecIndices.length - 1; i >= 0; i--) {\r\n        var index = fieldEnumSpecIndices[i];\r\n        var field = encodings[index].field;\r\n        var fieldEnumSpec = specM.enumSpecIndex.encodings[index].field;\r\n        var fieldIndex = schema.fieldSchema(field).index;\r\n        // reverse order field with lower index should get higher score and come first\r\n        var score_1 = -fieldIndex * base;\r\n        totalScore += score_1;\r\n        features.push({\r\n            score: score_1,\r\n            type: 'fieldOrder',\r\n            feature: \"field \" + fieldEnumSpec.name + \" is \" + field + \" (#\" + fieldIndex + \" in the schema)\"\r\n        });\r\n        base *= numFields;\r\n    }\r\n    return {\r\n        score: totalScore,\r\n        features: features\r\n    };\r\n}\r\nexports.score = score;\r\n//# sourceMappingURL=fieldorder.js.map",
    "\"use strict\";\r\nexports.effectiveness = require('./effectiveness/effectiveness');\r\nexports.aggregation = require('./aggregation');\r\nexports.fieldOrder = require('./fieldorder');\r\n/**\r\n * Registry for all encoding ranking functions\r\n */\r\nvar rankingRegistry = {};\r\n/**\r\n * Add an ordering function to the registry.\r\n */\r\nfunction register(name, keyFn) {\r\n    rankingRegistry[name] = keyFn;\r\n}\r\nexports.register = register;\r\nfunction get(name) {\r\n    return rankingRegistry[name];\r\n}\r\nexports.get = get;\r\nfunction rank(group, query, schema, level) {\r\n    if (!query.nest || level === query.nest.length) {\r\n        if (query.orderBy || query.chooseBy) {\r\n            group.items.sort(comparatorFactory(query.orderBy || query.chooseBy, schema, query.config));\r\n            if (query.chooseBy) {\r\n                if (group.items.length > 0) {\r\n                    // for chooseBy -- only keep the top-item\r\n                    group.items.splice(1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // sort lower-level nodes first because our ranking takes top-item in the subgroup\r\n        group.items.forEach(function (subgroup) {\r\n            rank(subgroup, query, schema, level + 1);\r\n        });\r\n        if (query.nest[level].orderGroupBy) {\r\n            group.items.sort(groupComparatorFactory(query.nest[level].orderGroupBy, schema, query.config));\r\n        }\r\n    }\r\n    return group;\r\n}\r\nexports.rank = rank;\r\nfunction comparatorFactory(name, schema, opt) {\r\n    return function (m1, m2) {\r\n        if (name instanceof Array) {\r\n            return getScoreDifference(name, m1, m2, schema, opt);\r\n        }\r\n        else {\r\n            return getScoreDifference([name], m1, m2, schema, opt);\r\n        }\r\n    };\r\n}\r\nexports.comparatorFactory = comparatorFactory;\r\nfunction groupComparatorFactory(name, schema, opt) {\r\n    return function (g1, g2) {\r\n        var m1 = g1.getTopSpecQueryModel();\r\n        var m2 = g2.getTopSpecQueryModel();\r\n        if (name instanceof Array) {\r\n            return getScoreDifference(name, m1, m2, schema, opt);\r\n        }\r\n        else {\r\n            return getScoreDifference([name], m1, m2, schema, opt);\r\n        }\r\n    };\r\n}\r\nexports.groupComparatorFactory = groupComparatorFactory;\r\nfunction getScoreDifference(name, m1, m2, schema, opt) {\r\n    for (var i = 0; i < name.length; i++) {\r\n        var scoreDifference = getScore(m2, name[i], schema, opt).score - getScore(m1, name[i], schema, opt).score;\r\n        if (scoreDifference !== 0) {\r\n            return scoreDifference;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\nfunction getScore(model, rankingName, schema, opt) {\r\n    if (model.getRankingScore(rankingName) !== undefined) {\r\n        return model.getRankingScore(rankingName);\r\n    }\r\n    var fn = get(rankingName);\r\n    var score = fn(model, schema, opt);\r\n    model.setRankingScore(rankingName, score);\r\n    return score;\r\n}\r\nexports.getScore = getScore;\r\nexports.EFFECTIVENESS = 'effectiveness';\r\nregister(exports.EFFECTIVENESS, exports.effectiveness.default);\r\nregister(exports.aggregation.name, exports.aggregation.score);\r\nregister(exports.fieldOrder.name, exports.fieldOrder.score);\r\n//# sourceMappingURL=ranking.js.map",
    "\"use strict\";\r\nvar type_1 = require('vega-lite/src/type');\r\nvar bin_1 = require('vega-lite/src/bin');\r\nvar timeunit_1 = require('vega-lite/src/timeunit');\r\nvar stats_1 = require('datalib/src/stats');\r\nvar type_2 = require('datalib/src/import/type');\r\nvar dlBin = require('datalib/src/bins/bins');\r\nvar config_1 = require('./config');\r\nvar util_1 = require('./util');\r\nvar Schema = (function () {\r\n    function Schema(fieldSchemas) {\r\n        this._fieldSchemas = fieldSchemas;\r\n        this._fieldSchemaIndex = fieldSchemas.reduce(function (m, fieldSchema) {\r\n            m[fieldSchema.field] = fieldSchema;\r\n            return m;\r\n        }, {});\r\n    }\r\n    /**\r\n     * Build a Schema object.\r\n     *\r\n     * @param data - a set of raw data\r\n     * @return a Schema object\r\n     */\r\n    Schema.build = function (data, opt) {\r\n        if (opt === void 0) { opt = {}; }\r\n        opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\r\n        // create profiles for each variable\r\n        var summaries = stats_1.summary(data);\r\n        var types = type_2.inferAll(data); // inferAll does stronger type inference than summary\r\n        var fieldSchemas = summaries.map(function (summary) {\r\n            var field = summary.field;\r\n            var primitiveType = types[field];\r\n            var distinct = summary.distinct;\r\n            var type;\r\n            if (primitiveType === PrimitiveType.NUMBER) {\r\n                type = type_1.Type.QUANTITATIVE;\r\n            }\r\n            else if (primitiveType === PrimitiveType.INTEGER) {\r\n                // use ordinal or nominal when cardinality of integer type is relatively low and the distinct values are less than an amount specified in options\r\n                if ((distinct < opt.numberNominalLimit) && (distinct / summary.count < opt.numberNominalProportion)) {\r\n                    type = type_1.Type.NOMINAL;\r\n                }\r\n                else {\r\n                    type = type_1.Type.QUANTITATIVE;\r\n                }\r\n            }\r\n            else if (primitiveType === PrimitiveType.DATE) {\r\n                type = type_1.Type.TEMPORAL;\r\n                // need to get correct min/max of date data because datalib's summary method does not\r\n                // calculate this correctly for date types.\r\n                summary.min = new Date(data[0][field]);\r\n                summary.max = new Date(data[0][field]);\r\n                for (var i = 0; i < data.length; i++) {\r\n                    var time = new Date(data[i][field]).getTime();\r\n                    if (time < summary.min.getTime()) {\r\n                        summary.min = new Date(time);\r\n                    }\r\n                    if (time > summary.max.getTime()) {\r\n                        summary.max = new Date(time);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                type = type_1.Type.NOMINAL;\r\n            }\r\n            return {\r\n                field: field,\r\n                type: type,\r\n                primitiveType: primitiveType,\r\n                stats: summary,\r\n                timeStats: {},\r\n                binStats: {}\r\n            };\r\n        });\r\n        // order the fieldSchemas (sort them)\r\n        var order = {\r\n            'nominal': 0,\r\n            'ordinal': 1,\r\n            'temporal': 2,\r\n            'quantitative': 3\r\n        };\r\n        fieldSchemas.sort(function (a, b) {\r\n            // first order by type: nominal < temporal < quantitative < ordinal\r\n            if (order[a.type] < order[b.type]) {\r\n                return -1;\r\n            }\r\n            else if (order[a.type] > order[b.type]) {\r\n                return 1;\r\n            }\r\n            else {\r\n                // then order by field (alphabetically)\r\n                return a.field.localeCompare(b.field);\r\n            }\r\n        });\r\n        // Add index for sorting\r\n        fieldSchemas.forEach(function (fieldSchema, index) { return fieldSchema.index = index; });\r\n        // calculate preset bins for quantitative and temporal data\r\n        for (var _i = 0, fieldSchemas_1 = fieldSchemas; _i < fieldSchemas_1.length; _i++) {\r\n            var fieldSchema = fieldSchemas_1[_i];\r\n            if (fieldSchema.type === type_1.Type.QUANTITATIVE) {\r\n                for (var _a = 0, _b = opt.maxBinsList; _a < _b.length; _a++) {\r\n                    var maxbins = _b[_a];\r\n                    fieldSchema.binStats[maxbins] = binSummary(maxbins, fieldSchema.stats);\r\n                }\r\n            }\r\n            else if (fieldSchema.type === type_1.Type.TEMPORAL) {\r\n                for (var _c = 0, _d = opt.timeUnits; _c < _d.length; _c++) {\r\n                    var unit = _d[_c];\r\n                    if (unit !== undefined) {\r\n                        fieldSchema.timeStats[unit] = timeSummary(unit, fieldSchema.stats);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Schema(fieldSchemas);\r\n    };\r\n    /** @return a list of the field names. */\r\n    Schema.prototype.fields = function () {\r\n        return this._fieldSchemas.map(function (fieldSchema) { return fieldSchema.field; });\r\n    };\r\n    Object.defineProperty(Schema.prototype, \"fieldSchemas\", {\r\n        /** @return a list of FieldSchemas */\r\n        get: function () {\r\n            return this._fieldSchemas;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Schema.prototype.fieldSchema = function (field) {\r\n        return this._fieldSchemaIndex[field];\r\n    };\r\n    /**\r\n     * @return primitive type of the field if exist, otherwise return null\r\n     */\r\n    Schema.prototype.primitiveType = function (field) {\r\n        return this._fieldSchemaIndex[field] ? this._fieldSchemaIndex[field].primitiveType : null;\r\n    };\r\n    /**\r\n     * @return type of measturement of the field if exist, otherwise return null\r\n     */\r\n    Schema.prototype.type = function (field) {\r\n        return this._fieldSchemaIndex[field] ? this._fieldSchemaIndex[field].type : null;\r\n    };\r\n    /** @return cardinality of the field associated with encQ, null if it doesn't exist.\r\n     *  @param augmentTimeUnitDomain - TimeUnit field domains will not be augmented if explicitly set to false.\r\n     */\r\n    Schema.prototype.cardinality = function (encQ, augmentTimeUnitDomain, excludeInvalid) {\r\n        if (augmentTimeUnitDomain === void 0) { augmentTimeUnitDomain = true; }\r\n        if (excludeInvalid === void 0) { excludeInvalid = false; }\r\n        var fieldSchema = this._fieldSchemaIndex[encQ.field];\r\n        if (encQ.aggregate || encQ.autoCount) {\r\n            return 1;\r\n        }\r\n        else if (encQ.bin) {\r\n            // encQ.bin will either be a boolean or a BinQuery\r\n            var bin;\r\n            if (typeof encQ.bin === 'boolean') {\r\n                // autoMaxBins defaults to 10 if channel is EnumSpec\r\n                bin = {\r\n                    maxbins: bin_1.autoMaxBins(encQ.channel)\r\n                };\r\n            }\r\n            else {\r\n                bin = encQ.bin;\r\n            }\r\n            var maxbins = bin.maxbins;\r\n            if (!fieldSchema.binStats[maxbins]) {\r\n                // need to calculate\r\n                fieldSchema.binStats[maxbins] = binSummary(maxbins, fieldSchema.stats);\r\n            }\r\n            // don't need to worry about excludeInvalid here because invalid values don't affect linearly binned field's cardinality\r\n            return fieldSchema.binStats[maxbins].distinct;\r\n        }\r\n        else if (encQ.timeUnit) {\r\n            if (augmentTimeUnitDomain) {\r\n                switch (encQ.timeUnit) {\r\n                    // TODO: this should not always be the case once Vega-Lite supports turning off domain augmenting (VL issue #1385)\r\n                    case timeunit_1.TimeUnit.SECONDS: return 60;\r\n                    case timeunit_1.TimeUnit.MINUTES: return 60;\r\n                    case timeunit_1.TimeUnit.HOURS: return 24;\r\n                    case timeunit_1.TimeUnit.DAY: return 7;\r\n                    case timeunit_1.TimeUnit.DATE: return 31;\r\n                    case timeunit_1.TimeUnit.MONTH: return 12;\r\n                    case timeunit_1.TimeUnit.QUARTER: return 4;\r\n                    case timeunit_1.TimeUnit.MILLISECONDS: return 1000;\r\n                }\r\n            }\r\n            var unit = encQ.timeUnit;\r\n            var timeStats = fieldSchema.timeStats;\r\n            // if the cardinality for the timeUnit is not cached, calculate it\r\n            if (!timeStats[unit]) {\r\n                timeStats[unit] = timeSummary(encQ.timeUnit, fieldSchema.stats);\r\n            }\r\n            if (excludeInvalid) {\r\n                return timeStats[unit].distinct - invalidCount(timeStats[unit].unique, ['Invalid Date', null]);\r\n            }\r\n            else {\r\n                return timeStats[unit].distinct;\r\n            }\r\n        }\r\n        else {\r\n            if (fieldSchema) {\r\n                if (excludeInvalid) {\r\n                    return fieldSchema.stats.distinct - invalidCount(fieldSchema.stats.unique, [NaN, null]);\r\n                }\r\n                else {\r\n                    return fieldSchema.stats.distinct;\r\n                }\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Given an EncodingQuery with a timeUnit, returns true if the date field\r\n     * has multiple distinct values for all parts of the timeUnit. Returns undefined\r\n     * if the timeUnit is undefined.\r\n     * i.e.\r\n     * ('yearmonth', [Jan 1 2000, Feb 2 2000] returns false)\r\n     * ('yearmonth', [Jan 1 2000, Feb 2 2001] returns true)\r\n     */\r\n    Schema.prototype.timeUnitHasVariation = function (encQ) {\r\n        if (!encQ.timeUnit) {\r\n            return;\r\n        }\r\n        // if there is no variation in `date`, there should not be variation in `day`\r\n        if (encQ.timeUnit === timeunit_1.TimeUnit.DAY) {\r\n            var dateEncQ = util_1.extend({}, encQ, { timeUnit: timeunit_1.TimeUnit.DATE });\r\n            if (this.cardinality(dateEncQ, false, true) <= 1) {\r\n                return false;\r\n            }\r\n        }\r\n        var fullTimeUnit = encQ.timeUnit;\r\n        for (var _i = 0, SINGLE_TIMEUNITS_1 = timeunit_1.SINGLE_TIMEUNITS; _i < SINGLE_TIMEUNITS_1.length; _i++) {\r\n            var singleUnit = SINGLE_TIMEUNITS_1[_i];\r\n            if (timeunit_1.containsTimeUnit(fullTimeUnit, singleUnit)) {\r\n                encQ.timeUnit = singleUnit;\r\n                if (this.cardinality(encQ, false, true) <= 1) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Schema.prototype.domain = function (encQ) {\r\n        // TODO: differentiate for field with bin / timeUnit\r\n        var fieldSchema = this._fieldSchemaIndex[encQ.field];\r\n        var domain = util_1.keys(fieldSchema.stats.unique);\r\n        if (fieldSchema.type === type_1.Type.QUANTITATIVE) {\r\n            // return [min, max], coerced into number types\r\n            return [+fieldSchema.stats.min, +fieldSchema.stats.max];\r\n        }\r\n        else if (fieldSchema.primitiveType === PrimitiveType.DATE) {\r\n            // return [min, max] dates\r\n            return [fieldSchema.stats.min, fieldSchema.stats.max];\r\n        }\r\n        else if (fieldSchema.primitiveType === PrimitiveType.INTEGER ||\r\n            fieldSchema.primitiveType === PrimitiveType.NUMBER) {\r\n            // coerce non-quantitative numerical data into number type\r\n            domain = domain.map(function (x) { return +x; });\r\n            return domain.sort(util_1.cmp);\r\n        }\r\n        return domain.map(function (x) {\r\n            // Convert 'null' to null as it is encoded similarly in datalib.\r\n            // This is wrong when it is a string 'null' but that rarely happens.\r\n            return x === 'null' ? null : x;\r\n        }).sort(util_1.cmp);\r\n    };\r\n    /**\r\n     * @return a Summary corresponding to the field of the given EncodingQuery\r\n     */\r\n    Schema.prototype.stats = function (encQ) {\r\n        // TODO: differentiate for field with bin / timeUnit vs without\r\n        var fieldSchema = this._fieldSchemaIndex[encQ.field];\r\n        return fieldSchema ? fieldSchema.stats : null;\r\n    };\r\n    return Schema;\r\n}());\r\nexports.Schema = Schema;\r\n/**\r\n * @return a summary of the binning scheme determined from the given max number of bins\r\n */\r\nfunction binSummary(maxbins, summary) {\r\n    var bin = dlBin({\r\n        min: summary.min,\r\n        max: summary.max,\r\n        maxbins: maxbins\r\n    });\r\n    // start with summary, pre-binning\r\n    var result = util_1.extend({}, summary);\r\n    result.unique = binUnique(bin, summary.unique);\r\n    result.distinct = (bin.stop - bin.start) / bin.step;\r\n    result.min = bin.start;\r\n    result.max = bin.stop;\r\n    return result;\r\n}\r\n/** @return a modified version of the passed summary with unique and distinct set according to the timeunit.\r\n *  Maps 'null' (string) keys to the null value and invalid dates to 'Invalid Date' in the unique dictionary.\r\n */\r\nfunction timeSummary(timeunit, summary) {\r\n    var result = util_1.extend({}, summary);\r\n    var unique = {};\r\n    util_1.keys(summary.unique).forEach(function (dateString) {\r\n        // don't convert null value because the Date constructor will actually convert it to a date\r\n        var date = (dateString === 'null') ? null : new Date(dateString);\r\n        // at this point, `date` is either the null value, a valid Date object, or \"Invalid Date\" which is a Date\r\n        var key;\r\n        if (date === null) {\r\n            key = null;\r\n        }\r\n        else if (isNaN(date.getTime())) {\r\n            key = 'Invalid Date';\r\n        }\r\n        else {\r\n            key = ((timeunit === timeunit_1.TimeUnit.DAY) ? date.getDay() : timeunit_1.convert(timeunit, date)).toString();\r\n        }\r\n        unique[key] = (unique[key] || 0) + summary.unique[dateString];\r\n    });\r\n    result.unique = unique;\r\n    result.distinct = util_1.keys(unique).length;\r\n    return result;\r\n}\r\n/**\r\n * @return a new unique object based off of the old unique count and a binning scheme\r\n */\r\nfunction binUnique(bin, oldUnique) {\r\n    var newUnique = {};\r\n    for (var value in oldUnique) {\r\n        var bucket = void 0;\r\n        if (value === null) {\r\n            bucket = null;\r\n        }\r\n        else if (isNaN(Number(value))) {\r\n            bucket = NaN;\r\n        }\r\n        else {\r\n            bucket = bin.value(Number(value));\r\n        }\r\n        newUnique[bucket] = (newUnique[bucket] || 0) + oldUnique[value];\r\n    }\r\n    return newUnique;\r\n}\r\n/** @return the number of items in list that occur as keys of unique */\r\nfunction invalidCount(unique, list) {\r\n    return list.reduce(function (prev, cur) {\r\n        return unique[cur] ? prev + 1 : prev;\r\n    }, 0);\r\n}\r\n(function (PrimitiveType) {\r\n    PrimitiveType[PrimitiveType[\"STRING\"] = 'string'] = \"STRING\";\r\n    PrimitiveType[PrimitiveType[\"NUMBER\"] = 'number'] = \"NUMBER\";\r\n    PrimitiveType[PrimitiveType[\"INTEGER\"] = 'integer'] = \"INTEGER\";\r\n    PrimitiveType[PrimitiveType[\"BOOLEAN\"] = 'boolean'] = \"BOOLEAN\";\r\n    PrimitiveType[PrimitiveType[\"DATE\"] = 'date'] = \"DATE\";\r\n})(exports.PrimitiveType || (exports.PrimitiveType = {}));\r\nvar PrimitiveType = exports.PrimitiveType;\r\n//# sourceMappingURL=schema.js.map",
    "\"use strict\";\r\nvar axis_1 = require('vega-lite/src/axis');\r\nvar channel_1 = require('vega-lite/src/channel');\r\nvar scale_1 = require('vega-lite/src/scale');\r\nvar type_1 = require('vega-lite/src/type');\r\nvar encoding_1 = require('./query/encoding');\r\nvar util_1 = require('./util');\r\nfunction stylize(answerSet, schema, opt) {\r\n    var encQIndex = {};\r\n    answerSet = answerSet.map(function (specM) {\r\n        if (opt.smallBandSizeForHighCardinalityOrFacet) {\r\n            specM = smallBandSizeForHighCardinalityOrFacet(specM, schema, encQIndex, opt);\r\n        }\r\n        if (opt.nominalColorScaleForHighCardinality) {\r\n            specM = nominalColorScaleForHighCardinality(specM, schema, encQIndex, opt);\r\n        }\r\n        if (opt.xAxisOnTopForHighYCardinalityWithoutColumn) {\r\n            specM = xAxisOnTopForHighYCardinalityWithoutColumn(specM, schema, encQIndex, opt);\r\n        }\r\n        return specM;\r\n    });\r\n    return answerSet;\r\n}\r\nexports.stylize = stylize;\r\nfunction smallBandSizeForHighCardinalityOrFacet(specM, schema, encQIndex, opt) {\r\n    [channel_1.Channel.ROW, channel_1.Channel.Y, channel_1.Channel.COLUMN, channel_1.Channel.X].forEach(function (channel) {\r\n        encQIndex[channel] = specM.getEncodingQueryByChannel(channel);\r\n    });\r\n    var yEncQ = encQIndex[channel_1.Channel.Y];\r\n    if (yEncQ !== undefined) {\r\n        if (encQIndex[channel_1.Channel.ROW] ||\r\n            schema.cardinality(yEncQ) > opt.smallBandSizeForHighCardinalityOrFacet.maxCardinality) {\r\n            // We check for undefined rather than\r\n            // yEncQ.scale = yEncQ.scale || {} to cover the case where\r\n            // yEncQ.scale has been set to false/null.\r\n            // This prevents us from incorrectly overriding scale and\r\n            // assigning a bandSize when scale is set to false.\r\n            if (yEncQ.scale === undefined) {\r\n                yEncQ.scale = {};\r\n            }\r\n            // We do not want to assign a bandSize if scale is set to false\r\n            // and we only apply this if the scale is (or can be) an ordinal scale.\r\n            if (yEncQ.scale && util_1.contains([scale_1.ScaleType.ORDINAL, undefined], encoding_1.scaleType(yEncQ))) {\r\n                if (!yEncQ.scale.bandSize) {\r\n                    yEncQ.scale.bandSize = 12;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    var xEncQ = encQIndex[channel_1.Channel.X];\r\n    if (xEncQ !== undefined) {\r\n        if (encQIndex[channel_1.Channel.COLUMN] ||\r\n            schema.cardinality(xEncQ) > opt.smallBandSizeForHighCardinalityOrFacet.maxCardinality) {\r\n            // Just like y, we don't want to do this if scale is null/false\r\n            if (xEncQ.scale === undefined) {\r\n                xEncQ.scale = {};\r\n            }\r\n            // We do not want to assign a bandSize if scale is set to false\r\n            // and we only apply this if the scale is (or can be) an ordinal scale.\r\n            if (xEncQ.scale && util_1.contains([scale_1.ScaleType.ORDINAL, undefined], encoding_1.scaleType(xEncQ))) {\r\n                if (!xEncQ.scale.bandSize) {\r\n                    xEncQ.scale.bandSize = 12;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return specM;\r\n}\r\nexports.smallBandSizeForHighCardinalityOrFacet = smallBandSizeForHighCardinalityOrFacet;\r\nfunction nominalColorScaleForHighCardinality(specM, schema, encQIndex, opt) {\r\n    encQIndex[channel_1.Channel.COLOR] = specM.getEncodingQueryByChannel(channel_1.Channel.COLOR);\r\n    var colorEncQ = encQIndex[channel_1.Channel.COLOR];\r\n    if ((colorEncQ !== undefined) && (colorEncQ.type === type_1.Type.NOMINAL) &&\r\n        (schema.cardinality(colorEncQ) > opt.nominalColorScaleForHighCardinality.maxCardinality)) {\r\n        if (colorEncQ.scale === undefined) {\r\n            colorEncQ.scale = {};\r\n        }\r\n        if (colorEncQ.scale) {\r\n            if (!colorEncQ.scale.range) {\r\n                colorEncQ.scale.range = opt.nominalColorScaleForHighCardinality.palette;\r\n            }\r\n        }\r\n    }\r\n    return specM;\r\n}\r\nexports.nominalColorScaleForHighCardinality = nominalColorScaleForHighCardinality;\r\nfunction xAxisOnTopForHighYCardinalityWithoutColumn(specM, schema, encQIndex, opt) {\r\n    [channel_1.Channel.COLUMN, channel_1.Channel.X, channel_1.Channel.Y].forEach(function (channel) {\r\n        encQIndex[channel] = specM.getEncodingQueryByChannel(channel);\r\n    });\r\n    if (encQIndex[channel_1.Channel.COLUMN] === undefined) {\r\n        var xEncQ = encQIndex[channel_1.Channel.X];\r\n        var yEncQ = encQIndex[channel_1.Channel.Y];\r\n        if (yEncQ !== undefined && yEncQ.field && encoding_1.scaleType(yEncQ) === scale_1.ScaleType.ORDINAL) {\r\n            if (xEncQ !== undefined) {\r\n                if (schema.cardinality(yEncQ) > opt.xAxisOnTopForHighYCardinalityWithoutColumn.maxCardinality) {\r\n                    if (xEncQ.axis === undefined) {\r\n                        xEncQ.axis = {};\r\n                    }\r\n                    if (xEncQ.axis && !xEncQ.axis.orient) {\r\n                        xEncQ.axis.orient = axis_1.AxisOrient.TOP;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return specM;\r\n}\r\nexports.xAxisOnTopForHighYCardinalityWithoutColumn = xAxisOnTopForHighYCardinalityWithoutColumn;\r\n//# sourceMappingURL=stylize.js.map",
    "\"use strict\";\r\nvar util_1 = require('datalib/src/util');\r\nvar util_2 = require('datalib/src/util');\r\nexports.cmp = util_2.cmp;\r\nexports.keys = util_2.keys;\r\nexports.duplicate = util_2.duplicate;\r\nexports.extend = util_2.extend;\r\nexports.isObject = util_2.isObject;\r\nexports.isArray = util_2.isArray;\r\nfunction contains(array, item) {\r\n    return array.indexOf(item) !== -1;\r\n}\r\nexports.contains = contains;\r\n;\r\nfunction every(arr, f) {\r\n    var i = 0, k;\r\n    for (k in arr) {\r\n        if (!f(arr[k], k, i++)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.every = every;\r\n;\r\nfunction forEach(obj, f, thisArg) {\r\n    if (obj.forEach) {\r\n        obj.forEach.call(thisArg, f);\r\n    }\r\n    else {\r\n        for (var k in obj) {\r\n            f.call(thisArg, obj[k], k, obj);\r\n        }\r\n    }\r\n}\r\nexports.forEach = forEach;\r\n;\r\nfunction some(arr, f) {\r\n    var i = 0, k;\r\n    for (k in arr) {\r\n        if (f(arr[k], k, i++)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.some = some;\r\n;\r\nfunction nestedMap(array, f) {\r\n    return array.map(function (a) {\r\n        if (util_1.isArray(a)) {\r\n            return nestedMap(a, f);\r\n        }\r\n        return f(a);\r\n    });\r\n}\r\nexports.nestedMap = nestedMap;\r\n/** Returns the array without the elements in item */\r\nfunction without(array, excludedItems) {\r\n    return array.filter(function (item) {\r\n        return !contains(excludedItems, item);\r\n    });\r\n}\r\nexports.without = without;\r\n//# sourceMappingURL=util.js.map"
  ]
}